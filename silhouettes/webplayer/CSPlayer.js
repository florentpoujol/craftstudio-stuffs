"use strict";
var THREE = THREE || {
    REVISION: "61"
};
self.console = self.console || {
    info: function () {},
    log: function () {},
    debug: function () {},
    warn: function () {},
    error: function () {}
};
String.prototype.trim = String.prototype.trim || function () {
    return this.replace(/^\s+|\s+$/g, "")
};
THREE.extend = function (a, b) {
    if (Object.keys)
        for (var c = Object.keys(b), d = 0, e = c.length; d < e; d++) {
            var f = c[d];
            Object.defineProperty(a, f, Object.getOwnPropertyDescriptor(b, f))
        } else
            for (f in c = {}.hasOwnProperty, b) c.call(b, f) && (a[f] = b[f]);
    return a
};
(function () {
    for (var a = 0, b = ["ms", "moz", "webkit", "o"], c = 0; c < b.length && !self.requestAnimationFrame; ++c) self.requestAnimationFrame = self[b[c] + "RequestAnimationFrame"], self.cancelAnimationFrame = self[b[c] + "CancelAnimationFrame"] || self[b[c] + "CancelRequestAnimationFrame"];
    void 0 === self.requestAnimationFrame && void 0 !== self.setTimeout && (self.requestAnimationFrame = function (b) {
        var c = Date.now(),
            f = Math.max(0, 16 - (c - a)),
            h = self.setTimeout(function () {
                b(c + f)
            }, f);
        a = c + f;
        return h
    });
    void 0 === self.cancelAnimationFrame && void 0 !== self.clearTimeout && (self.cancelAnimationFrame = function (a) {
        self.clearTimeout(a)
    })
})();
THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;
THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;
THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;
THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;
THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;
THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;
THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;
THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;
THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;
THREE.UVMapping = function () {};
THREE.CubeReflectionMapping = function () {};
THREE.CubeRefractionMapping = function () {};
THREE.SphericalReflectionMapping = function () {};
THREE.SphericalRefractionMapping = function () {};
THREE.RepeatWrapping = 1e3;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;
THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;
THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;
THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;
THREE.Color = function (a) {
    void 0 !== a && this.set(a);
    return this
};
THREE.Color.prototype = {
    constructor: THREE.Color,
    r: 1,
    g: 1,
    b: 1,
    set: function (a) {
        a instanceof THREE.Color ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
        return this
    },
    setHex: function (a) {
        a = Math.floor(a);
        this.r = (a >> 16 & 255) / 255;
        this.g = (a >> 8 & 255) / 255;
        this.b = (a & 255) / 255;
        return this
    },
    setRGB: function (a, b, c) {
        this.r = a;
        this.g = b;
        this.b = c;
        return this
    },
    setHSL: function (a, b, c) {
        if (0 === b) this.r = this.g = this.b = c;
        else {
            var d = function (a, b, c) {
                    0 > c && (c += 1);
                    1 < c && (c -= 1);
                    return c < 1 / 6 ? a + 6 * (b - a) * c : .5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a
                },
                b = .5 >= c ? c * (1 + b) : c + b - c * b,
                c = 2 * c - b;
            this.r = d(c, b, a + 1 / 3);
            this.g = d(c, b, a);
            this.b = d(c, b, a - 1 / 3)
        }
        return this
    },
    setStyle: function (a) {
        if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a)) return a = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a), this.r = Math.min(255, parseInt(a[1], 10)) / 255, this.g = Math.min(255, parseInt(a[2], 10)) / 255, this.b = Math.min(255, parseInt(a[3], 10)) / 255, this;
        if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a)) return a = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a), this.r = Math.min(100, parseInt(a[1], 10)) / 100, this.g = Math.min(100, parseInt(a[2], 10)) / 100, this.b = Math.min(100, parseInt(a[3], 10)) / 100, this;
        if (/^\#([0-9a-f]{6})$/i.test(a)) return a = /^\#([0-9a-f]{6})$/i.exec(a), this.setHex(parseInt(a[1], 16)), this;
        if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a)) return a = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a), this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)), this;
        if (/^(\w+)$/i.test(a)) return this.setHex(THREE.ColorKeywords[a]), this
    },
    copy: function (a) {
        this.r = a.r;
        this.g = a.g;
        this.b = a.b;
        return this
    },
    copyGammaToLinear: function (a) {
        this.r = a.r * a.r;
        this.g = a.g * a.g;
        this.b = a.b * a.b;
        return this
    },
    copyLinearToGamma: function (a) {
        this.r = Math.sqrt(a.r);
        this.g = Math.sqrt(a.g);
        this.b = Math.sqrt(a.b);
        return this
    },
    convertGammaToLinear: function () {
        var a = this.r,
            b = this.g,
            c = this.b;
        this.r = a * a;
        this.g = b * b;
        this.b = c * c;
        return this
    },
    convertLinearToGamma: function () {
        this.r = Math.sqrt(this.r);
        this.g = Math.sqrt(this.g);
        this.b = Math.sqrt(this.b);
        return this
    },
    getHex: function () {
        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
    },
    getHexString: function () {
        return ("000000" + this.getHex().toString(16)).slice(-6)
    },
    getHSL: function () {
        var a = {
            h: 0,
            s: 0,
            l: 0
        };
        return function () {
            var b = this.r,
                c = this.g,
                d = this.b,
                e = Math.max(b, c, d),
                f = Math.min(b, c, d),
                h, g = (f + e) / 2;
            if (f === e) f = h = 0;
            else {
                var i = e - f,
                    f = .5 >= g ? i / (e + f) : i / (2 - e - f);
                switch (e) {
                case b:
                    h = (c - d) / i + (c < d ? 6 : 0);
                    break;
                case c:
                    h = (d - b) / i + 2;
                    break;
                case d:
                    h = (b - c) / i + 4
                }
                h /= 6
            }
            a.h = h;
            a.s = f;
            a.l = g;
            return a
        }
    }(),
    getStyle: function () {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
    },
    offsetHSL: function (a, b, c) {
        var d = this.getHSL();
        d.h += a;
        d.s += b;
        d.l += c;
        this.setHSL(d.h, d.s, d.l);
        return this
    },
    add: function (a) {
        this.r += a.r;
        this.g += a.g;
        this.b += a.b;
        return this
    },
    addColors: function (a, b) {
        this.r = a.r + b.r;
        this.g = a.g + b.g;
        this.b = a.b + b.b;
        return this
    },
    addScalar: function (a) {
        this.r += a;
        this.g += a;
        this.b += a;
        return this
    },
    multiply: function (a) {
        this.r *= a.r;
        this.g *= a.g;
        this.b *= a.b;
        return this
    },
    multiplyScalar: function (a) {
        this.r *= a;
        this.g *= a;
        this.b *= a;
        return this
    },
    lerp: function (a, b) {
        this.r += (a.r - this.r) * b;
        this.g += (a.g - this.g) * b;
        this.b += (a.b - this.b) * b;
        return this
    },
    equals: function (a) {
        return a.r === this.r && a.g === this.g && a.b === this.b
    },
    fromArray: function (a) {
        this.r = a[0];
        this.g = a[1];
        this.b = a[2];
        return this
    },
    toArray: function () {
        return [this.r, this.g, this.b]
    },
    clone: function () {
        return (new THREE.Color).setRGB(this.r, this.g, this.b)
    }
};
THREE.ColorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
};
THREE.Quaternion = function (a, b, c, d) {
    this._x = a || 0;
    this._y = b || 0;
    this._z = c || 0;
    this._w = void 0 !== d ? d : 1
};
THREE.Quaternion.prototype = {
    constructor: THREE.Quaternion,
    _x: 0,
    _y: 0,
    _z: 0,
    _w: 0,
    _euler: void 0,
    _updateEuler: function () {
        void 0 !== this._euler && this._euler.setFromQuaternion(this, void 0, !1)
    },
    get x() {
        return this._x
    },
    set x(a) {
        this._x = a;
        this._updateEuler()
    },
    get y() {
        return this._y
    },
    set y(a) {
        this._y = a;
        this._updateEuler()
    },
    get z() {
        return this._z
    },
    set z(a) {
        this._z = a;
        this._updateEuler()
    },
    get w() {
        return this._w
    },
    set w(a) {
        this._w = a;
        this._updateEuler()
    },
    set: function (a, b, c, d) {
        this._x = a;
        this._y = b;
        this._z = c;
        this._w = d;
        this._updateEuler();
        return this
    },
    copy: function (a) {
        this._x = a._x;
        this._y = a._y;
        this._z = a._z;
        this._w = a._w;
        this._updateEuler();
        return this
    },
    setFromEuler: function (a, b) {
        if (!1 === a instanceof THREE.Euler) throw Error("ERROR: Quaternion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
        var c = Math.cos(a._x / 2),
            d = Math.cos(a._y / 2),
            e = Math.cos(a._z / 2),
            f = Math.sin(a._x / 2),
            h = Math.sin(a._y / 2),
            g = Math.sin(a._z / 2);
        "XYZ" === a.order ? (this._x = f * d * e + c * h * g, this._y = c * h * e - f * d * g, this._z = c * d * g + f * h * e, this._w = c * d * e - f * h * g) : "YXZ" === a.order ? (this._x = f * d * e + c * h * g, this._y = c * h * e - f * d * g, this._z = c * d * g - f * h * e, this._w = c * d * e + f * h * g) : "ZXY" === a.order ? (this._x = f * d * e - c * h * g, this._y = c * h * e + f * d * g, this._z = c * d * g + f * h * e, this._w = c * d * e - f * h * g) : "ZYX" === a.order ? (this._x = f * d * e - c * h * g, this._y = c * h * e + f * d * g, this._z = c * d * g - f * h * e, this._w = c * d * e + f * h * g) : "YZX" === a.order ? (this._x = f * d * e + c * h * g, this._y = c * h * e + f * d * g, this._z = c * d * g - f * h * e, this._w = c * d * e - f * h * g) : "XZY" === a.order && (this._x = f * d * e - c * h * g, this._y = c * h * e - f * d * g, this._z = c * d * g + f * h * e, this._w = c * d * e + f * h * g);
        !1 !== b && this._updateEuler();
        return this
    },
    setFromAxisAngle: function (a, b) {
        var c = b / 2,
            d = Math.sin(c);
        this._x = a.x * d;
        this._y = a.y * d;
        this._z = a.z * d;
        this._w = Math.cos(c);
        this._updateEuler();
        return this
    },
    setFromRotationMatrix: function (a) {
        var b = a.elements,
            c = b[0],
            a = b[4],
            d = b[8],
            e = b[1],
            f = b[5],
            h = b[9],
            g = b[2],
            i = b[6],
            b = b[10],
            k = c + f + b;
        0 < k ? (c = .5 / Math.sqrt(k + 1), this._w = .25 / c, this._x = (i - h) * c, this._y = (d - g) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (i - h) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + g) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - g) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (h + i) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + g) / c, this._y = (h + i) / c, this._z = .25 * c);
        this._updateEuler();
        return this
    },
    inverse: function () {
        this.conjugate().normalize();
        return this
    },
    conjugate: function () {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._updateEuler();
        return this
    },
    lengthSq: function () {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    },
    length: function () {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    },
    normalize: function () {
        var a = this.length();
        0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
        return this
    },
    multiply: function (a, b) {
        return void 0 !== b ? (console.warn("DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
    },
    multiplyQuaternions: function (a, b) {
        var c = a._x,
            d = a._y,
            e = a._z,
            f = a._w,
            h = b._x,
            g = b._y,
            i = b._z,
            k = b._w;
        this._x = c * k + f * h + d * i - e * g;
        this._y = d * k + f * g + e * h - c * i;
        this._z = e * k + f * i + c * g - d * h;
        this._w = f * k - c * h - d * g - e * i;
        this._updateEuler();
        return this
    },
    multiplyVector3: function (a) {
        console.warn("DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
        return a.applyQuaternion(this)
    },
    slerp: function (a, b) {
        var c = this._x,
            d = this._y,
            e = this._z,
            f = this._w,
            h = f * a._w + c * a._x + d * a._y + e * a._z;
        0 > h ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, h = -h) : this.copy(a);
        if (1 <= h) return this._w = f, this._x = c, this._y = d, this._z = e, this;
        var g = Math.acos(h),
            i = Math.sqrt(1 - h * h);
        if (.001 > Math.abs(i)) return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this;
        h = Math.sin((1 - b) * g) / i;
        g = Math.sin(b * g) / i;
        this._w = f * h + this._w * g;
        this._x = c * h + this._x * g;
        this._y = d * h + this._y * g;
        this._z = e * h + this._z * g;
        this._updateEuler();
        return this
    },
    equals: function (a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
    },
    fromArray: function (a) {
        this._x = a[0];
        this._y = a[1];
        this._z = a[2];
        this._w = a[3];
        this._updateEuler();
        return this
    },
    toArray: function () {
        return [this._x, this._y, this._z, this._w]
    },
    clone: function () {
        return new THREE.Quaternion(this._x, this._y, this._z, this._w)
    }
};
THREE.Quaternion.slerp = function (a, b, c, d) {
    return c.copy(a).slerp(b, d)
};
THREE.Vector2 = function (a, b) {
    this.x = a || 0;
    this.y = b || 0
};
THREE.Vector2.prototype = {
    constructor: THREE.Vector2,
    set: function (a, b) {
        this.x = a;
        this.y = b;
        return this
    },
    setX: function (a) {
        this.x = a;
        return this
    },
    setY: function (a) {
        this.y = a;
        return this
    },
    setComponent: function (a, b) {
        switch (a) {
        case 0:
            this.x = b;
            break;
        case 1:
            this.y = b;
            break;
        default:
            throw Error("index is out of range: " + a)
        }
    },
    getComponent: function (a) {
        switch (a) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw Error("index is out of range: " + a)
        }
    },
    copy: function (a) {
        this.x = a.x;
        this.y = a.y;
        return this
    },
    add: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
        this.x += a.x;
        this.y += a.y;
        return this
    },
    addVectors: function (a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this
    },
    addScalar: function (a) {
        this.x += a;
        this.y += a;
        return this
    },
    sub: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
        this.x -= a.x;
        this.y -= a.y;
        return this
    },
    subVectors: function (a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this
    },
    multiplyScalar: function (a) {
        this.x *= a;
        this.y *= a;
        return this
    },
    divideScalar: function (a) {
        0 !== a ? (a = 1 / a, this.x *= a, this.y *= a) : this.y = this.x = 0;
        return this
    },
    min: function (a) {
        this.x > a.x && (this.x = a.x);
        this.y > a.y && (this.y = a.y);
        return this
    },
    max: function (a) {
        this.x < a.x && (this.x = a.x);
        this.y < a.y && (this.y = a.y);
        return this
    },
    clamp: function (a, b) {
        this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
        this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
        return this
    },
    negate: function () {
        return this.multiplyScalar(-1)
    },
    dot: function (a) {
        return this.x * a.x + this.y * a.y
    },
    lengthSq: function () {
        return this.x * this.x + this.y * this.y
    },
    length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    },
    normalize: function () {
        return this.divideScalar(this.length())
    },
    distanceTo: function (a) {
        return Math.sqrt(this.distanceToSquared(a))
    },
    distanceToSquared: function (a) {
        var b = this.x - a.x,
            a = this.y - a.y;
        return b * b + a * a
    },
    setLength: function (a) {
        var b = this.length();
        0 !== b && a !== b && this.multiplyScalar(a / b);
        return this
    },
    lerp: function (a, b) {
        this.x += (a.x - this.x) * b;
        this.y += (a.y - this.y) * b;
        return this
    },
    equals: function (a) {
        return a.x === this.x && a.y === this.y
    },
    fromArray: function (a) {
        this.x = a[0];
        this.y = a[1];
        return this
    },
    toArray: function () {
        return [this.x, this.y]
    },
    clone: function () {
        return new THREE.Vector2(this.x, this.y)
    }
};
THREE.Vector3 = function (a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0
};
THREE.Vector3.prototype = {
    constructor: THREE.Vector3,
    set: function (a, b, c) {
        this.x = a;
        this.y = b;
        this.z = c;
        return this
    },
    setX: function (a) {
        this.x = a;
        return this
    },
    setY: function (a) {
        this.y = a;
        return this
    },
    setZ: function (a) {
        this.z = a;
        return this
    },
    setComponent: function (a, b) {
        switch (a) {
        case 0:
            this.x = b;
            break;
        case 1:
            this.y = b;
            break;
        case 2:
            this.z = b;
            break;
        default:
            throw Error("index is out of range: " + a)
        }
    },
    getComponent: function (a) {
        switch (a) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw Error("index is out of range: " + a)
        }
    },
    copy: function (a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        return this
    },
    add: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        return this
    },
    addScalar: function (a) {
        this.x += a;
        this.y += a;
        this.z += a;
        return this
    },
    addVectors: function (a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this
    },
    sub: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
        return this
    },
    subVectors: function (a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this
    },
    multiply: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b);
        this.x *= a.x;
        this.y *= a.y;
        this.z *= a.z;
        return this
    },
    multiplyScalar: function (a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        return this
    },
    multiplyVectors: function (a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this
    },
    applyMatrix3: function (a) {
        var b = this.x,
            c = this.y,
            d = this.z,
            a = a.elements;
        this.x = a[0] * b + a[3] * c + a[6] * d;
        this.y = a[1] * b + a[4] * c + a[7] * d;
        this.z = a[2] * b + a[5] * c + a[8] * d;
        return this
    },
    applyMatrix4: function (a) {
        var b = this.x,
            c = this.y,
            d = this.z,
            a = a.elements;
        this.x = a[0] * b + a[4] * c + a[8] * d + a[12];
        this.y = a[1] * b + a[5] * c + a[9] * d + a[13];
        this.z = a[2] * b + a[6] * c + a[10] * d + a[14];
        return this
    },
    applyProjection: function (a) {
        var b = this.x,
            c = this.y,
            d = this.z,
            a = a.elements,
            e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
        this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;
        this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
        this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
        return this
    },
    applyQuaternion: function (a) {
        var b = this.x,
            c = this.y,
            d = this.z,
            e = a.x,
            f = a.y,
            h = a.z,
            a = a.w,
            g = a * b + f * d - h * c,
            i = a * c + h * b - e * d,
            k = a * d + e * c - f * b,
            b = -e * b - f * c - h * d;
        this.x = g * a + b * -e + i * -h - k * -f;
        this.y = i * a + b * -f + k * -e - g * -h;
        this.z = k * a + b * -h + g * -f - i * -e;
        return this
    },
    transformDirection: function (a) {
        var b = this.x,
            c = this.y,
            d = this.z,
            a = a.elements;
        this.x = a[0] * b + a[4] * c + a[8] * d;
        this.y = a[1] * b + a[5] * c + a[9] * d;
        this.z = a[2] * b + a[6] * c + a[10] * d;
        this.normalize();
        return this
    },
    divide: function (a) {
        this.x /= a.x;
        this.y /= a.y;
        this.z /= a.z;
        return this
    },
    divideScalar: function (a) {
        0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0;
        return this
    },
    min: function (a) {
        this.x > a.x && (this.x = a.x);
        this.y > a.y && (this.y = a.y);
        this.z > a.z && (this.z = a.z);
        return this
    },
    max: function (a) {
        this.x < a.x && (this.x = a.x);
        this.y < a.y && (this.y = a.y);
        this.z < a.z && (this.z = a.z);
        return this
    },
    clamp: function (a, b) {
        this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
        this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
        this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
        return this
    },
    negate: function () {
        return this.multiplyScalar(-1)
    },
    dot: function (a) {
        return this.x * a.x + this.y * a.y + this.z * a.z
    },
    lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z
    },
    length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    },
    lengthManhattan: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    },
    normalize: function () {
        return this.divideScalar(this.length())
    },
    setLength: function (a) {
        var b = this.length();
        0 !== b && a !== b && this.multiplyScalar(a / b);
        return this
    },
    lerp: function (a, b) {
        this.x += (a.x - this.x) * b;
        this.y += (a.y - this.y) * b;
        this.z += (a.z - this.z) * b;
        return this
    },
    cross: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b);
        var c = this.x,
            d = this.y,
            e = this.z;
        this.x = d * a.z - e * a.y;
        this.y = e * a.x - c * a.z;
        this.z = c * a.y - d * a.x;
        return this
    },
    crossVectors: function (a, b) {
        var c = a.x,
            d = a.y,
            e = a.z,
            f = b.x,
            h = b.y,
            g = b.z;
        this.x = d * g - e * h;
        this.y = e * f - c * g;
        this.z = c * h - d * f;
        return this
    },
    angleTo: function (a) {
        a = this.dot(a) / (this.length() * a.length());
        return Math.acos(THREE.Math.clamp(a, -1, 1))
    },
    distanceTo: function (a) {
        return Math.sqrt(this.distanceToSquared(a))
    },
    distanceToSquared: function (a) {
        var b = this.x - a.x,
            c = this.y - a.y,
            a = this.z - a.z;
        return b * b + c * c + a * a
    },
    setEulerFromRotationMatrix: function () {
        console.error("REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.")
    },
    setEulerFromQuaternion: function () {
        console.error("REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.")
    },
    getPositionFromMatrix: function (a) {
        this.x = a.elements[12];
        this.y = a.elements[13];
        this.z = a.elements[14];
        return this
    },
    getScaleFromMatrix: function (a) {
        var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(),
            c = this.set(a.elements[4], a.elements[5], a.elements[6]).length(),
            a = this.set(a.elements[8], a.elements[9], a.elements[10]).length();
        this.x = b;
        this.y = c;
        this.z = a;
        return this
    },
    getColumnFromMatrix: function (a, b) {
        var c = 4 * a,
            d = b.elements;
        this.x = d[c];
        this.y = d[c + 1];
        this.z = d[c + 2];
        return this
    },
    equals: function (a) {
        return a.x === this.x && a.y === this.y && a.z === this.z
    },
    fromArray: function (a) {
        this.x = a[0];
        this.y = a[1];
        this.z = a[2];
        return this
    },
    toArray: function () {
        return [this.x, this.y, this.z]
    },
    clone: function () {
        return new THREE.Vector3(this.x, this.y, this.z)
    }
};
THREE.extend(THREE.Vector3.prototype, {
    applyEuler: function () {
        var a = new THREE.Quaternion;
        return function (b) {
            !1 === b instanceof THREE.Euler && console.error("ERROR: Vector3's .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
            this.applyQuaternion(a.setFromEuler(b));
            return this
        }
    }(),
    applyAxisAngle: function () {
        var a = new THREE.Quaternion;
        return function (b, c) {
            this.applyQuaternion(a.setFromAxisAngle(b, c));
            return this
        }
    }(),
    projectOnVector: function () {
        var a = new THREE.Vector3;
        return function (b) {
            a.copy(b).normalize();
            b = this.dot(a);
            return this.copy(a).multiplyScalar(b)
        }
    }(),
    projectOnPlane: function () {
        var a = new THREE.Vector3;
        return function (b) {
            a.copy(this).projectOnVector(b);
            return this.sub(a)
        }
    }(),
    reflect: function () {
        var a = new THREE.Vector3;
        return function (b) {
            a.copy(this).projectOnVector(b).multiplyScalar(2);
            return this.subVectors(a, this)
        }
    }()
});
THREE.Vector4 = function (a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.w = void 0 !== d ? d : 1
};
THREE.Vector4.prototype = {
    constructor: THREE.Vector4,
    set: function (a, b, c, d) {
        this.x = a;
        this.y = b;
        this.z = c;
        this.w = d;
        return this
    },
    setX: function (a) {
        this.x = a;
        return this
    },
    setY: function (a) {
        this.y = a;
        return this
    },
    setZ: function (a) {
        this.z = a;
        return this
    },
    setW: function (a) {
        this.w = a;
        return this
    },
    setComponent: function (a, b) {
        switch (a) {
        case 0:
            this.x = b;
            break;
        case 1:
            this.y = b;
            break;
        case 2:
            this.z = b;
            break;
        case 3:
            this.w = b;
            break;
        default:
            throw Error("index is out of range: " + a)
        }
    },
    getComponent: function (a) {
        switch (a) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw Error("index is out of range: " + a)
        }
    },
    copy: function (a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = void 0 !== a.w ? a.w : 1;
        return this
    },
    add: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        this.w += a.w;
        return this
    },
    addScalar: function (a) {
        this.x += a;
        this.y += a;
        this.z += a;
        this.w += a;
        return this
    },
    addVectors: function (a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this
    },
    sub: function (a, b) {
        if (void 0 !== b) return console.warn("DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
        this.w -= a.w;
        return this
    },
    subVectors: function (a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this
    },
    multiplyScalar: function (a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this
    },
    applyMatrix4: function (a) {
        var b = this.x,
            c = this.y,
            d = this.z,
            e = this.w,
            a = a.elements;
        this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
        this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
        this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
        this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
        return this
    },
    divideScalar: function (a) {
        0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a) : (this.z = this.y = this.x = 0, this.w = 1);
        return this
    },
    setAxisAngleFromQuaternion: function (a) {
        this.w = 2 * Math.acos(a.w);
        var b = Math.sqrt(1 - a.w * a.w);
        1e-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
        return this
    },
    setAxisAngleFromRotationMatrix: function (a) {
        var b, c, d, a = a.elements,
            e = a[0];
        d = a[4];
        var f = a[8],
            h = a[1],
            g = a[5],
            i = a[9];
        c = a[2];
        b = a[6];
        var k = a[10];
        if (.01 > Math.abs(d - h) && .01 > Math.abs(f - c) && .01 > Math.abs(i - b)) {
            if (.1 > Math.abs(d + h) && .1 > Math.abs(f + c) && .1 > Math.abs(i + b) && .1 > Math.abs(e + g + k - 3)) return this.set(1, 0, 0, 0), this;
            a = Math.PI;
            e = (e + 1) / 2;
            g = (g + 1) / 2;
            k = (k + 1) / 2;
            d = (d + h) / 4;
            f = (f + c) / 4;
            i = (i + b) / 4;
            e > g && e > k ? .01 > e ? (b = 0, d = c = .707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : g > k ? .01 > g ? (b = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(g), b = d / c, d = i / c) : .01 > k ? (c = b = .707106781, d = 0) : (d = Math.sqrt(k), b = f / d, c = i / d);
            this.set(b, c, d, a);
            return this
        }
        a = Math.sqrt((b - i) * (b - i) + (f - c) * (f - c) + (h - d) * (h - d));.001 > Math.abs(a) && (a = 1);
        this.x = (b - i) / a;
        this.y = (f - c) / a;
        this.z = (h - d) / a;
        this.w = Math.acos((e + g + k - 1) / 2);
        return this
    },
    min: function (a) {
        this.x > a.x && (this.x = a.x);
        this.y > a.y && (this.y = a.y);
        this.z > a.z && (this.z = a.z);
        this.w > a.w && (this.w = a.w);
        return this
    },
    max: function (a) {
        this.x < a.x && (this.x = a.x);
        this.y < a.y && (this.y = a.y);
        this.z < a.z && (this.z = a.z);
        this.w < a.w && (this.w = a.w);
        return this
    },
    clamp: function (a, b) {
        this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
        this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
        this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
        this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w);
        return this
    },
    negate: function () {
        return this.multiplyScalar(-1)
    },
    dot: function (a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
    },
    lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    },
    length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    },
    lengthManhattan: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    },
    normalize: function () {
        return this.divideScalar(this.length())
    },
    setLength: function (a) {
        var b = this.length();
        0 !== b && a !== b && this.multiplyScalar(a / b);
        return this
    },
    lerp: function (a, b) {
        this.x += (a.x - this.x) * b;
        this.y += (a.y - this.y) * b;
        this.z += (a.z - this.z) * b;
        this.w += (a.w - this.w) * b;
        return this
    },
    equals: function (a) {
        return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
    },
    fromArray: function (a) {
        this.x = a[0];
        this.y = a[1];
        this.z = a[2];
        this.w = a[3];
        return this
    },
    toArray: function () {
        return [this.x, this.y, this.z, this.w]
    },
    clone: function () {
        return new THREE.Vector4(this.x, this.y, this.z, this.w)
    }
};
THREE.Euler = function (a, b, c, d) {
    this._x = a || 0;
    this._y = b || 0;
    this._z = c || 0;
    this._order = d || THREE.Euler.DefaultOrder
};
THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
THREE.Euler.DefaultOrder = "XYZ";
THREE.Euler.prototype = {
    constructor: THREE.Euler,
    _x: 0,
    _y: 0,
    _z: 0,
    _order: THREE.Euler.DefaultOrder,
    _quaternion: void 0,
    _updateQuaternion: function () {
        void 0 !== this._quaternion && this._quaternion.setFromEuler(this, !1)
    },
    get x() {
        return this._x
    },
    set x(a) {
        this._x = a;
        this._updateQuaternion()
    },
    get y() {
        return this._y
    },
    set y(a) {
        this._y = a;
        this._updateQuaternion()
    },
    get z() {
        return this._z
    },
    set z(a) {
        this._z = a;
        this._updateQuaternion()
    },
    get order() {
        return this._order
    },
    set order(a) {
        this._order = a;
        this._updateQuaternion()
    },
    set: function (a, b, c, d) {
        this._x = a;
        this._y = b;
        this._z = c;
        this._order = d || this._order;
        this._updateQuaternion();
        return this
    },
    copy: function (a) {
        this._x = a._x;
        this._y = a._y;
        this._z = a._z;
        this._order = a._order;
        this._updateQuaternion();
        return this
    },
    setFromRotationMatrix: function (a, b) {
        function c(a) {
            return Math.min(Math.max(a, -1), 1)
        }
        var d = a.elements,
            e = d[0],
            f = d[4],
            h = d[8],
            g = d[1],
            i = d[5],
            k = d[9],
            m = d[2],
            l = d[6],
            d = d[10],
            b = b || this._order;
        "XYZ" === b ? (this._y = Math.asin(c(h)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-k, d), this._z = Math.atan2(-f, e)) : (this._x = Math.atan2(l, i), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-c(k)), .99999 > Math.abs(k) ? (this._y = Math.atan2(h, d), this._z = Math.atan2(g, i)) : (this._y = Math.atan2(-m, e), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(c(l)), .99999 > Math.abs(l) ? (this._y = Math.atan2(-m, d), this._z = Math.atan2(-f, i)) : (this._y = 0, this._z = Math.atan2(g, e))) : "ZYX" === b ? (this._y = Math.asin(-c(m)), .99999 > Math.abs(m) ? (this._x = Math.atan2(l, d), this._z = Math.atan2(g, e)) : (this._x = 0, this._z = Math.atan2(-f, i))) : "YZX" === b ? (this._z = Math.asin(c(g)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-k, i), this._y = Math.atan2(-m, e)) : (this._x = 0, this._y = Math.atan2(h, d))) : "XZY" === b ? (this._z = Math.asin(-c(f)), .99999 > Math.abs(f) ? (this._x = Math.atan2(l, i), this._y = Math.atan2(h, e)) : (this._x = Math.atan2(-k, d), this._y = 0)) : console.warn("WARNING: Euler.setFromRotationMatrix() given unsupported order: " + b);
        this._order = b;
        this._updateQuaternion();
        return this
    },
    setFromQuaternion: function (a, b, c) {
        function d(a) {
            return Math.min(Math.max(a, -1), 1)
        }
        var e = a.x * a.x,
            f = a.y * a.y,
            h = a.z * a.z,
            g = a.w * a.w,
            b = b || this._order;
        "XYZ" === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.y * a.z), g - e - f + h), this._y = Math.asin(d(2 * (a.x * a.z + a.y * a.w))), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), g + e - f - h)) : "YXZ" === b ? (this._x = Math.asin(d(2 * (a.x * a.w - a.y * a.z))), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), g - e - f + h), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), g - e + f - h)) : "ZXY" === b ? (this._x = Math.asin(d(2 * (a.x * a.w + a.y * a.z))), this._y = Math.atan2(2 * (a.y * a.w - a.z * a.x), g - e - f + h), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), g - e + f - h)) : "ZYX" === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.z * a.y), g - e - f + h), this._y = Math.asin(d(2 * (a.y * a.w - a.x * a.z))), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), g + e - f - h)) : "YZX" === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.z * a.y), g - e + f - h), this._y = Math.atan2(2 * (a.y * a.w - a.x * a.z), g + e - f - h), this._z = Math.asin(d(2 * (a.x * a.y + a.z * a.w)))) : "XZY" === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.y * a.z), g - e + f - h), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), g + e - f - h), this._z = Math.asin(d(2 * (a.z * a.w - a.x * a.y)))) : console.warn("WARNING: Euler.setFromQuaternion() given unsupported order: " + b);
        this._order = b;
        !1 !== c && this._updateQuaternion();
        return this
    },
    reorder: function () {
        var a = new THREE.Quaternion;
        return function (b) {
            a.setFromEuler(this);
            this.setFromQuaternion(a, b)
        }
    }(),
    fromArray: function (a) {
        this._x = a[0];
        this._y = a[1];
        this._z = a[2];
        void 0 !== a[3] && (this._order = a[3]);
        this._updateQuaternion();
        return this
    },
    toArray: function () {
        return [this._x, this._y, this._z, this._order]
    },
    equals: function (a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
    },
    clone: function () {
        return new THREE.Euler(this._x, this._y, this._z, this._order)
    }
};
THREE.Line3 = function (a, b) {
    this.start = void 0 !== a ? a : new THREE.Vector3;
    this.end = void 0 !== b ? b : new THREE.Vector3
};
THREE.Line3.prototype = {
    constructor: THREE.Line3,
    set: function (a, b) {
        this.start.copy(a);
        this.end.copy(b);
        return this
    },
    copy: function (a) {
        this.start.copy(a.start);
        this.end.copy(a.end);
        return this
    },
    center: function (a) {
        return (a || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(.5)
    },
    delta: function (a) {
        return (a || new THREE.Vector3).subVectors(this.end, this.start)
    },
    distanceSq: function () {
        return this.start.distanceToSquared(this.end)
    },
    distance: function () {
        return this.start.distanceTo(this.end)
    },
    at: function (a, b) {
        var c = b || new THREE.Vector3;
        return this.delta(c).multiplyScalar(a).add(this.start)
    },
    closestPointToPointParameter: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3;
        return function (c, d) {
            a.subVectors(c, this.start);
            b.subVectors(this.end, this.start);
            var e = b.dot(b),
                e = b.dot(a) / e;
            d && (e = THREE.Math.clamp(e, 0, 1));
            return e
        }
    }(),
    closestPointToPoint: function (a, b, c) {
        a = this.closestPointToPointParameter(a, b);
        c = c || new THREE.Vector3;
        return this.delta(c).multiplyScalar(a).add(this.start)
    },
    applyMatrix4: function (a) {
        this.start.applyMatrix4(a);
        this.end.applyMatrix4(a);
        return this
    },
    equals: function (a) {
        return a.start.equals(this.start) && a.end.equals(this.end)
    },
    clone: function () {
        return (new THREE.Line3).copy(this)
    }
};
THREE.Box2 = function (a, b) {
    this.min = void 0 !== a ? a : new THREE.Vector2(Infinity, Infinity);
    this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity, -Infinity)
};
THREE.Box2.prototype = {
    constructor: THREE.Box2,
    set: function (a, b) {
        this.min.copy(a);
        this.max.copy(b);
        return this
    },
    setFromPoints: function (a) {
        if (0 < a.length) {
            var b = a[0];
            this.min.copy(b);
            this.max.copy(b);
            for (var c = 1, d = a.length; c < d; c++) b = a[c], b.x < this.min.x ? this.min.x = b.x : b.x > this.max.x && (this.max.x = b.x), b.y < this.min.y ? this.min.y = b.y : b.y > this.max.y && (this.max.y = b.y)
        } else this.makeEmpty();
        return this
    },
    setFromCenterAndSize: function () {
        var a = new THREE.Vector2;
        return function (b, c) {
            var d = a.copy(c).multiplyScalar(.5);
            this.min.copy(b).sub(d);
            this.max.copy(b).add(d);
            return this
        }
    }(),
    copy: function (a) {
        this.min.copy(a.min);
        this.max.copy(a.max);
        return this
    },
    makeEmpty: function () {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this
    },
    empty: function () {
        return this.max.x < this.min.x || this.max.y < this.min.y
    },
    center: function (a) {
        return (a || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(.5)
    },
    size: function (a) {
        return (a || new THREE.Vector2).subVectors(this.max, this.min)
    },
    expandByPoint: function (a) {
        this.min.min(a);
        this.max.max(a);
        return this
    },
    expandByVector: function (a) {
        this.min.sub(a);
        this.max.add(a);
        return this
    },
    expandByScalar: function (a) {
        this.min.addScalar(-a);
        this.max.addScalar(a);
        return this
    },
    containsPoint: function (a) {
        return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
    },
    containsBox: function (a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1
    },
    getParameter: function (a) {
        return new THREE.Vector2((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
    },
    isIntersectionBox: function (a) {
        return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0
    },
    clampPoint: function (a, b) {
        return (b || new THREE.Vector2).copy(a).clamp(this.min, this.max)
    },
    distanceToPoint: function () {
        var a = new THREE.Vector2;
        return function (b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length()
        }
    }(),
    intersect: function (a) {
        this.min.max(a.min);
        this.max.min(a.max);
        return this
    },
    union: function (a) {
        this.min.min(a.min);
        this.max.max(a.max);
        return this
    },
    translate: function (a) {
        this.min.add(a);
        this.max.add(a);
        return this
    },
    equals: function (a) {
        return a.min.equals(this.min) && a.max.equals(this.max)
    },
    clone: function () {
        return (new THREE.Box2).copy(this)
    }
};
THREE.Box3 = function (a, b) {
    this.min = void 0 !== a ? a : new THREE.Vector3(Infinity, Infinity, Infinity);
    this.max = void 0 !== b ? b : new THREE.Vector3(-Infinity, -Infinity, -Infinity)
};
THREE.Box3.prototype = {
    constructor: THREE.Box3,
    set: function (a, b) {
        this.min.copy(a);
        this.max.copy(b);
        return this
    },
    addPoint: function (a) {
        a.x < this.min.x ? this.min.x = a.x : a.x > this.max.x && (this.max.x = a.x);
        a.y < this.min.y ? this.min.y = a.y : a.y > this.max.y && (this.max.y = a.y);
        a.z < this.min.z ? this.min.z = a.z : a.z > this.max.z && (this.max.z = a.z)
    },
    setFromPoints: function (a) {
        if (0 < a.length) {
            var b = a[0];
            this.min.copy(b);
            this.max.copy(b);
            for (var b = 1, c = a.length; b < c; b++) this.addPoint(a[b])
        } else this.makeEmpty();
        return this
    },
    setFromCenterAndSize: function () {
        var a = new THREE.Vector3;
        return function (b, c) {
            var d = a.copy(c).multiplyScalar(.5);
            this.min.copy(b).sub(d);
            this.max.copy(b).add(d);
            return this
        }
    }(),
    setFromObject: function () {
        var a = new THREE.Vector3;
        return function (b) {
            var c = this;
            b.updateMatrixWorld(!0);
            this.makeEmpty();
            b.traverse(function (b) {
                if (void 0 !== b.geometry && void 0 !== b.geometry.vertices)
                    for (var e = b.geometry.vertices, f = 0, h = e.length; f < h; f++) a.copy(e[f]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a)
            });
            return this
        }
    }(),
    copy: function (a) {
        this.min.copy(a.min);
        this.max.copy(a.max);
        return this
    },
    makeEmpty: function () {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this
    },
    empty: function () {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    },
    center: function (a) {
        return (a || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(.5)
    },
    size: function (a) {
        return (a || new THREE.Vector3).subVectors(this.max, this.min)
    },
    expandByPoint: function (a) {
        this.min.min(a);
        this.max.max(a);
        return this
    },
    expandByVector: function (a) {
        this.min.sub(a);
        this.max.add(a);
        return this
    },
    expandByScalar: function (a) {
        this.min.addScalar(-a);
        this.max.addScalar(a);
        return this
    },
    containsPoint: function (a) {
        return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0
    },
    containsBox: function (a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1
    },
    getParameter: function (a) {
        return new THREE.Vector3((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
    },
    isIntersectionBox: function (a) {
        return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0
    },
    clampPoint: function (a, b) {
        return (b || new THREE.Vector3).copy(a).clamp(this.min, this.max)
    },
    distanceToPoint: function () {
        var a = new THREE.Vector3;
        return function (b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length()
        }
    }(),
    getBoundingSphere: function () {
        var a = new THREE.Vector3;
        return function (b) {
            b = b || new THREE.Sphere;
            b.center = this.center();
            b.radius = .5 * this.size(a).length();
            return b
        }
    }(),
    intersect: function (a) {
        this.min.max(a.min);
        this.max.min(a.max);
        return this
    },
    union: function (a) {
        this.min.min(a.min);
        this.max.max(a.max);
        return this
    },
    applyMatrix4: function () {
        var a = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
        return function (b) {
            a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b);
            a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
            a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
            a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
            a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
            a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
            a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
            a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
            this.makeEmpty();
            this.setFromPoints(a);
            return this
        }
    }(),
    translate: function (a) {
        this.min.add(a);
        this.max.add(a);
        return this
    },
    equals: function (a) {
        return a.min.equals(this.min) && a.max.equals(this.max)
    },
    clone: function () {
        return (new THREE.Box3).copy(this)
    }
};
THREE.Matrix3 = function (a, b, c, d, e, f, h, g, i) {
    this.elements = new Float32Array(9);
    this.set(void 0 !== a ? a : 1, b || 0, c || 0, d || 0, void 0 !== e ? e : 1, f || 0, h || 0, g || 0, void 0 !== i ? i : 1)
};
THREE.Matrix3.prototype = {
    constructor: THREE.Matrix3,
    set: function (a, b, c, d, e, f, h, g, i) {
        var k = this.elements;
        k[0] = a;
        k[3] = b;
        k[6] = c;
        k[1] = d;
        k[4] = e;
        k[7] = f;
        k[2] = h;
        k[5] = g;
        k[8] = i;
        return this
    },
    identity: function () {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this
    },
    copy: function (a) {
        a = a.elements;
        this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
        return this
    },
    multiplyVector3: function (a) {
        console.warn("DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return a.applyMatrix3(this)
    },
    multiplyVector3Array: function () {
        var a = new THREE.Vector3;
        return function (b) {
            for (var c = 0, d = b.length; c < d; c += 3) a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix3(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
            return b
        }
    }(),
    multiplyScalar: function (a) {
        var b = this.elements;
        b[0] *= a;
        b[3] *= a;
        b[6] *= a;
        b[1] *= a;
        b[4] *= a;
        b[7] *= a;
        b[2] *= a;
        b[5] *= a;
        b[8] *= a;
        return this
    },
    determinant: function () {
        var a = this.elements,
            b = a[0],
            c = a[1],
            d = a[2],
            e = a[3],
            f = a[4],
            h = a[5],
            g = a[6],
            i = a[7],
            a = a[8];
        return b * f * a - b * h * i - c * e * a + c * h * g + d * e * i - d * f * g
    },
    getInverse: function (a, b) {
        var c = a.elements,
            d = this.elements;
        d[0] = c[10] * c[5] - c[6] * c[9];
        d[1] = -c[10] * c[1] + c[2] * c[9];
        d[2] = c[6] * c[1] - c[2] * c[5];
        d[3] = -c[10] * c[4] + c[6] * c[8];
        d[4] = c[10] * c[0] - c[2] * c[8];
        d[5] = -c[6] * c[0] + c[2] * c[4];
        d[6] = c[9] * c[4] - c[5] * c[8];
        d[7] = -c[9] * c[0] + c[1] * c[8];
        d[8] = c[5] * c[0] - c[1] * c[4];
        c = c[0] * d[0] + c[1] * d[3] + c[2] * d[6];
        if (0 === c) {
            if (b) throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
            this.identity();
            return this
        }
        this.multiplyScalar(1 / c);
        return this
    },
    transpose: function () {
        var a, b = this.elements;
        a = b[1];
        b[1] = b[3];
        b[3] = a;
        a = b[2];
        b[2] = b[6];
        b[6] = a;
        a = b[5];
        b[5] = b[7];
        b[7] = a;
        return this
    },
    getNormalMatrix: function (a) {
        this.getInverse(a).transpose();
        return this
    },
    transposeIntoArray: function (a) {
        var b = this.elements;
        a[0] = b[0];
        a[1] = b[3];
        a[2] = b[6];
        a[3] = b[1];
        a[4] = b[4];
        a[5] = b[7];
        a[6] = b[2];
        a[7] = b[5];
        a[8] = b[8];
        return this
    },
    clone: function () {
        var a = this.elements;
        return new THREE.Matrix3(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8])
    }
};
THREE.Matrix4 = function (a, b, c, d, e, f, h, g, i, k, m, l, p, r, t, n) {
    var s = this.elements = new Float32Array(16);
    s[0] = void 0 !== a ? a : 1;
    s[4] = b || 0;
    s[8] = c || 0;
    s[12] = d || 0;
    s[1] = e || 0;
    s[5] = void 0 !== f ? f : 1;
    s[9] = h || 0;
    s[13] = g || 0;
    s[2] = i || 0;
    s[6] = k || 0;
    s[10] = void 0 !== m ? m : 1;
    s[14] = l || 0;
    s[3] = p || 0;
    s[7] = r || 0;
    s[11] = t || 0;
    s[15] = void 0 !== n ? n : 1
};
THREE.Matrix4.prototype = {
    constructor: THREE.Matrix4,
    set: function (a, b, c, d, e, f, h, g, i, k, m, l, p, r, t, n) {
        var s = this.elements;
        s[0] = a;
        s[4] = b;
        s[8] = c;
        s[12] = d;
        s[1] = e;
        s[5] = f;
        s[9] = h;
        s[13] = g;
        s[2] = i;
        s[6] = k;
        s[10] = m;
        s[14] = l;
        s[3] = p;
        s[7] = r;
        s[11] = t;
        s[15] = n;
        return this
    },
    identity: function () {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this
    },
    copy: function (a) {
        this.elements.set(a.elements);
        return this
    },
    extractPosition: function (a) {
        console.warn("DEPRECATED: Matrix4's .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(a)
    },
    copyPosition: function (a) {
        var b = this.elements,
            a = a.elements;
        b[12] = a[12];
        b[13] = a[13];
        b[14] = a[14];
        return this
    },
    extractRotation: function () {
        var a = new THREE.Vector3;
        return function (b) {
            var c = this.elements,
                b = b.elements,
                d = 1 / a.set(b[0], b[1], b[2]).length(),
                e = 1 / a.set(b[4], b[5], b[6]).length(),
                f = 1 / a.set(b[8], b[9], b[10]).length();
            c[0] = b[0] * d;
            c[1] = b[1] * d;
            c[2] = b[2] * d;
            c[4] = b[4] * e;
            c[5] = b[5] * e;
            c[6] = b[6] * e;
            c[8] = b[8] * f;
            c[9] = b[9] * f;
            c[10] = b[10] * f;
            return this
        }
    }(),
    makeRotationFromEuler: function (a) {
        !1 === a instanceof THREE.Euler && console.error("ERROR: Matrix's .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
        var b = this.elements,
            c = a.x,
            d = a.y,
            e = a.z,
            f = Math.cos(c),
            c = Math.sin(c),
            h = Math.cos(d),
            d = Math.sin(d),
            g = Math.cos(e),
            e = Math.sin(e);
        if ("XYZ" === a.order) {
            var a = f * g,
                i = f * e,
                k = c * g,
                m = c * e;
            b[0] = h * g;
            b[4] = -h * e;
            b[8] = d;
            b[1] = i + k * d;
            b[5] = a - m * d;
            b[9] = -c * h;
            b[2] = m - a * d;
            b[6] = k + i * d;
            b[10] = f * h
        } else "YXZ" === a.order ? (a = h * g, i = h * e, k = d * g, m = d * e, b[0] = a + m * c, b[4] = k * c - i, b[8] = f * d, b[1] = f * e, b[5] = f * g, b[9] = -c, b[2] = i * c - k, b[6] = m + a * c, b[10] = f * h) : "ZXY" === a.order ? (a = h * g, i = h * e, k = d * g, m = d * e, b[0] = a - m * c, b[4] = -f * e, b[8] = k + i * c, b[1] = i + k * c, b[5] = f * g, b[9] = m - a * c, b[2] = -f * d, b[6] = c, b[10] = f * h) : "ZYX" === a.order ? (a = f * g, i = f * e, k = c * g, m = c * e, b[0] = h * g, b[4] = k * d - i, b[8] = a * d + m, b[1] = h * e, b[5] = m * d + a, b[9] = i * d - k, b[2] = -d, b[6] = c * h, b[10] = f * h) : "YZX" === a.order ? (a = f * h, i = f * d, k = c * h, m = c * d, b[0] = h * g, b[4] = m - a * e, b[8] = k * e + i, b[1] = e, b[5] = f * g, b[9] = -c * g, b[2] = -d * g, b[6] = i * e + k, b[10] = a - m * e) : "XZY" === a.order && (a = f * h, i = f * d, k = c * h, m = c * d, b[0] = h * g, b[4] = -e, b[8] = d * g, b[1] = a * e + m, b[5] = f * g, b[9] = i * e - k, b[2] = k * e - i, b[6] = c * g, b[10] = m * e + a);
        b[3] = 0;
        b[7] = 0;
        b[11] = 0;
        b[12] = 0;
        b[13] = 0;
        b[14] = 0;
        b[15] = 1;
        return this
    },
    setRotationFromQuaternion: function (a) {
        console.warn("DEPRECATED: Matrix4's .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.");
        return this.makeRotationFromQuaternion(a)
    },
    makeRotationFromQuaternion: function (a) {
        var b = this.elements,
            c = a.x,
            d = a.y,
            e = a.z,
            f = a.w,
            h = c + c,
            g = d + d,
            i = e + e,
            a = c * h,
            k = c * g,
            c = c * i,
            m = d * g,
            d = d * i,
            e = e * i,
            h = f * h,
            g = f * g,
            f = f * i;
        b[0] = 1 - (m + e);
        b[4] = k - f;
        b[8] = c + g;
        b[1] = k + f;
        b[5] = 1 - (a + e);
        b[9] = d - h;
        b[2] = c - g;
        b[6] = d + h;
        b[10] = 1 - (a + m);
        b[3] = 0;
        b[7] = 0;
        b[11] = 0;
        b[12] = 0;
        b[13] = 0;
        b[14] = 0;
        b[15] = 1;
        return this
    },
    lookAt: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3,
            c = new THREE.Vector3;
        return function (d, e, f) {
            var h = this.elements;
            c.subVectors(d, e).normalize();
            0 === c.length() && (c.z = 1);
            a.crossVectors(f, c).normalize();
            0 === a.length() && (c.x += 1e-4, a.crossVectors(f, c).normalize());
            b.crossVectors(c, a);
            h[0] = a.x;
            h[4] = b.x;
            h[8] = c.x;
            h[1] = a.y;
            h[5] = b.y;
            h[9] = c.y;
            h[2] = a.z;
            h[6] = b.z;
            h[10] = c.z;
            return this
        }
    }(),
    multiply: function (a, b) {
        return void 0 !== b ? (console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
    },
    multiplyMatrices: function (a, b) {
        var c = a.elements,
            d = b.elements,
            e = this.elements,
            f = c[0],
            h = c[4],
            g = c[8],
            i = c[12],
            k = c[1],
            m = c[5],
            l = c[9],
            p = c[13],
            r = c[2],
            t = c[6],
            n = c[10],
            s = c[14],
            q = c[3],
            u = c[7],
            w = c[11],
            c = c[15],
            E = d[0],
            C = d[4],
            F = d[8],
            y = d[12],
            A = d[1],
            z = d[5],
            O = d[9],
            B = d[13],
            D = d[2],
            I = d[6],
            v = d[10],
            x = d[14],
            G = d[3],
            Q = d[7],
            J = d[11],
            d = d[15];
        e[0] = f * E + h * A + g * D + i * G;
        e[4] = f * C + h * z + g * I + i * Q;
        e[8] = f * F + h * O + g * v + i * J;
        e[12] = f * y + h * B + g * x + i * d;
        e[1] = k * E + m * A + l * D + p * G;
        e[5] = k * C + m * z + l * I + p * Q;
        e[9] = k * F + m * O + l * v + p * J;
        e[13] = k * y + m * B + l * x + p * d;
        e[2] = r * E + t * A + n * D + s * G;
        e[6] = r * C + t * z + n * I + s * Q;
        e[10] = r * F + t * O + n * v + s * J;
        e[14] = r * y + t * B + n * x + s * d;
        e[3] = q * E + u * A + w * D + c * G;
        e[7] = q * C + u * z + w * I + c * Q;
        e[11] = q * F + u * O + w * v + c * J;
        e[15] = q * y + u * B + w * x + c * d;
        return this
    },
    multiplyToArray: function (a, b, c) {
        var d = this.elements;
        this.multiplyMatrices(a, b);
        c[0] = d[0];
        c[1] = d[1];
        c[2] = d[2];
        c[3] = d[3];
        c[4] = d[4];
        c[5] = d[5];
        c[6] = d[6];
        c[7] = d[7];
        c[8] = d[8];
        c[9] = d[9];
        c[10] = d[10];
        c[11] = d[11];
        c[12] = d[12];
        c[13] = d[13];
        c[14] = d[14];
        c[15] = d[15];
        return this
    },
    multiplyScalar: function (a) {
        var b = this.elements;
        b[0] *= a;
        b[4] *= a;
        b[8] *= a;
        b[12] *= a;
        b[1] *= a;
        b[5] *= a;
        b[9] *= a;
        b[13] *= a;
        b[2] *= a;
        b[6] *= a;
        b[10] *= a;
        b[14] *= a;
        b[3] *= a;
        b[7] *= a;
        b[11] *= a;
        b[15] *= a;
        return this
    },
    multiplyVector3: function (a) {
        console.warn("DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
        return a.applyProjection(this)
    },
    multiplyVector4: function (a) {
        console.warn("DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return a.applyMatrix4(this)
    },
    multiplyVector3Array: function () {
        var a = new THREE.Vector3;
        return function (b) {
            for (var c = 0, d = b.length; c < d; c += 3) a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyProjection(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
            return b
        }
    }(),
    rotateAxis: function (a) {
        console.warn("DEPRECATED: Matrix4's .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        a.transformDirection(this)
    },
    crossVector: function (a) {
        console.warn("DEPRECATED: Matrix4's .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return a.applyMatrix4(this)
    },
    determinant: function () {
        var a = this.elements,
            b = a[0],
            c = a[4],
            d = a[8],
            e = a[12],
            f = a[1],
            h = a[5],
            g = a[9],
            i = a[13],
            k = a[2],
            m = a[6],
            l = a[10],
            p = a[14];
        return a[3] * (+e * g * m - d * i * m - e * h * l + c * i * l + d * h * p - c * g * p) + a[7] * (+b * g * p - b * i * l + e * f * l - d * f * p + d * i * k - e * g * k) + a[11] * (+b * i * m - b * h * p - e * f * m + c * f * p + e * h * k - c * i * k) + a[15] * (-d * h * k - b * g * m + b * h * l + d * f * m - c * f * l + c * g * k)
    },
    transpose: function () {
        var a = this.elements,
            b;
        b = a[1];
        a[1] = a[4];
        a[4] = b;
        b = a[2];
        a[2] = a[8];
        a[8] = b;
        b = a[6];
        a[6] = a[9];
        a[9] = b;
        b = a[3];
        a[3] = a[12];
        a[12] = b;
        b = a[7];
        a[7] = a[13];
        a[13] = b;
        b = a[11];
        a[11] = a[14];
        a[14] = b;
        return this
    },
    flattenToArray: function (a) {
        var b = this.elements;
        a[0] = b[0];
        a[1] = b[1];
        a[2] = b[2];
        a[3] = b[3];
        a[4] = b[4];
        a[5] = b[5];
        a[6] = b[6];
        a[7] = b[7];
        a[8] = b[8];
        a[9] = b[9];
        a[10] = b[10];
        a[11] = b[11];
        a[12] = b[12];
        a[13] = b[13];
        a[14] = b[14];
        a[15] = b[15];
        return a
    },
    flattenToArrayOffset: function (a, b) {
        var c = this.elements;
        a[b] = c[0];
        a[b + 1] = c[1];
        a[b + 2] = c[2];
        a[b + 3] = c[3];
        a[b + 4] = c[4];
        a[b + 5] = c[5];
        a[b + 6] = c[6];
        a[b + 7] = c[7];
        a[b + 8] = c[8];
        a[b + 9] = c[9];
        a[b + 10] = c[10];
        a[b + 11] = c[11];
        a[b + 12] = c[12];
        a[b + 13] = c[13];
        a[b + 14] = c[14];
        a[b + 15] = c[15];
        return a
    },
    getPosition: function () {
        var a = new THREE.Vector3;
        return function () {
            console.warn("DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.");
            var b = this.elements;
            return a.set(b[12], b[13], b[14])
        }
    }(),
    setPosition: function (a) {
        var b = this.elements;
        b[12] = a.x;
        b[13] = a.y;
        b[14] = a.z;
        return this
    },
    getInverse: function (a, b) {
        var c = this.elements,
            d = a.elements,
            e = d[0],
            f = d[4],
            h = d[8],
            g = d[12],
            i = d[1],
            k = d[5],
            m = d[9],
            l = d[13],
            p = d[2],
            r = d[6],
            t = d[10],
            n = d[14],
            s = d[3],
            q = d[7],
            u = d[11],
            d = d[15];
        c[0] = m * n * q - l * t * q + l * r * u - k * n * u - m * r * d + k * t * d;
        c[4] = g * t * q - h * n * q - g * r * u + f * n * u + h * r * d - f * t * d;
        c[8] = h * l * q - g * m * q + g * k * u - f * l * u - h * k * d + f * m * d;
        c[12] = g * m * r - h * l * r - g * k * t + f * l * t + h * k * n - f * m * n;
        c[1] = l * t * s - m * n * s - l * p * u + i * n * u + m * p * d - i * t * d;
        c[5] = h * n * s - g * t * s + g * p * u - e * n * u - h * p * d + e * t * d;
        c[9] = g * m * s - h * l * s - g * i * u + e * l * u + h * i * d - e * m * d;
        c[13] = h * l * p - g * m * p + g * i * t - e * l * t - h * i * n + e * m * n;
        c[2] = k * n * s - l * r * s + l * p * q - i * n * q - k * p * d + i * r * d;
        c[6] = g * r * s - f * n * s - g * p * q + e * n * q + f * p * d - e * r * d;
        c[10] = f * l * s - g * k * s + g * i * q - e * l * q - f * i * d + e * k * d;
        c[14] = g * k * p - f * l * p - g * i * r + e * l * r + f * i * n - e * k * n;
        c[3] = m * r * s - k * t * s - m * p * q + i * t * q + k * p * u - i * r * u;
        c[7] = f * t * s - h * r * s + h * p * q - e * t * q - f * p * u + e * r * u;
        c[11] = h * k * s - f * m * s - h * i * q + e * m * q + f * i * u - e * k * u;
        c[15] = f * m * p - h * k * p + h * i * r - e * m * r - f * i * t + e * k * t;
        c = e * c[0] + i * c[4] + p * c[8] + s * c[12];
        if (0 == c) {
            if (b) throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");
            this.identity();
            return this
        }
        this.multiplyScalar(1 / c);
        return this
    },
    translate: function () {
        console.warn("DEPRECATED: Matrix4's .translate() has been removed.")
    },
    rotateX: function () {
        console.warn("DEPRECATED: Matrix4's .rotateX() has been removed.")
    },
    rotateY: function () {
        console.warn("DEPRECATED: Matrix4's .rotateY() has been removed.")
    },
    rotateZ: function () {
        console.warn("DEPRECATED: Matrix4's .rotateZ() has been removed.")
    },
    rotateByAxis: function () {
        console.warn("DEPRECATED: Matrix4's .rotateByAxis() has been removed.")
    },
    scale: function (a) {
        var b = this.elements,
            c = a.x,
            d = a.y,
            a = a.z;
        b[0] *= c;
        b[4] *= d;
        b[8] *= a;
        b[1] *= c;
        b[5] *= d;
        b[9] *= a;
        b[2] *= c;
        b[6] *= d;
        b[10] *= a;
        b[3] *= c;
        b[7] *= d;
        b[11] *= a;
        return this
    },
    getMaxScaleOnAxis: function () {
        var a = this.elements;
        return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])))
    },
    makeTranslation: function (a, b, c) {
        this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
        return this
    },
    makeRotationX: function (a) {
        var b = Math.cos(a),
            a = Math.sin(a);
        this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
        return this
    },
    makeRotationY: function (a) {
        var b = Math.cos(a),
            a = Math.sin(a);
        this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
        return this
    },
    makeRotationZ: function (a) {
        var b = Math.cos(a),
            a = Math.sin(a);
        this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this
    },
    makeRotationAxis: function (a, b) {
        var c = Math.cos(b),
            d = Math.sin(b),
            e = 1 - c,
            f = a.x,
            h = a.y,
            g = a.z,
            i = e * f,
            k = e * h;
        this.set(i * f + c, i * h - d * g, i * g + d * h, 0, i * h + d * g, k * h + c, k * g - d * f, 0, i * g - d * h, k * g + d * f, e * g * g + c, 0, 0, 0, 0, 1);
        return this
    },
    makeScale: function (a, b, c) {
        this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
        return this
    },
    compose: function (a, b, c) {
        this.makeRotationFromQuaternion(b);
        this.scale(c);
        this.setPosition(a);
        return this
    },
    decompose: function () {
        var a = new THREE.Vector3,
            b = new THREE.Matrix4;
        return function (c, d, e) {
            var f = this.elements,
                h = a.set(f[0], f[1], f[2]).length(),
                g = a.set(f[4], f[5], f[6]).length(),
                i = a.set(f[8], f[9], f[10]).length();
            c.x = f[12];
            c.y = f[13];
            c.z = f[14];
            b.elements.set(this.elements);
            var c = 1 / h,
                f = 1 / g,
                k = 1 / i;
            b.elements[0] *= c;
            b.elements[1] *= c;
            b.elements[2] *= c;
            b.elements[4] *= f;
            b.elements[5] *= f;
            b.elements[6] *= f;
            b.elements[8] *= k;
            b.elements[9] *= k;
            b.elements[10] *= k;
            d.setFromRotationMatrix(b);
            e.x = h;
            e.y = g;
            e.z = i;
            return this
        }
    }(),
    makeFrustum: function (a, b, c, d, e, f) {
        var h = this.elements;
        h[0] = 2 * e / (b - a);
        h[4] = 0;
        h[8] = (b + a) / (b - a);
        h[12] = 0;
        h[1] = 0;
        h[5] = 2 * e / (d - c);
        h[9] = (d + c) / (d - c);
        h[13] = 0;
        h[2] = 0;
        h[6] = 0;
        h[10] = -(f + e) / (f - e);
        h[14] = -2 * f * e / (f - e);
        h[3] = 0;
        h[7] = 0;
        h[11] = -1;
        h[15] = 0;
        return this
    },
    makePerspective: function (a, b, c, d) {
        var a = c * Math.tan(THREE.Math.degToRad(.5 * a)),
            e = -a;
        return this.makeFrustum(e * b, a * b, e, a, c, d)
    },
    makeOrthographic: function (a, b, c, d, e, f) {
        var h = this.elements,
            g = b - a,
            i = c - d,
            k = f - e;
        h[0] = 2 / g;
        h[4] = 0;
        h[8] = 0;
        h[12] = -((b + a) / g);
        h[1] = 0;
        h[5] = 2 / i;
        h[9] = 0;
        h[13] = -((c + d) / i);
        h[2] = 0;
        h[6] = 0;
        h[10] = -2 / k;
        h[14] = -((f + e) / k);
        h[3] = 0;
        h[7] = 0;
        h[11] = 0;
        h[15] = 1;
        return this
    },
    fromArray: function (a) {
        this.elements.set(a);
        return this
    },
    toArray: function () {
        var a = this.elements;
        return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]]
    },
    clone: function () {
        var a = this.elements;
        return new THREE.Matrix4(a[0], a[4], a[8], a[12], a[1], a[5], a[9], a[13], a[2], a[6], a[10], a[14], a[3], a[7], a[11], a[15])
    }
};
THREE.Ray = function (a, b) {
    this.origin = void 0 !== a ? a : new THREE.Vector3;
    this.direction = void 0 !== b ? b : new THREE.Vector3
};
THREE.Ray.prototype = {
    constructor: THREE.Ray,
    set: function (a, b) {
        this.origin.copy(a);
        this.direction.copy(b);
        return this
    },
    copy: function (a) {
        this.origin.copy(a.origin);
        this.direction.copy(a.direction);
        return this
    },
    at: function (a, b) {
        return (b || new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin)
    },
    recast: function () {
        var a = new THREE.Vector3;
        return function (b) {
            this.origin.copy(this.at(b, a));
            return this
        }
    }(),
    closestPointToPoint: function (a, b) {
        var c = b || new THREE.Vector3;
        c.subVectors(a, this.origin);
        var d = c.dot(this.direction);
        return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin)
    },
    distanceToPoint: function () {
        var a = new THREE.Vector3;
        return function (b) {
            var c = a.subVectors(b, this.origin).dot(this.direction);
            if (0 > c) return this.origin.distanceTo(b);
            a.copy(this.direction).multiplyScalar(c).add(this.origin);
            return a.distanceTo(b)
        }
    }(),
    distanceSqToSegment: function (a, b, c, d) {
        var e = a.clone().add(b).multiplyScalar(.5),
            f = b.clone().sub(a).normalize(),
            h = .5 * a.distanceTo(b),
            g = this.origin.clone().sub(e),
            a = -this.direction.dot(f),
            b = g.dot(this.direction),
            i = -g.dot(f),
            k = g.lengthSq(),
            m = Math.abs(1 - a * a),
            l, p;
        0 <= m ? (g = a * i - b, l = a * b - i, p = h * m, 0 <= g ? l >= -p ? l <= p ? (h = 1 / m, g *= h, l *= h, a = g * (g + a * l + 2 * b) + l * (a * g + l + 2 * i) + k) : (l = h, g = Math.max(0, -(a * l + b)), a = -g * g + l * (l + 2 * i) + k) : (l = -h, g = Math.max(0, -(a * l + b)), a = -g * g + l * (l + 2 * i) + k) : l <= -p ? (g = Math.max(0, -(-a * h + b)), l = 0 < g ? -h : Math.min(Math.max(-h, -i), h), a = -g * g + l * (l + 2 * i) + k) : l <= p ? (g = 0, l = Math.min(Math.max(-h, -i), h), a = l * (l + 2 * i) + k) : (g = Math.max(0, -(a * h + b)), l = 0 < g ? h : Math.min(Math.max(-h, -i), h), a = -g * g + l * (l + 2 * i) + k)) : (l = 0 < a ? -h : h, g = Math.max(0, -(a * l + b)), a = -g * g + l * (l + 2 * i) + k);
        c && c.copy(this.direction.clone().multiplyScalar(g).add(this.origin));
        d && d.copy(f.clone().multiplyScalar(l).add(e));
        return a
    },
    isIntersectionSphere: function (a) {
        return this.distanceToPoint(a.center) <= a.radius
    },
    isIntersectionPlane: function (a) {
        var b = a.distanceToPoint(this.origin);
        return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
    },
    distanceToPlane: function (a) {
        var b = a.normal.dot(this.direction);
        if (0 == b) return 0 == a.distanceToPoint(this.origin) ? 0 : null;
        a = -(this.origin.dot(a.normal) + a.constant) / b;
        return 0 <= a ? a : null
    },
    intersectPlane: function (a, b) {
        var c = this.distanceToPlane(a);
        return null === c ? null : this.at(c, b)
    },
    isIntersectionBox: function () {
        var a = new THREE.Vector3;
        return function (b) {
            return null !== this.intersectBox(b, a)
        }
    }(),
    intersectBox: function (a, b) {
        var c, d, e, f, h;
        d = 1 / this.direction.x;
        f = 1 / this.direction.y;
        h = 1 / this.direction.z;
        var g = this.origin;
        0 <= d ? (c = (a.min.x - g.x) * d, d *= a.max.x - g.x) : (c = (a.max.x - g.x) * d, d *= a.min.x - g.x);
        0 <= f ? (e = (a.min.y - g.y) * f, f *= a.max.y - g.y) : (e = (a.max.y - g.y) * f, f *= a.min.y - g.y);
        if (c > f || e > d) return null;
        if (e > c || c !== c) c = e;
        if (f < d || d !== d) d = f;
        0 <= h ? (e = (a.min.z - g.z) * h, h *= a.max.z - g.z) : (e = (a.max.z - g.z) * h, h *= a.min.z - g.z);
        if (c > h || e > d) return null;
        if (e > c || c !== c) c = e;
        if (h < d || d !== d) d = h;
        return 0 > d ? null : this.at(0 <= c ? c : d, b)
    },
    intersectTriangle: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3,
            c = new THREE.Vector3,
            d = new THREE.Vector3;
        return function (e, f, h, g, i) {
            b.subVectors(f, e);
            c.subVectors(h, e);
            d.crossVectors(b, c);
            f = this.direction.dot(d);
            if (0 < f) {
                if (g) return null;
                g = 1
            } else if (0 > f) g = -1, f = -f;
            else return null;
            a.subVectors(this.origin, e);
            e = g * this.direction.dot(c.crossVectors(a, c));
            if (0 > e) return null;
            h = g * this.direction.dot(b.cross(a));
            if (0 > h || e + h > f) return null;
            e = -g * a.dot(d);
            return 0 > e ? null : this.at(e / f, i)
        }
    }(),
    applyMatrix4: function (a) {
        this.direction.add(this.origin).applyMatrix4(a);
        this.origin.applyMatrix4(a);
        this.direction.sub(this.origin);
        this.direction.normalize();
        return this
    },
    equals: function (a) {
        return a.origin.equals(this.origin) && a.direction.equals(this.direction)
    },
    clone: function () {
        return (new THREE.Ray).copy(this)
    }
};
THREE.Sphere = function (a, b) {
    this.center = void 0 !== a ? a : new THREE.Vector3;
    this.radius = void 0 !== b ? b : 0
};
THREE.Sphere.prototype = {
    constructor: THREE.Sphere,
    set: function (a, b) {
        this.center.copy(a);
        this.radius = b;
        return this
    },
    setFromPoints: function () {
        var a = new THREE.Box3;
        return function (b, c) {
            var d = this.center;
            void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
            for (var e = 0, f = 0, h = b.length; f < h; f++) e = Math.max(e, d.distanceToSquared(b[f]));
            this.radius = Math.sqrt(e);
            return this
        }
    }(),
    copy: function (a) {
        this.center.copy(a.center);
        this.radius = a.radius;
        return this
    },
    empty: function () {
        return 0 >= this.radius
    },
    containsPoint: function (a) {
        return a.distanceToSquared(this.center) <= this.radius * this.radius
    },
    distanceToPoint: function (a) {
        return a.distanceTo(this.center) - this.radius
    },
    intersectsSphere: function (a) {
        var b = this.radius + a.radius;
        return a.center.distanceToSquared(this.center) <= b * b
    },
    clampPoint: function (a, b) {
        var c = this.center.distanceToSquared(a),
            d = b || new THREE.Vector3;
        d.copy(a);
        c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center));
        return d
    },
    getBoundingBox: function (a) {
        a = a || new THREE.Box3;
        a.set(this.center, this.center);
        a.expandByScalar(this.radius);
        return a
    },
    applyMatrix4: function (a) {
        this.center.applyMatrix4(a);
        this.radius *= a.getMaxScaleOnAxis();
        return this
    },
    translate: function (a) {
        this.center.add(a);
        return this
    },
    equals: function (a) {
        return a.center.equals(this.center) && a.radius === this.radius
    },
    clone: function () {
        return (new THREE.Sphere).copy(this)
    }
};
THREE.Frustum = function (a, b, c, d, e, f) {
    this.planes = [void 0 !== a ? a : new THREE.Plane, void 0 !== b ? b : new THREE.Plane, void 0 !== c ? c : new THREE.Plane, void 0 !== d ? d : new THREE.Plane, void 0 !== e ? e : new THREE.Plane, void 0 !== f ? f : new THREE.Plane]
};
THREE.Frustum.prototype = {
    constructor: THREE.Frustum,
    set: function (a, b, c, d, e, f) {
        var h = this.planes;
        h[0].copy(a);
        h[1].copy(b);
        h[2].copy(c);
        h[3].copy(d);
        h[4].copy(e);
        h[5].copy(f);
        return this
    },
    copy: function (a) {
        for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
        return this
    },
    setFromMatrix: function (a) {
        var b = this.planes,
            c = a.elements,
            a = c[0],
            d = c[1],
            e = c[2],
            f = c[3],
            h = c[4],
            g = c[5],
            i = c[6],
            k = c[7],
            m = c[8],
            l = c[9],
            p = c[10],
            r = c[11],
            t = c[12],
            n = c[13],
            s = c[14],
            c = c[15];
        b[0].setComponents(f - a, k - h, r - m, c - t).normalize();
        b[1].setComponents(f + a, k + h, r + m, c + t).normalize();
        b[2].setComponents(f + d, k + g, r + l, c + n).normalize();
        b[3].setComponents(f - d, k - g, r - l, c - n).normalize();
        b[4].setComponents(f - e, k - i, r - p, c - s).normalize();
        b[5].setComponents(f + e, k + i, r + p, c + s).normalize();
        return this
    },
    intersectsObject: function () {
        var a = new THREE.Sphere;
        return function (b) {
            var c = b.geometry;
            null === c.boundingSphere && c.computeBoundingSphere();
            a.copy(c.boundingSphere);
            a.applyMatrix4(b.matrixWorld);
            return this.intersectsSphere(a)
        }
    }(),
    intersectsSphere: function (a) {
        for (var b = this.planes, c = a.center, a = -a.radius, d = 0; 6 > d; d++)
            if (b[d].distanceToPoint(c) < a) return !1;
        return !0
    },
    intersectsBox: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3;
        return function (c) {
            for (var d = this.planes, e = 0; 6 > e; e++) {
                var f = d[e];
                a.x = 0 < f.normal.x ? c.min.x : c.max.x;
                b.x = 0 < f.normal.x ? c.max.x : c.min.x;
                a.y = 0 < f.normal.y ? c.min.y : c.max.y;
                b.y = 0 < f.normal.y ? c.max.y : c.min.y;
                a.z = 0 < f.normal.z ? c.min.z : c.max.z;
                b.z = 0 < f.normal.z ? c.max.z : c.min.z;
                var h = f.distanceToPoint(a),
                    f = f.distanceToPoint(b);
                if (0 > h && 0 > f) return !1
            }
            return !0
        }
    }(),
    containsPoint: function (a) {
        for (var b = this.planes, c = 0; 6 > c; c++)
            if (0 > b[c].distanceToPoint(a)) return !1;
        return !0
    },
    clone: function () {
        return (new THREE.Frustum).copy(this)
    }
};
THREE.Plane = function (a, b) {
    this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0);
    this.constant = void 0 !== b ? b : 0
};
THREE.Plane.prototype = {
    constructor: THREE.Plane,
    set: function (a, b) {
        this.normal.copy(a);
        this.constant = b;
        return this
    },
    setComponents: function (a, b, c, d) {
        this.normal.set(a, b, c);
        this.constant = d;
        return this
    },
    setFromNormalAndCoplanarPoint: function (a, b) {
        this.normal.copy(a);
        this.constant = -b.dot(this.normal);
        return this
    },
    setFromCoplanarPoints: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3;
        return function (c, d, e) {
            d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
            this.setFromNormalAndCoplanarPoint(d, c);
            return this
        }
    }(),
    copy: function (a) {
        this.normal.copy(a.normal);
        this.constant = a.constant;
        return this
    },
    normalize: function () {
        var a = 1 / this.normal.length();
        this.normal.multiplyScalar(a);
        this.constant *= a;
        return this
    },
    negate: function () {
        this.constant *= -1;
        this.normal.negate();
        return this
    },
    distanceToPoint: function (a) {
        return this.normal.dot(a) + this.constant
    },
    distanceToSphere: function (a) {
        return this.distanceToPoint(a.center) - a.radius
    },
    projectPoint: function (a, b) {
        return this.orthoPoint(a, b).sub(a).negate()
    },
    orthoPoint: function (a, b) {
        var c = this.distanceToPoint(a);
        return (b || new THREE.Vector3).copy(this.normal).multiplyScalar(c)
    },
    isIntersectionLine: function (a) {
        var b = this.distanceToPoint(a.start),
            a = this.distanceToPoint(a.end);
        return 0 > b && 0 < a || 0 > a && 0 < b
    },
    intersectLine: function () {
        var a = new THREE.Vector3;
        return function (b, c) {
            var d = c || new THREE.Vector3,
                e = b.delta(a),
                f = this.normal.dot(e);
            if (0 == f) {
                if (0 == this.distanceToPoint(b.start)) return d.copy(b.start)
            } else return f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start)
        }
    }(),
    coplanarPoint: function (a) {
        return (a || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)
    },
    applyMatrix4: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3;
        return function (c, d) {
            var d = d || (new THREE.Matrix3).getNormalMatrix(c),
                e = a.copy(this.normal).applyMatrix3(d),
                f = this.coplanarPoint(b);
            f.applyMatrix4(c);
            this.setFromNormalAndCoplanarPoint(e, f);
            return this
        }
    }(),
    translate: function (a) {
        this.constant -= a.dot(this.normal);
        return this
    },
    equals: function (a) {
        return a.normal.equals(this.normal) && a.constant == this.constant
    },
    clone: function () {
        return (new THREE.Plane).copy(this)
    }
};
THREE.Math = {
    PI2: 2 * Math.PI,
    generateUUID: function () {
        var a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
            b = Array(36),
            c = 0,
            d;
        return function () {
            for (var e = 0; 36 > e; e++) 8 == e || 13 == e || 18 == e || 23 == e ? b[e] = "-" : 14 == e ? b[e] = "4" : (2 >= c && (c = 33554432 + 16777216 * Math.random() | 0), d = c & 15, c >>= 4, b[e] = a[19 == e ? d & 3 | 8 : d]);
            return b.join("")
        }
    }(),
    clamp: function (a, b, c) {
        return a < b ? b : a > c ? c : a
    },
    clampBottom: function (a, b) {
        return a < b ? b : a
    },
    mapLinear: function (a, b, c, d, e) {
        return d + (a - b) * (e - d) / (c - b)
    },
    smoothstep: function (a, b, c) {
        if (a <= b) return 0;
        if (a >= c) return 1;
        a = (a - b) / (c - b);
        return a * a * (3 - 2 * a)
    },
    smootherstep: function (a, b, c) {
        if (a <= b) return 0;
        if (a >= c) return 1;
        a = (a - b) / (c - b);
        return a * a * a * (a * (6 * a - 15) + 10)
    },
    random16: function () {
        return (65280 * Math.random() + 255 * Math.random()) / 65535
    },
    randInt: function (a, b) {
        return a + Math.floor(Math.random() * (b - a + 1))
    },
    randFloat: function (a, b) {
        return a + Math.random() * (b - a)
    },
    randFloatSpread: function (a) {
        return a * (.5 - Math.random())
    },
    sign: function (a) {
        return 0 > a ? -1 : 0 < a ? 1 : 0
    },
    degToRad: function () {
        var a = Math.PI / 180;
        return function (b) {
            return b * a
        }
    }(),
    radToDeg: function () {
        var a = 180 / Math.PI;
        return function (b) {
            return b * a
        }
    }()
};
THREE.Spline = function (a) {
    function b(a, b, c, d, e, f, h) {
        a = .5 * (c - a);
        d = .5 * (d - b);
        return (2 * (b - c) + a + d) * h + (-3 * (b - c) - 2 * a - d) * f + a * e + b
    }
    this.points = a;
    var c = [],
        d = {
            x: 0,
            y: 0,
            z: 0
        },
        e, f, h, g, i, k, m, l, p;
    this.initFromArray = function (a) {
        this.points = [];
        for (var b = 0; b < a.length; b++) this.points[b] = {
            x: a[b][0],
            y: a[b][1],
            z: a[b][2]
        }
    };
    this.getPoint = function (a) {
        e = (this.points.length - 1) * a;
        f = Math.floor(e);
        h = e - f;
        c[0] = 0 === f ? f : f - 1;
        c[1] = f;
        c[2] = f > this.points.length - 2 ? this.points.length - 1 : f + 1;
        c[3] = f > this.points.length - 3 ? this.points.length - 1 : f + 2;
        k = this.points[c[0]];
        m = this.points[c[1]];
        l = this.points[c[2]];
        p = this.points[c[3]];
        g = h * h;
        i = h * g;
        d.x = b(k.x, m.x, l.x, p.x, h, g, i);
        d.y = b(k.y, m.y, l.y, p.y, h, g, i);
        d.z = b(k.z, m.z, l.z, p.z, h, g, i);
        return d
    };
    this.getControlPointsArray = function () {
        var a, b, c = this.points.length,
            d = [];
        for (a = 0; a < c; a++) b = this.points[a], d[a] = [b.x, b.y, b.z];
        return d
    };
    this.getLength = function (a) {
        var b, c, d, e = b = b = 0,
            f = new THREE.Vector3,
            h = new THREE.Vector3,
            g = [],
            i = 0;
        g[0] = 0;
        a || (a = 100);
        c = this.points.length * a;
        f.copy(this.points[0]);
        for (a = 1; a < c; a++) b = a / c, d = this.getPoint(b), h.copy(d), i += h.distanceTo(f), f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b != e && (g[b] = i, e = b);
        g[g.length] = i;
        return {
            chunks: g,
            total: i
        }
    };
    this.reparametrizeByArcLength = function (a) {
        var b, c, d, e, f, h, g = [],
            i = new THREE.Vector3,
            k = this.getLength();
        g.push(i.copy(this.points[0]).clone());
        for (b = 1; b < this.points.length; b++) {
            c = k.chunks[b] - k.chunks[b - 1];
            h = Math.ceil(a * c / k.total);
            e = (b - 1) / (this.points.length - 1);
            f = b / (this.points.length - 1);
            for (c = 1; c < h - 1; c++) d = e + c * (1 / h) * (f - e), d = this.getPoint(d), g.push(i.copy(d).clone());
            g.push(i.copy(this.points[b]).clone())
        }
        this.points = g
    }
};
THREE.Triangle = function (a, b, c) {
    this.a = void 0 !== a ? a : new THREE.Vector3;
    this.b = void 0 !== b ? b : new THREE.Vector3;
    this.c = void 0 !== c ? c : new THREE.Vector3
};
THREE.Triangle.normal = function () {
    var a = new THREE.Vector3;
    return function (b, c, d, e) {
        e = e || new THREE.Vector3;
        e.subVectors(d, c);
        a.subVectors(b, c);
        e.cross(a);
        b = e.lengthSq();
        return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0)
    }
}();
THREE.Triangle.barycoordFromPoint = function () {
    var a = new THREE.Vector3,
        b = new THREE.Vector3,
        c = new THREE.Vector3;
    return function (d, e, f, h, g) {
        a.subVectors(h, e);
        b.subVectors(f, e);
        c.subVectors(d, e);
        var d = a.dot(a),
            e = a.dot(b),
            f = a.dot(c),
            i = b.dot(b),
            h = b.dot(c),
            k = d * i - e * e,
            g = g || new THREE.Vector3;
        if (0 == k) return g.set(-2, -1, -1);
        k = 1 / k;
        i = (i * f - e * h) * k;
        d = (d * h - e * f) * k;
        return g.set(1 - i - d, d, i)
    }
}();
THREE.Triangle.containsPoint = function () {
    var a = new THREE.Vector3;
    return function (b, c, d, e) {
        b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a);
        return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y
    }
}();
THREE.Triangle.prototype = {
    constructor: THREE.Triangle,
    set: function (a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this
    },
    setFromPointsAndIndices: function (a, b, c, d) {
        this.a.copy(a[b]);
        this.b.copy(a[c]);
        this.c.copy(a[d]);
        return this
    },
    copy: function (a) {
        this.a.copy(a.a);
        this.b.copy(a.b);
        this.c.copy(a.c);
        return this
    },
    area: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3;
        return function () {
            a.subVectors(this.c, this.b);
            b.subVectors(this.a, this.b);
            return .5 * a.cross(b).length()
        }
    }(),
    midpoint: function (a) {
        return (a || new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    },
    normal: function (a) {
        return THREE.Triangle.normal(this.a, this.b, this.c, a)
    },
    plane: function (a) {
        return (a || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c)
    },
    barycoordFromPoint: function (a, b) {
        return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b)
    },
    containsPoint: function (a) {
        return THREE.Triangle.containsPoint(a, this.a, this.b, this.c)
    },
    equals: function (a) {
        return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
    },
    clone: function () {
        return (new THREE.Triangle).copy(this)
    }
};
THREE.Vertex = function (a) {
    console.warn("THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.");
    return a
};
THREE.UV = function (a, b) {
    console.warn("THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.");
    return new THREE.Vector2(a, b)
};
THREE.Clock = function (a) {
    this.autoStart = void 0 !== a ? a : !0;
    this.elapsedTime = this.oldTime = this.startTime = 0;
    this.running = !1
};
THREE.Clock.prototype = {
    constructor: THREE.Clock,
    start: function () {
        this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();
        this.running = !0
    },
    stop: function () {
        this.getElapsedTime();
        this.running = !1
    },
    getElapsedTime: function () {
        this.getDelta();
        return this.elapsedTime
    },
    getDelta: function () {
        var a = 0;
        this.autoStart && !this.running && this.start();
        if (this.running) {
            var b = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(),
                a = .001 * (b - this.oldTime);
            this.oldTime = b;
            this.elapsedTime += a
        }
        return a
    }
};
THREE.EventDispatcher = function () {};
THREE.EventDispatcher.prototype = {
    constructor: THREE.EventDispatcher,
    apply: function (a) {
        a.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
    },
    addEventListener: function (a, b) {
        void 0 === this._listeners && (this._listeners = {});
        var c = this._listeners;
        void 0 === c[a] && (c[a] = []); - 1 === c[a].indexOf(b) && c[a].push(b)
    },
    hasEventListener: function (a, b) {
        if (void 0 === this._listeners) return !1;
        var c = this._listeners;
        return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1
    },
    removeEventListener: function (a, b) {
        if (void 0 !== this._listeners) {
            var c = this._listeners,
                d = c[a].indexOf(b); - 1 !== d && c[a].splice(d, 1)
        }
    },
    dispatchEvent: function (a) {
        if (void 0 !== this._listeners) {
            var b = this._listeners[a.type];
            if (void 0 !== b) {
                a.target = this;
                for (var c = 0, d = b.length; c < d; c++) b[c].call(this, a)
            }
        }
    }
};
(function (a) {
    a.Raycaster = function (b, c, d, e) {
        this.ray = new a.Ray(b, c);
        this.near = d || 0;
        this.far = e || Infinity
    };
    var b = new a.Sphere,
        c = new a.Ray;
    new a.Plane;
    new a.Vector3;
    var d = new a.Vector3,
        e = new a.Matrix4,
        f = function (a, b) {
            return a.distance - b.distance
        },
        h = new a.Vector3,
        g = new a.Vector3,
        i = new a.Vector3,
        k = function (f, m, r) {
            if (f instanceof a.Particle) {
                d.getPositionFromMatrix(f.matrixWorld);
                var t = m.ray.distanceToPoint(d);
                if (t > f.scale.x) return r;
                r.push({
                    distance: t,
                    point: f.position,
                    face: null,
                    object: f
                })
            } else if (f instanceof a.LOD) d.getPositionFromMatrix(f.matrixWorld), t = m.ray.origin.distanceTo(d), k(f.getObjectForDistance(t), m, r);
            else if (f instanceof a.Mesh) {
                var n = f.geometry;
                null === n.boundingSphere && n.computeBoundingSphere();
                b.copy(n.boundingSphere);
                b.applyMatrix4(f.matrixWorld);
                if (!1 === m.ray.isIntersectionSphere(b)) return r;
                e.getInverse(f.matrixWorld);
                c.copy(m.ray).applyMatrix4(e);
                if (null !== n.boundingBox && !1 === c.isIntersectionBox(n.boundingBox)) return r;
                if (n instanceof a.BufferGeometry) {
                    var s = f.material;
                    if (void 0 === s || !1 === n.dynamic) return r;
                    var q, u, w = m.precision;
                    if (void 0 !== n.attributes.index)
                        for (var E = n.offsets, C = n.attributes.index.array, F = n.attributes.position.array, y = n.offsets.length, A = n.attributes.index.array.length / 3, A = 0; A < y; ++A)
                            for (var t = E[A].start, z = E[A].index, n = t, O = t + E[A].count; n < O; n += 3) {
                                if (t = z + C[n], q = z + C[n + 1], u = z + C[n + 2], h.set(F[3 * t], F[3 * t + 1], F[3 * t + 2]), g.set(F[3 * q], F[3 * q + 1], F[3 * q + 2]), i.set(F[3 * u], F[3 * u + 1], F[3 * u + 2]), q = c.intersectTriangle(h, g, i, s.side !== a.DoubleSide), null !== q && (q.applyMatrix4(f.matrixWorld), t = m.ray.origin.distanceTo(q), !(t < w || t < m.near || t > m.far))) {
                                    u = (new a.Vector3).subVectors(g, h);
                                    var B = (new a.Vector3).subVectors(i, h);
                                    u.cross(B).normalize();
                                    r.push({
                                        distance: t,
                                        point: q,
                                        normal: u,
                                        face: null,
                                        faceIndex: null,
                                        object: f
                                    })
                                }
                            } else {
                                F = n.attributes.position.array;
                                A = n.attributes.position.array.length;
                                for (n = 0; n < A; n += 3) t = n, q = n + 1, u = n + 2, h.set(F[3 * t], F[3 * t + 1], F[3 * t + 2]), g.set(F[3 * q], F[3 * q + 1], F[3 * q + 2]), i.set(F[3 * u], F[3 * u + 1], F[3 * u + 2]), q = c.intersectTriangle(h, g, i, s.side !== a.DoubleSide), null !== q && (q.applyMatrix4(f.matrixWorld), t = m.ray.origin.distanceTo(q), t < w || t < m.near || t > m.far || r.push({
                                    distance: t,
                                    point: q,
                                    face: null,
                                    faceIndex: null,
                                    object: f
                                }))
                            }
                } else if (n instanceof a.Geometry) {
                    C = f.material instanceof a.MeshFaceMaterial;
                    F = !0 === C ? f.material.materials : null;
                    w = m.precision;
                    E = n.vertices;
                    y = 0;
                    for (A = n.faces.length; y < A; y++) z = n.faces[y], s = !0 === C ? F[z.materialIndex] : f.material, void 0 !== s && (t = E[z.a], q = E[z.b], u = E[z.c], q = c.intersectTriangle(t, q, u, s.side !== a.DoubleSide), null !== q && (q.applyMatrix4(f.matrixWorld), t = m.ray.origin.distanceTo(q), t < w || t < m.near || t > m.far || r.push({
                        distance: t,
                        point: q,
                        face: z,
                        faceIndex: y,
                        object: f
                    })))
                }
            } else if (f instanceof a.Line) {
                w = m.linePrecision;
                s = w * w;
                n = f.geometry;
                null === n.boundingSphere && n.computeBoundingSphere();
                b.copy(n.boundingSphere);
                b.applyMatrix4(f.matrixWorld);
                if (!1 === m.ray.isIntersectionSphere(b)) return r;
                e.getInverse(f.matrixWorld);
                c.copy(m.ray).applyMatrix4(e);
                if (n instanceof a.Geometry) {
                    E = n.vertices;
                    w = E.length;
                    q = new a.Vector3;
                    u = new a.Vector3;
                    C = f.type === a.LineStrip ? 1 : 2;
                    for (n = 0; n < w - 1; n += C) c.distanceSqToSegment(E[n], E[n + 1], u, q) > s || (t = c.origin.distanceTo(u), t < m.near || t > m.far || r.push({
                        distance: t,
                        point: q.clone().applyMatrix4(f.matrixWorld),
                        face: null,
                        faceIndex: null,
                        object: f
                    }))
                }
            }
        },
        m = function (a, b, c) {
            for (var a = a.getDescendants(), d = 0, e = a.length; d < e; d++) k(a[d], b, c)
        };
    a.Raycaster.prototype.precision = 1e-4;
    a.Raycaster.prototype.linePrecision = 1;
    a.Raycaster.prototype.set = function (a, b) {
        this.ray.set(a, b)
    };
    a.Raycaster.prototype.intersectObject = function (a, b) {
        var c = [];
        !0 === b && m(a, this, c);
        k(a, this, c);
        c.sort(f);
        return c
    };
    a.Raycaster.prototype.intersectObjects = function (a, b) {
        for (var c = [], d = 0, e = a.length; d < e; d++) k(a[d], this, c), !0 === b && m(a[d], this, c);
        c.sort(f);
        return c
    }
})(THREE);
THREE.Object3D = function () {
    this.id = THREE.Object3DIdCount++;
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.parent = void 0;
    this.children = [];
    this.up = new THREE.Vector3(0, 1, 0);
    this.position = new THREE.Vector3;
    this.rotation = new THREE.Euler;
    this.quaternion = new THREE.Quaternion;
    this.scale = new THREE.Vector3(1, 1, 1);
    this.rotation._quaternion = this.quaternion;
    this.quaternion._euler = this.rotation;
    this.renderDepth = null;
    this.rotationAutoUpdate = !0;
    this.matrix = new THREE.Matrix4;
    this.matrixWorld = new THREE.Matrix4;
    this.visible = this.matrixWorldNeedsUpdate = this.matrixAutoUpdate = !0;
    this.receiveShadow = this.castShadow = !1;
    this.frustumCulled = !0;
    this.userData = {}
};
THREE.Object3D.prototype = {
    constructor: THREE.Object3D,
    get eulerOrder() {
        console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.");
        return this.rotation.order
    },
    set eulerOrder(a) {
        console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.");
        this.rotation.order = a
    },
    get useQuaternion() {
        console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")
    },
    set useQuaternion(a) {
        console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")
    },
    applyMatrix: function () {
        var a = new THREE.Matrix4;
        return function (b) {
            this.matrix.multiplyMatrices(b, this.matrix);
            this.position.getPositionFromMatrix(this.matrix);
            this.scale.getScaleFromMatrix(this.matrix);
            a.extractRotation(this.matrix);
            this.quaternion.setFromRotationMatrix(a)
        }
    }(),
    setRotationFromAxisAngle: function (a, b) {
        this.quaternion.setFromAxisAngle(a, b)
    },
    setRotationFromEuler: function (a) {
        this.quaternion.setFromEuler(a, !0)
    },
    setRotationFromMatrix: function (a) {
        this.quaternion.setFromRotationMatrix(a)
    },
    setRotationFromQuaternion: function (a) {
        this.quaternion.copy(a)
    },
    rotateOnAxis: function () {
        var a = new THREE.Quaternion;
        return function (b, c) {
            a.setFromAxisAngle(b, c);
            this.quaternion.multiply(a);
            return this
        }
    }(),
    rotateX: function () {
        var a = new THREE.Vector3(1, 0, 0);
        return function (b) {
            return this.rotateOnAxis(a, b)
        }
    }(),
    rotateY: function () {
        var a = new THREE.Vector3(0, 1, 0);
        return function (b) {
            return this.rotateOnAxis(a, b)
        }
    }(),
    rotateZ: function () {
        var a = new THREE.Vector3(0, 0, 1);
        return function (b) {
            return this.rotateOnAxis(a, b)
        }
    }(),
    translateOnAxis: function () {
        var a = new THREE.Vector3;
        return function (b, c) {
            a.copy(b);
            a.applyQuaternion(this.quaternion);
            this.position.add(a.multiplyScalar(c));
            return this
        }
    }(),
    translate: function (a, b) {
        console.warn("DEPRECATED: Object3D's .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.");
        return this.translateOnAxis(b, a)
    },
    translateX: function () {
        var a = new THREE.Vector3(1, 0, 0);
        return function (b) {
            return this.translateOnAxis(a, b)
        }
    }(),
    translateY: function () {
        var a = new THREE.Vector3(0, 1, 0);
        return function (b) {
            return this.translateOnAxis(a, b)
        }
    }(),
    translateZ: function () {
        var a = new THREE.Vector3(0, 0, 1);
        return function (b) {
            return this.translateOnAxis(a, b)
        }
    }(),
    localToWorld: function (a) {
        return a.applyMatrix4(this.matrixWorld)
    },
    worldToLocal: function () {
        var a = new THREE.Matrix4;
        return function (b) {
            return b.applyMatrix4(a.getInverse(this.matrixWorld))
        }
    }(),
    lookAt: function () {
        var a = new THREE.Matrix4;
        return function (b) {
            a.lookAt(b, this.position, this.up);
            this.quaternion.setFromRotationMatrix(a)
        }
    }(),
    add: function (a) {
        if (a === this) console.warn("THREE.Object3D.add: An object can't be added as a child of itself.");
        else if (a instanceof THREE.Object3D) {
            void 0 !== a.parent && a.parent.remove(a);
            a.parent = this;
            a.dispatchEvent({
                type: "added"
            });
            this.children.push(a);
            for (var b = this; void 0 !== b.parent;) b = b.parent;
            void 0 !== b && b instanceof THREE.Scene && b.__addObject(a)
        }
    },
    remove: function (a) {
        var b = this.children.indexOf(a);
        if (-1 !== b) {
            a.parent = void 0;
            a.dispatchEvent({
                type: "removed"
            });
            this.children.splice(b, 1);
            for (b = this; void 0 !== b.parent;) b = b.parent;
            void 0 !== b && b instanceof THREE.Scene && b.__removeObject(a)
        }
    },
    traverse: function (a) {
        a(this);
        for (var b = 0, c = this.children.length; b < c; b++) this.children[b].traverse(a)
    },
    getObjectById: function (a, b) {
        for (var c = 0, d = this.children.length; c < d; c++) {
            var e = this.children[c];
            if (e.id === a || !0 === b && (e = e.getObjectById(a, b), void 0 !== e)) return e
        }
    },
    getObjectByName: function (a, b) {
        for (var c = 0, d = this.children.length; c < d; c++) {
            var e = this.children[c];
            if (e.name === a || !0 === b && (e = e.getObjectByName(a, b), void 0 !== e)) return e
        }
    },
    getChildByName: function (a, b) {
        console.warn("DEPRECATED: Object3D's .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(a, b)
    },
    getDescendants: function (a) {
        void 0 === a && (a = []);
        Array.prototype.push.apply(a, this.children);
        for (var b = 0, c = this.children.length; b < c; b++) this.children[b].getDescendants(a);
        return a
    },
    updateMatrix: function () {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = !0
    },
    updateMatrixWorld: function (a) {
        !0 === this.matrixAutoUpdate && this.updateMatrix();
        if (!0 === this.matrixWorldNeedsUpdate || !0 === a) void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
        for (var b = 0, c = this.children.length; b < c; b++) this.children[b].updateMatrixWorld(a)
    },
    clone: function (a, b) {
        void 0 === a && (a = new THREE.Object3D);
        void 0 === b && (b = !0);
        a.name = this.name;
        a.up.copy(this.up);
        a.position.copy(this.position);
        a.quaternion.copy(this.quaternion);
        a.scale.copy(this.scale);
        a.renderDepth = this.renderDepth;
        a.rotationAutoUpdate = this.rotationAutoUpdate;
        a.matrix.copy(this.matrix);
        a.matrixWorld.copy(this.matrixWorld);
        a.matrixAutoUpdate = this.matrixAutoUpdate;
        a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
        a.visible = this.visible;
        a.castShadow = this.castShadow;
        a.receiveShadow = this.receiveShadow;
        a.frustumCulled = this.frustumCulled;
        a.userData = JSON.parse(JSON.stringify(this.userData));
        if (!0 === b)
            for (var c = 0; c < this.children.length; c++) a.add(this.children[c].clone());
        return a
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
THREE.Object3DIdCount = 0;
THREE.Projector = function () {
    function a() {
        if (i === m) {
            var a = new THREE.RenderableVertex;
            k.push(a);
            m++;
            i++;
            return a
        }
        return k[i++]
    }

    function b(a, b) {
        return a.z !== b.z ? b.z - a.z : a.id !== b.id ? a.id - b.id : 0
    }

    function c(a, b) {
        var c = 0,
            d = 1,
            e = a.z + a.w,
            f = b.z + b.w,
            h = -a.z + a.w,
            g = -b.z + b.w;
        if (0 <= e && 0 <= f && 0 <= h && 0 <= g) return !0;
        if (0 > e && 0 > f || 0 > h && 0 > g) return !1;
        0 > e ? c = Math.max(c, e / (e - f)) : 0 > f && (d = Math.min(d, e / (e - f)));
        0 > h ? c = Math.max(c, h / (h - g)) : 0 > g && (d = Math.min(d, h / (h - g)));
        if (d < c) return !1;
        a.lerp(b, c);
        b.lerp(a, 1 - d);
        return !0
    }
    var d, e, f = [],
        h = 0,
        g, i, k = [],
        m = 0,
        l, p, r = [],
        t = 0,
        n, s, q = [],
        u = 0,
        w, E, C = [],
        F = 0,
        y = {
            objects: [],
            sprites: [],
            lights: [],
            elements: []
        },
        A = new THREE.Vector3,
        z = new THREE.Vector4,
        O = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),
        B = new THREE.Box3,
        D = Array(3),
        I = new THREE.Matrix4,
        v = new THREE.Matrix4,
        x, G = new THREE.Matrix4,
        Q = new THREE.Matrix3,
        J = new THREE.Matrix3,
        ca = new THREE.Vector3,
        oa = new THREE.Frustum,
        pa = new THREE.Vector4,
        N = new THREE.Vector4;
    this.projectVector = function (a, b) {
        b.matrixWorldInverse.getInverse(b.matrixWorld);
        v.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
        return a.applyProjection(v)
    };
    this.unprojectVector = function (a, b) {
        b.projectionMatrixInverse.getInverse(b.projectionMatrix);
        v.multiplyMatrices(b.matrixWorld, b.projectionMatrixInverse);
        return a.applyProjection(v)
    };
    this.pickingRay = function (a, b) {
        a.z = -1;
        var c = new THREE.Vector3(a.x, a.y, 1);
        this.unprojectVector(a, b);
        this.unprojectVector(c, b);
        c.sub(a).normalize();
        return new THREE.Raycaster(a, c)
    };
    var M = function (a) {
            if (e === h) {
                var b = new THREE.RenderableObject;
                f.push(b);
                h++;
                e++;
                d = b
            } else d = f[e++];
            d.id = a.id;
            d.object = a;
            null !== a.renderDepth ? d.z = a.renderDepth : (A.getPositionFromMatrix(a.matrixWorld), A.applyProjection(v), d.z = A.z);
            return d
        },
        R = function (a) {
            if (!1 !== a.visible) {
                a instanceof THREE.Light ? y.lights.push(a) : a instanceof THREE.Mesh || a instanceof THREE.Line ? (!1 === a.frustumCulled || !0 === oa.intersectsObject(a)) && y.objects.push(M(a)) : (a instanceof THREE.Sprite || a instanceof THREE.Particle) && y.sprites.push(M(a));
                for (var b = 0, c = a.children.length; b < c; b++) R(a.children[b])
            }
        };
    this.projectScene = function (d, f, h, m) {
        var A = !1,
            M, $, ea, V, P, Y, U, ka, ta, ia, La, Ga;
        E = s = p = 0;
        y.elements.length = 0;
        !0 === d.autoUpdate && d.updateMatrixWorld();
        void 0 === f.parent && f.updateMatrixWorld();
        I.copy(f.matrixWorldInverse.getInverse(f.matrixWorld));
        v.multiplyMatrices(f.projectionMatrix, I);
        J.getNormalMatrix(I);
        oa.setFromMatrix(v);
        e = 0;
        y.objects.length = 0;
        y.sprites.length = 0;
        y.lights.length = 0;
        R(d);
        !0 === h && y.objects.sort(b);
        d = 0;
        for (h = y.objects.length; d < h; d++)
            if (U = y.objects[d].object, x = U.matrixWorld, i = 0, U instanceof THREE.Mesh) {
                ka = U.geometry;
                ea = ka.vertices;
                ta = ka.faces;
                ka = ka.faceVertexUvs;
                Q.getNormalMatrix(x);
                La = U.material instanceof THREE.MeshFaceMaterial;
                Ga = !0 === La ? U.material : null;
                M = 0;
                for ($ = ea.length; M < $; M++) {
                    g = a();
                    g.positionWorld.copy(ea[M]).applyMatrix4(x);
                    g.positionScreen.copy(g.positionWorld).applyMatrix4(v);
                    var fa = 1 / g.positionScreen.w;
                    g.positionScreen.x *= fa;
                    g.positionScreen.y *= fa;
                    g.positionScreen.z *= fa;
                    g.visible = !(-1 > g.positionScreen.x || 1 < g.positionScreen.x || -1 > g.positionScreen.y || 1 < g.positionScreen.y || -1 > g.positionScreen.z || 1 < g.positionScreen.z)
                }
                ea = 0;
                for (M = ta.length; ea < M; ea++)
                    if ($ = ta[ea], fa = !0 === La ? Ga.materials[$.materialIndex] : U.material, void 0 !== fa && (Y = fa.side, V = k[$.a], P = k[$.b], ia = k[$.c], D[0] = V.positionScreen, D[1] = P.positionScreen, D[2] = ia.positionScreen, !0 === V.visible || !0 === P.visible || !0 === ia.visible || O.isIntersectionBox(B.setFromPoints(D))))
                        if (A = 0 > (ia.positionScreen.x - V.positionScreen.x) * (P.positionScreen.y - V.positionScreen.y) - (ia.positionScreen.y - V.positionScreen.y) * (P.positionScreen.x - V.positionScreen.x), Y === THREE.DoubleSide || A === (Y === THREE.FrontSide)) {
                            if (p === t) {
                                var Ea = new THREE.RenderableFace3;
                                r.push(Ea);
                                t++;
                                p++;
                                l = Ea
                            } else l = r[p++];
                            l.id = U.id;
                            l.v1.copy(V);
                            l.v2.copy(P);
                            l.v3.copy(ia);
                            l.normalModel.copy($.normal);
                            !1 === A && (Y === THREE.BackSide || Y === THREE.DoubleSide) && l.normalModel.negate();
                            l.normalModel.applyMatrix3(Q).normalize();
                            l.normalModelView.copy(l.normalModel).applyMatrix3(J);
                            l.centroidModel.copy($.centroid).applyMatrix4(x);
                            ia = $.vertexNormals;
                            V = 0;
                            for (P = Math.min(ia.length, 3); V < P; V++) Ea = l.vertexNormalsModel[V], Ea.copy(ia[V]), !1 === A && (Y === THREE.BackSide || Y === THREE.DoubleSide) && Ea.negate(), Ea.applyMatrix3(Q).normalize(), l.vertexNormalsModelView[V].copy(Ea).applyMatrix3(J);
                            l.vertexNormalsLength = ia.length;
                            A = 0;
                            for (V = Math.min(ka.length, 3); A < V; A++)
                                if (ia = ka[A][ea], void 0 !== ia) {
                                    P = 0;
                                    for (Y = ia.length; P < Y; P++) l.uvs[A][P] = ia[P]
                                }
                            l.color = $.color;
                            l.material = fa;
                            ca.copy(l.centroidModel).applyProjection(v);
                            l.z = ca.z;
                            y.elements.push(l)
                        }
            } else if (U instanceof THREE.Line) {
            G.multiplyMatrices(v, x);
            ea = U.geometry.vertices;
            V = a();
            V.positionScreen.copy(ea[0]).applyMatrix4(G);
            ta = U.type === THREE.LinePieces ? 2 : 1;
            M = 1;
            for ($ = ea.length; M < $; M++) V = a(), V.positionScreen.copy(ea[M]).applyMatrix4(G), 0 < (M + 1) % ta || (P = k[i - 2], pa.copy(V.positionScreen), N.copy(P.positionScreen), !0 === c(pa, N) && (pa.multiplyScalar(1 / pa.w), N.multiplyScalar(1 / N.w), s === u ? (ka = new THREE.RenderableLine, q.push(ka), u++, s++, n = ka) : n = q[s++], n.id = U.id, n.v1.positionScreen.copy(pa), n.v2.positionScreen.copy(N), n.z = Math.max(pa.z, N.z), n.material = U.material, U.material.vertexColors === THREE.VertexColors && (n.vertexColors[0].copy(U.geometry.colors[M]), n.vertexColors[1].copy(U.geometry.colors[M - 1])), y.elements.push(n)))
        }
        d = 0;
        for (h = y.sprites.length; d < h; d++) U = y.sprites[d].object, x = U.matrixWorld, U instanceof THREE.Particle && (z.set(x.elements[12], x.elements[13], x.elements[14], 1), z.applyMatrix4(v), fa = 1 / z.w, z.z *= fa, 0 < z.z && 1 > z.z && (E === F ? (ta = new THREE.RenderableParticle, C.push(ta), F++, E++, w = ta) : w = C[E++], w.id = U.id, w.x = z.x * fa, w.y = z.y * fa, w.z = z.z, w.object = U, w.rotation = U.rotation.z, w.scale.x = U.scale.x * Math.abs(w.x - (z.x + f.projectionMatrix.elements[0]) / (z.w + f.projectionMatrix.elements[12])), w.scale.y = U.scale.y * Math.abs(w.y - (z.y + f.projectionMatrix.elements[5]) / (z.w + f.projectionMatrix.elements[13])), w.material = U.material, y.elements.push(w)));
        !0 === m && y.elements.sort(b);
        return y
    }
};
THREE.Face3 = function (a, b, c, d, e, f) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3;
    this.vertexNormals = d instanceof Array ? d : [];
    this.color = e instanceof THREE.Color ? e : new THREE.Color;
    this.vertexColors = e instanceof Array ? e : [];
    this.vertexTangents = [];
    this.materialIndex = void 0 !== f ? f : 0;
    this.centroid = new THREE.Vector3
};
THREE.Face3.prototype = {
    constructor: THREE.Face3,
    clone: function () {
        var a = new THREE.Face3(this.a, this.b, this.c);
        a.normal.copy(this.normal);
        a.color.copy(this.color);
        a.centroid.copy(this.centroid);
        a.materialIndex = this.materialIndex;
        var b, c;
        b = 0;
        for (c = this.vertexNormals.length; b < c; b++) a.vertexNormals[b] = this.vertexNormals[b].clone();
        b = 0;
        for (c = this.vertexColors.length; b < c; b++) a.vertexColors[b] = this.vertexColors[b].clone();
        b = 0;
        for (c = this.vertexTangents.length; b < c; b++) a.vertexTangents[b] = this.vertexTangents[b].clone();
        return a
    }
};
THREE.Face4 = function (a, b, c, d, e, f, h) {
    console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
    return new THREE.Face3(a, b, c, e, f, h)
};
THREE.Geometry = function () {
    this.id = THREE.GeometryIdCount++;
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [
        []
    ];
    this.morphTargets = [];
    this.morphColors = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingSphere = this.boundingBox = null;
    this.hasTangents = !1;
    this.dynamic = !0;
    this.buffersNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1
};
THREE.Geometry.prototype = {
    constructor: THREE.Geometry,
    applyMatrix: function (a) {
        for (var b = (new THREE.Matrix3).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) this.vertices[c].applyMatrix4(a);
        c = 0;
        for (d = this.faces.length; c < d; c++) {
            var e = this.faces[c];
            e.normal.applyMatrix3(b).normalize();
            for (var f = 0, h = e.vertexNormals.length; f < h; f++) e.vertexNormals[f].applyMatrix3(b).normalize();
            e.centroid.applyMatrix4(a)
        }
        this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox();
        this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere()
    },
    computeCentroids: function () {
        var a, b, c;
        a = 0;
        for (b = this.faces.length; a < b; a++) c = this.faces[a], c.centroid.set(0, 0, 0), c.centroid.add(this.vertices[c.a]), c.centroid.add(this.vertices[c.b]), c.centroid.add(this.vertices[c.c]), c.centroid.divideScalar(3)
    },
    computeFaceNormals: function () {
        for (var a = new THREE.Vector3, b = new THREE.Vector3, c = 0, d = this.faces.length; c < d; c++) {
            var e = this.faces[c],
                f = this.vertices[e.a],
                h = this.vertices[e.b];
            a.subVectors(this.vertices[e.c], h);
            b.subVectors(f, h);
            a.cross(b);
            a.normalize();
            e.normal.copy(a)
        }
    },
    computeVertexNormals: function (a) {
        var b, c, d, e;
        if (void 0 === this.__tmpVertices) {
            e = this.__tmpVertices = Array(this.vertices.length);
            b = 0;
            for (c = this.vertices.length; b < c; b++) e[b] = new THREE.Vector3;
            b = 0;
            for (c = this.faces.length; b < c; b++) d = this.faces[b], d.vertexNormals = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3]
        } else {
            e = this.__tmpVertices;
            b = 0;
            for (c = this.vertices.length; b < c; b++) e[b].set(0, 0, 0)
        } if (a) {
            var f, h, g = new THREE.Vector3,
                i = new THREE.Vector3;
            new THREE.Vector3;
            new THREE.Vector3;
            new THREE.Vector3;
            b = 0;
            for (c = this.faces.length; b < c; b++) d = this.faces[b], a = this.vertices[d.a], f = this.vertices[d.b], h = this.vertices[d.c], g.subVectors(h, f), i.subVectors(a, f), g.cross(i), e[d.a].add(g), e[d.b].add(g), e[d.c].add(g)
        } else {
            b = 0;
            for (c = this.faces.length; b < c; b++) d = this.faces[b], e[d.a].add(d.normal), e[d.b].add(d.normal), e[d.c].add(d.normal)
        }
        b = 0;
        for (c = this.vertices.length; b < c; b++) e[b].normalize();
        b = 0;
        for (c = this.faces.length; b < c; b++) d = this.faces[b], d.vertexNormals[0].copy(e[d.a]), d.vertexNormals[1].copy(e[d.b]), d.vertexNormals[2].copy(e[d.c])
    },
    computeMorphNormals: function () {
        var a, b, c, d, e;
        c = 0;
        for (d = this.faces.length; c < d; c++) {
            e = this.faces[c];
            e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone();
            e.__originalVertexNormals || (e.__originalVertexNormals = []);
            a = 0;
            for (b = e.vertexNormals.length; a < b; a++) e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone()
        }
        var f = new THREE.Geometry;
        f.faces = this.faces;
        a = 0;
        for (b = this.morphTargets.length; a < b; a++) {
            if (!this.morphNormals[a]) {
                this.morphNormals[a] = {};
                this.morphNormals[a].faceNormals = [];
                this.morphNormals[a].vertexNormals = [];
                e = this.morphNormals[a].faceNormals;
                var h = this.morphNormals[a].vertexNormals,
                    g, i;
                c = 0;
                for (d = this.faces.length; c < d; c++) g = new THREE.Vector3, i = {
                    a: new THREE.Vector3,
                    b: new THREE.Vector3,
                    c: new THREE.Vector3
                }, e.push(g), h.push(i)
            }
            h = this.morphNormals[a];
            f.vertices = this.morphTargets[a].vertices;
            f.computeFaceNormals();
            f.computeVertexNormals();
            c = 0;
            for (d = this.faces.length; c < d; c++) e = this.faces[c], g = h.faceNormals[c], i = h.vertexNormals[c], g.copy(e.normal), i.a.copy(e.vertexNormals[0]), i.b.copy(e.vertexNormals[1]), i.c.copy(e.vertexNormals[2])
        }
        c = 0;
        for (d = this.faces.length; c < d; c++) e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
    },
    computeTangents: function () {
        var a, b, c, d, e, f, h, g, i, k, m, l, p, r, t, n, s, q = [],
            u = [];
        c = new THREE.Vector3;
        var w = new THREE.Vector3,
            E = new THREE.Vector3,
            C = new THREE.Vector3,
            F = new THREE.Vector3;
        a = 0;
        for (b = this.vertices.length; a < b; a++) q[a] = new THREE.Vector3, u[a] = new THREE.Vector3;
        a = 0;
        for (b = this.faces.length; a < b; a++) e = this.faces[a], f = this.faceVertexUvs[0][a], d = e.a, s = e.b, e = e.c, h = this.vertices[d], g = this.vertices[s], i = this.vertices[e], k = f[0], m = f[1], l = f[2], f = g.x - h.x, p = i.x - h.x, r = g.y - h.y, t = i.y - h.y, g = g.z - h.z, h = i.z - h.z, i = m.x - k.x, n = l.x - k.x, m = m.y - k.y, k = l.y - k.y, l = 1 / (i * k - n * m), c.set((k * f - m * p) * l, (k * r - m * t) * l, (k * g - m * h) * l), w.set((i * p - n * f) * l, (i * t - n * r) * l, (i * h - n * g) * l), q[d].add(c), q[s].add(c), q[e].add(c), u[d].add(w), u[s].add(w), u[e].add(w);
        w = ["a", "b", "c", "d"];
        a = 0;
        for (b = this.faces.length; a < b; a++) {
            e = this.faces[a];
            for (c = 0; c < Math.min(e.vertexNormals.length, 3); c++) F.copy(e.vertexNormals[c]), d = e[w[c]], s = q[d], E.copy(s), E.sub(F.multiplyScalar(F.dot(s))).normalize(), C.crossVectors(e.vertexNormals[c], s), d = C.dot(u[d]), d = 0 > d ? -1 : 1, e.vertexTangents[c] = new THREE.Vector4(E.x, E.y, E.z, d)
        }
        this.hasTangents = !0
    },
    computeLineDistances: function () {
        for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++) 0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a
    },
    computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new THREE.Box3);
        this.boundingBox.setFromPoints(this.vertices)
    },
    computeBoundingSphere: function () {
        null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
        this.boundingSphere.setFromPoints(this.vertices)
    },
    mergeVertices: function () {
        var a = {},
            b = [],
            c = [],
            d, e = Math.pow(10, 4),
            f, h;
        this.__tmpVertices = void 0;
        f = 0;
        for (h = this.vertices.length; f < h; f++) d = this.vertices[f], d = Math.round(d.x * e) + "_" + Math.round(d.y * e) + "_" + Math.round(d.z * e), void 0 === a[d] ? (a[d] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[d]];
        a = [];
        f = 0;
        for (h = this.faces.length; f < h; f++) {
            e = this.faces[f];
            e.a = c[e.a];
            e.b = c[e.b];
            e.c = c[e.c];
            e = [e.a, e.b, e.c];
            for (d = 0; 3 > d; d++)
                if (e[d] == e[(d + 1) % 3]) {
                    a.push(f);
                    break
                }
        }
        for (f = a.length - 1; 0 <= f; f--) {
            e = a[f];
            this.faces.splice(e, 1);
            c = 0;
            for (h = this.faceVertexUvs.length; c < h; c++) this.faceVertexUvs[c].splice(e, 1)
        }
        f = this.vertices.length - b.length;
        this.vertices = b;
        return f
    },
    clone: function () {
        for (var a = new THREE.Geometry, b = this.vertices, c = 0, d = b.length; c < d; c++) a.vertices.push(b[c].clone());
        b = this.faces;
        c = 0;
        for (d = b.length; c < d; c++) a.faces.push(b[c].clone());
        b = this.faceVertexUvs[0];
        c = 0;
        for (d = b.length; c < d; c++) {
            for (var e = b[c], f = [], h = 0, g = e.length; h < g; h++) f.push(new THREE.Vector2(e[h].x, e[h].y));
            a.faceVertexUvs[0].push(f)
        }
        return a
    },
    dispose: function () {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
THREE.GeometryIdCount = 0;
THREE.BufferGeometry = function () {
    this.id = THREE.GeometryIdCount++;
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.attributes = {};
    this.dynamic = !0;
    this.offsets = [];
    this.boundingSphere = this.boundingBox = null;
    this.hasTangents = !1;
    this.morphTargets = []
};
THREE.BufferGeometry.prototype = {
    constructor: THREE.BufferGeometry,
    applyMatrix: function (a) {
        var b, c;
        this.attributes.position && (b = this.attributes.position.array);
        this.attributes.normal && (c = this.attributes.normal.array);
        void 0 !== b && (a.multiplyVector3Array(b), this.verticesNeedUpdate = !0);
        void 0 !== c && ((new THREE.Matrix3).getNormalMatrix(a).multiplyVector3Array(c), this.normalizeNormals(), this.normalsNeedUpdate = !0)
    },
    computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new THREE.Box3);
        var a = this.attributes.position.array;
        if (a) {
            var b = this.boundingBox,
                c, d, e;
            3 <= a.length && (b.min.x = b.max.x = a[0], b.min.y = b.max.y = a[1], b.min.z = b.max.z = a[2]);
            for (var f = 3, h = a.length; f < h; f += 3) c = a[f], d = a[f + 1], e = a[f + 2], c < b.min.x ? b.min.x = c : c > b.max.x && (b.max.x = c), d < b.min.y ? b.min.y = d : d > b.max.y && (b.max.y = d), e < b.min.z ? b.min.z = e : e > b.max.z && (b.max.z = e)
        }
        if (void 0 === a || 0 === a.length) this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0)
    },
    computeBoundingSphere: function () {
        var a = new THREE.Box3,
            b = new THREE.Vector3;
        return function () {
            null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
            var c = this.attributes.position.array;
            if (c) {
                for (var d = this.boundingSphere.center, e = 0, f = c.length; e < f; e += 3) b.set(c[e], c[e + 1], c[e + 2]), a.addPoint(b);
                a.center(d);
                for (var h = 0, e = 0, f = c.length; e < f; e += 3) b.set(c[e], c[e + 1], c[e + 2]), h = Math.max(h, d.distanceToSquared(b));
                this.boundingSphere.radius = Math.sqrt(h)
            }
        }
    }(),
    computeVertexNormals: function () {
        if (this.attributes.position) {
            var a, b, c, d;
            a = this.attributes.position.array.length;
            if (void 0 === this.attributes.normal) this.attributes.normal = {
                itemSize: 3,
                array: new Float32Array(a)
            };
            else {
                a = 0;
                for (b = this.attributes.normal.array.length; a < b; a++) this.attributes.normal.array[a] = 0
            }
            var e = this.attributes.position.array,
                f = this.attributes.normal.array,
                h, g, i, k, m, l, p = new THREE.Vector3,
                r = new THREE.Vector3,
                t = new THREE.Vector3,
                n = new THREE.Vector3,
                s = new THREE.Vector3;
            if (this.attributes.index) {
                var q = this.attributes.index.array,
                    u = this.offsets;
                c = 0;
                for (d = u.length; c < d; ++c) {
                    b = u[c].start;
                    h = u[c].count;
                    var w = u[c].index;
                    a = b;
                    for (b += h; a < b; a += 3) h = w + q[a], g = w + q[a + 1], i = w + q[a + 2], k = e[3 * h], m = e[3 * h + 1], l = e[3 * h + 2], p.set(k, m, l), k = e[3 * g], m = e[3 * g + 1], l = e[3 * g + 2], r.set(k, m, l), k = e[3 * i], m = e[3 * i + 1], l = e[3 * i + 2], t.set(k, m, l), n.subVectors(t, r), s.subVectors(p, r), n.cross(s), f[3 * h] += n.x, f[3 * h + 1] += n.y, f[3 * h + 2] += n.z, f[3 * g] += n.x, f[3 * g + 1] += n.y, f[3 * g + 2] += n.z, f[3 * i] += n.x, f[3 * i + 1] += n.y, f[3 * i + 2] += n.z
                }
            } else {
                a = 0;
                for (b = e.length; a < b; a += 9) k = e[a], m = e[a + 1], l = e[a + 2], p.set(k, m, l), k = e[a + 3], m = e[a + 4], l = e[a + 5], r.set(k, m, l), k = e[a + 6], m = e[a + 7], l = e[a + 8], t.set(k, m, l), n.subVectors(t, r), s.subVectors(p, r), n.cross(s), f[a] = n.x, f[a + 1] = n.y, f[a + 2] = n.z, f[a + 3] = n.x, f[a + 4] = n.y, f[a + 5] = n.z, f[a + 6] = n.x, f[a + 7] = n.y, f[a + 8] = n.z
            }
            this.normalizeNormals();
            this.normalsNeedUpdate = !0
        }
    },
    normalizeNormals: function () {
        for (var a = this.attributes.normal.array, b, c, d, e = 0, f = a.length; e < f; e += 3) b = a[e], c = a[e + 1], d = a[e + 2], b = 1 / Math.sqrt(b * b + c * c + d * d), a[e] *= b, a[e + 1] *= b, a[e + 2] *= b
    },
    computeTangents: function () {
        function a(a) {
            oa.x = d[3 * a];
            oa.y = d[3 * a + 1];
            oa.z = d[3 * a + 2];
            pa.copy(oa);
            M = g[a];
            J.copy(M);
            J.sub(oa.multiplyScalar(oa.dot(M))).normalize();
            ca.crossVectors(pa, M);
            R = ca.dot(i[a]);
            N = 0 > R ? -1 : 1;
            h[4 * a] = J.x;
            h[4 * a + 1] = J.y;
            h[4 * a + 2] = J.z;
            h[4 * a + 3] = N
        }
        if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
        else {
            var b = this.attributes.index.array,
                c = this.attributes.position.array,
                d = this.attributes.normal.array,
                e = this.attributes.uv.array,
                f = c.length / 3;
            void 0 === this.attributes.tangent && (this.attributes.tangent = {
                itemSize: 4,
                array: new Float32Array(4 * f)
            });
            for (var h = this.attributes.tangent.array, g = [], i = [], k = 0; k < f; k++) g[k] = new THREE.Vector3, i[k] = new THREE.Vector3;
            var m, l, p, r, t, n, s, q, u, w, E, C, F, y, A, f = new THREE.Vector3,
                k = new THREE.Vector3,
                z, O, B, D, I, v, x, G = this.offsets;
            B = 0;
            for (D = G.length; B < D; ++B) {
                O = G[B].start;
                I = G[B].count;
                var Q = G[B].index;
                z = O;
                for (O += I; z < O; z += 3) I = Q + b[z], v = Q + b[z + 1], x = Q + b[z + 2], m = c[3 * I], l = c[3 * I + 1], p = c[3 * I + 2], r = c[3 * v], t = c[3 * v + 1], n = c[3 * v + 2], s = c[3 * x], q = c[3 * x + 1], u = c[3 * x + 2], w = e[2 * I], E = e[2 * I + 1], C = e[2 * v], F = e[2 * v + 1], y = e[2 * x], A = e[2 * x + 1], r -= m, m = s - m, t -= l, l = q - l, n -= p, p = u - p, C -= w, w = y - w, F -= E, E = A - E, A = 1 / (C * E - w * F), f.set((E * r - F * m) * A, (E * t - F * l) * A, (E * n - F * p) * A), k.set((C * m - w * r) * A, (C * l - w * t) * A, (C * p - w * n) * A), g[I].add(f), g[v].add(f), g[x].add(f), i[I].add(k), i[v].add(k), i[x].add(k)
            }
            var J = new THREE.Vector3,
                ca = new THREE.Vector3,
                oa = new THREE.Vector3,
                pa = new THREE.Vector3,
                N, M, R;
            B = 0;
            for (D = G.length; B < D; ++B) {
                O = G[B].start;
                I = G[B].count;
                Q = G[B].index;
                z = O;
                for (O += I; z < O; z += 3) I = Q + b[z], v = Q + b[z + 1], x = Q + b[z + 2], a(I), a(v), a(x)
            }
            this.tangentsNeedUpdate = this.hasTangents = !0
        }
    },
    clone: function () {
        var a = new THREE.BufferGeometry,
            b = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array],
            c;
        for (c in this.attributes) {
            for (var d = this.attributes[c], e = d.array, f = {
                itemSize: d.itemSize,
                numItems: d.numItems,
                array: null
            }, d = 0, h = b.length; d < h; d++) {
                var g = b[d];
                if (e instanceof g) {
                    f.array = new g(e);
                    break
                }
            }
            a.attributes[c] = f
        }
        d = 0;
        for (h = this.offsets.length; d < h; d++) b = this.offsets[d], a.offsets.push({
            start: b.start,
            index: b.index,
            count: b.count
        });
        return a
    },
    dispose: function () {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
THREE.Camera = function () {
    THREE.Object3D.call(this);
    this.matrixWorldInverse = new THREE.Matrix4;
    this.projectionMatrix = new THREE.Matrix4;
    this.projectionMatrixInverse = new THREE.Matrix4
};
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
THREE.Camera.prototype.lookAt = function () {
    var a = new THREE.Matrix4;
    return function (b) {
        a.lookAt(this.position, b, this.up);
        this.quaternion.setFromRotationMatrix(a)
    }
}();
THREE.Camera.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.Camera);
    THREE.Object3D.prototype.clone.call(this, a);
    a.matrixWorldInverse.copy(this.matrixWorldInverse);
    a.projectionMatrix.copy(this.projectionMatrix);
    a.projectionMatrixInverse.copy(this.projectionMatrixInverse);
    return a
};
THREE.OrthographicCamera = function (a, b, c, d, e, f) {
    THREE.Camera.call(this);
    this.left = a;
    this.right = b;
    this.top = c;
    this.bottom = d;
    this.near = void 0 !== e ? e : .1;
    this.far = void 0 !== f ? f : 2e3;
    this.updateProjectionMatrix()
};
THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
    this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far)
};
THREE.OrthographicCamera.prototype.clone = function () {
    var a = new THREE.OrthographicCamera;
    THREE.Camera.prototype.clone.call(this, a);
    a.left = this.left;
    a.right = this.right;
    a.top = this.top;
    a.bottom = this.bottom;
    a.near = this.near;
    a.far = this.far;
    return a
};
THREE.PerspectiveCamera = function (a, b, c, d) {
    THREE.Camera.call(this);
    this.fov = void 0 !== a ? a : 50;
    this.aspect = void 0 !== b ? b : 1;
    this.near = void 0 !== c ? c : .1;
    this.far = void 0 !== d ? d : 2e3;
    this.updateProjectionMatrix()
};
THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.PerspectiveCamera.prototype.setLens = function (a, b) {
    void 0 === b && (b = 24);
    this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
    this.updateProjectionMatrix()
};
THREE.PerspectiveCamera.prototype.setViewOffset = function (a, b, c, d, e, f) {
    this.fullWidth = a;
    this.fullHeight = b;
    this.x = c;
    this.y = d;
    this.width = e;
    this.height = f;
    this.updateProjectionMatrix()
};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
    if (this.fullWidth) {
        var a = this.fullWidth / this.fullHeight,
            b = Math.tan(THREE.Math.degToRad(.5 * this.fov)) * this.near,
            c = -b,
            d = a * c,
            a = Math.abs(a * b - d),
            c = Math.abs(b - c);
        this.projectionMatrix.makeFrustum(d + this.x * a / this.fullWidth, d + (this.x + this.width) * a / this.fullWidth, b - (this.y + this.height) * c / this.fullHeight, b - this.y * c / this.fullHeight, this.near, this.far)
    } else this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far)
};
THREE.PerspectiveCamera.prototype.clone = function () {
    var a = new THREE.PerspectiveCamera;
    THREE.Camera.prototype.clone.call(this, a);
    a.fov = this.fov;
    a.aspect = this.aspect;
    a.near = this.near;
    a.far = this.far;
    return a
};
THREE.Light = function (a) {
    THREE.Object3D.call(this);
    this.color = new THREE.Color(a)
};
THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
THREE.Light.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.Light);
    THREE.Object3D.prototype.clone.call(this, a);
    a.color.copy(this.color);
    return a
};
THREE.AmbientLight = function (a) {
    THREE.Light.call(this, a)
};
THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
THREE.AmbientLight.prototype.clone = function () {
    var a = new THREE.AmbientLight;
    THREE.Light.prototype.clone.call(this, a);
    return a
};
THREE.AreaLight = function (a, b) {
    THREE.Light.call(this, a);
    this.normal = new THREE.Vector3(0, -1, 0);
    this.right = new THREE.Vector3(1, 0, 0);
    this.intensity = void 0 !== b ? b : 1;
    this.height = this.width = 1;
    this.constantAttenuation = 1.5;
    this.linearAttenuation = .5;
    this.quadraticAttenuation = .1
};
THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight = function (a, b) {
    THREE.Light.call(this, a);
    this.position.set(0, 1, 0);
    this.target = new THREE.Object3D;
    this.intensity = void 0 !== b ? b : 1;
    this.onlyShadow = this.castShadow = !1;
    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5e3;
    this.shadowCameraLeft = -500;
    this.shadowCameraTop = this.shadowCameraRight = 500;
    this.shadowCameraBottom = -500;
    this.shadowCameraVisible = !1;
    this.shadowBias = 0;
    this.shadowDarkness = .5;
    this.shadowMapHeight = this.shadowMapWidth = 512;
    this.shadowCascade = !1;
    this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3);
    this.shadowCascadeCount = 2;
    this.shadowCascadeBias = [0, 0, 0];
    this.shadowCascadeWidth = [512, 512, 512];
    this.shadowCascadeHeight = [512, 512, 512];
    this.shadowCascadeNearZ = [-1, .99, .998];
    this.shadowCascadeFarZ = [.99, .998, 1];
    this.shadowCascadeArray = [];
    this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
};
THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.clone = function () {
    var a = new THREE.DirectionalLight;
    THREE.Light.prototype.clone.call(this, a);
    a.target = this.target.clone();
    a.intensity = this.intensity;
    a.castShadow = this.castShadow;
    a.onlyShadow = this.onlyShadow;
    return a
};
THREE.HemisphereLight = function (a, b, c) {
    THREE.Light.call(this, a);
    this.position.set(0, 100, 0);
    this.groundColor = new THREE.Color(b);
    this.intensity = void 0 !== c ? c : 1
};
THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
THREE.HemisphereLight.prototype.clone = function () {
    var a = new THREE.HemisphereLight;
    THREE.Light.prototype.clone.call(this, a);
    a.groundColor.copy(this.groundColor);
    a.intensity = this.intensity;
    return a
};
THREE.PointLight = function (a, b, c) {
    THREE.Light.call(this, a);
    this.intensity = void 0 !== b ? b : 1;
    this.distance = void 0 !== c ? c : 0
};
THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
THREE.PointLight.prototype.clone = function () {
    var a = new THREE.PointLight;
    THREE.Light.prototype.clone.call(this, a);
    a.intensity = this.intensity;
    a.distance = this.distance;
    return a
};
THREE.SpotLight = function (a, b, c, d, e) {
    THREE.Light.call(this, a);
    this.position.set(0, 1, 0);
    this.target = new THREE.Object3D;
    this.intensity = void 0 !== b ? b : 1;
    this.distance = void 0 !== c ? c : 0;
    this.angle = void 0 !== d ? d : Math.PI / 3;
    this.exponent = void 0 !== e ? e : 10;
    this.onlyShadow = this.castShadow = !1;
    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5e3;
    this.shadowCameraFov = 50;
    this.shadowCameraVisible = !1;
    this.shadowBias = 0;
    this.shadowDarkness = .5;
    this.shadowMapHeight = this.shadowMapWidth = 512;
    this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
};
THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
THREE.SpotLight.prototype.clone = function () {
    var a = new THREE.SpotLight;
    THREE.Light.prototype.clone.call(this, a);
    a.target = this.target.clone();
    a.intensity = this.intensity;
    a.distance = this.distance;
    a.angle = this.angle;
    a.exponent = this.exponent;
    a.castShadow = this.castShadow;
    a.onlyShadow = this.onlyShadow;
    return a
};
THREE.Loader = function (a) {
    this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null;
    this.onLoadStart = function () {};
    this.onLoadProgress = function () {};
    this.onLoadComplete = function () {}
};
THREE.Loader.prototype = {
    constructor: THREE.Loader,
    crossOrigin: "anonymous",
    addStatusElement: function () {
        var a = document.createElement("div");
        a.style.position = "absolute";
        a.style.right = "0px";
        a.style.top = "0px";
        a.style.fontSize = "0.8em";
        a.style.textAlign = "left";
        a.style.background = "rgba(0,0,0,0.25)";
        a.style.color = "#fff";
        a.style.width = "120px";
        a.style.padding = "0.5em 0.5em 0.5em 0.5em";
        a.style.zIndex = 1e3;
        a.innerHTML = "Loading ...";
        return a
    },
    updateProgress: function (a) {
        var b = "Loaded ",
            b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) + "%") : b + ((a.loaded / 1e3).toFixed(2) + " KB");
        this.statusDomElement.innerHTML = b
    },
    extractUrlBase: function (a) {
        a = a.split("/");
        a.pop();
        return (1 > a.length ? "." : a.join("/")) + "/"
    },
    initMaterials: function (a, b) {
        for (var c = [], d = 0; d < a.length; ++d) c[d] = THREE.Loader.prototype.createMaterial(a[d], b);
        return c
    },
    needsTangents: function (a) {
        for (var b = 0, c = a.length; b < c; b++)
            if (a[b] instanceof THREE.ShaderMaterial) return !0;
        return !1
    },
    createMaterial: function (a, b) {
        function c(a) {
            a = Math.log(a) / Math.LN2;
            return Math.floor(a) == a
        }

        function d(a) {
            a = Math.log(a) / Math.LN2;
            return Math.pow(2, Math.round(a))
        }

        function e(a, e, f, g, i, k, s) {
            var q = /\.dds$/i.test(f),
                u = b + "/" + f;
            if (q) {
                var w = THREE.ImageUtils.loadCompressedTexture(u);
                a[e] = w
            } else w = document.createElement("canvas"), a[e] = new THREE.Texture(w);
            a[e].sourceFile = f;
            g && (a[e].repeat.set(g[0], g[1]), 1 !== g[0] && (a[e].wrapS = THREE.RepeatWrapping), 1 !== g[1] && (a[e].wrapT = THREE.RepeatWrapping));
            i && a[e].offset.set(i[0], i[1]);
            k && (f = {
                repeat: THREE.RepeatWrapping,
                mirror: THREE.MirroredRepeatWrapping
            }, void 0 !== f[k[0]] && (a[e].wrapS = f[k[0]]), void 0 !== f[k[1]] && (a[e].wrapT = f[k[1]]));
            s && (a[e].anisotropy = s);
            if (!q) {
                var E = a[e],
                    a = new Image;
                a.onload = function () {
                    if (!c(this.width) || !c(this.height)) {
                        var a = d(this.width),
                            b = d(this.height);
                        E.image.width = a;
                        E.image.height = b;
                        E.image.getContext("2d").drawImage(this, 0, 0, a, b)
                    } else E.image = this;
                    E.needsUpdate = !0
                };
                a.crossOrigin = h.crossOrigin;
                a.src = u
            }
        }

        function f(a) {
            return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2]
        }
        var h = this,
            g = "MeshLambertMaterial",
            i = {
                color: 15658734,
                opacity: 1,
                map: null,
                lightMap: null,
                normalMap: null,
                bumpMap: null,
                wireframe: !1
            };
        if (a.shading) {
            var k = a.shading.toLowerCase();
            "phong" === k ? g = "MeshPhongMaterial" : "basic" === k && (g = "MeshBasicMaterial")
        }
        void 0 !== a.blending && void 0 !== THREE[a.blending] && (i.blending = THREE[a.blending]);
        if (void 0 !== a.transparent || 1 > a.opacity) i.transparent = a.transparent;
        void 0 !== a.depthTest && (i.depthTest = a.depthTest);
        void 0 !== a.depthWrite && (i.depthWrite = a.depthWrite);
        void 0 !== a.visible && (i.visible = a.visible);
        void 0 !== a.flipSided && (i.side = THREE.BackSide);
        void 0 !== a.doubleSided && (i.side = THREE.DoubleSide);
        void 0 !== a.wireframe && (i.wireframe = a.wireframe);
        void 0 !== a.vertexColors && ("face" === a.vertexColors ? i.vertexColors = THREE.FaceColors : a.vertexColors && (i.vertexColors = THREE.VertexColors));
        a.colorDiffuse ? i.color = f(a.colorDiffuse) : a.DbgColor && (i.color = a.DbgColor);
        a.colorSpecular && (i.specular = f(a.colorSpecular));
        a.colorAmbient && (i.ambient = f(a.colorAmbient));
        a.transparency && (i.opacity = a.transparency);
        a.specularCoef && (i.shininess = a.specularCoef);
        a.mapDiffuse && b && e(i, "map", a.mapDiffuse, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);
        a.mapLight && b && e(i, "lightMap", a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);
        a.mapBump && b && e(i, "bumpMap", a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);
        a.mapNormal && b && e(i, "normalMap", a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);
        a.mapSpecular && b && e(i, "specularMap", a.mapSpecular, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy);
        a.mapBumpScale && (i.bumpScale = a.mapBumpScale);
        a.mapNormal ? (g = THREE.ShaderLib.normalmap, k = THREE.UniformsUtils.clone(g.uniforms), k.tNormal.value = i.normalMap, a.mapNormalFactor && k.uNormalScale.value.set(a.mapNormalFactor, a.mapNormalFactor), i.map && (k.tDiffuse.value = i.map, k.enableDiffuse.value = !0), i.specularMap && (k.tSpecular.value = i.specularMap, k.enableSpecular.value = !0), i.lightMap && (k.tAO.value = i.lightMap, k.enableAO.value = !0), k.uDiffuseColor.value.setHex(i.color), k.uSpecularColor.value.setHex(i.specular), k.uAmbientColor.value.setHex(i.ambient), k.uShininess.value = i.shininess, void 0 !== i.opacity && (k.uOpacity.value = i.opacity), g = new THREE.ShaderMaterial({
            fragmentShader: g.fragmentShader,
            vertexShader: g.vertexShader,
            uniforms: k,
            lights: !0,
            fog: !0
        }), i.transparent && (g.transparent = !0)) : g = new THREE[g](i);
        void 0 !== a.DbgName && (g.name = a.DbgName);
        return g
    }
};
THREE.XHRLoader = function (a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.XHRLoader.prototype = {
    constructor: THREE.XHRLoader,
    load: function (a, b, c, d) {
        var e = this,
            f = new XMLHttpRequest;
        void 0 !== b && f.addEventListener("load", function (c) {
            b(c.target.responseText);
            e.manager.itemEnd(a)
        }, !1);
        void 0 !== c && f.addEventListener("progress", function (a) {
            c(a)
        }, !1);
        void 0 !== d && f.addEventListener("error", function (a) {
            d(a)
        }, !1);
        void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin);
        f.open("GET", a, !0);
        f.send(null);
        e.manager.itemStart(a)
    },
    setCrossOrigin: function (a) {
        this.crossOrigin = a
    }
};
THREE.ImageLoader = function (a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.ImageLoader.prototype = {
    constructor: THREE.ImageLoader,
    load: function (a, b, c, d) {
        var e = this,
            f = document.createElement("img");
        void 0 !== b && f.addEventListener("load", function () {
            e.manager.itemEnd(a);
            b(this)
        }, !1);
        void 0 !== c && f.addEventListener("progress", function (a) {
            c(a)
        }, !1);
        void 0 !== d && f.addEventListener("error", function (a) {
            d(a)
        }, !1);
        void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin);
        f.src = a;
        e.manager.itemStart(a);
        return f
    },
    setCrossOrigin: function (a) {
        this.crossOrigin = a
    }
};
THREE.JSONLoader = function (a) {
    THREE.Loader.call(this, a);
    this.withCredentials = !1
};
THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);
THREE.JSONLoader.prototype.load = function (a, b, c) {
    c = c && "string" === typeof c ? c : this.extractUrlBase(a);
    this.onLoadStart();
    this.loadAjaxJSON(this, a, b, c)
};
THREE.JSONLoader.prototype.loadAjaxJSON = function (a, b, c, d, e) {
    var f = new XMLHttpRequest,
        h = 0;
    f.onreadystatechange = function () {
        if (f.readyState === f.DONE)
            if (200 === f.status || 0 === f.status) {
                if (f.responseText) {
                    var g = JSON.parse(f.responseText),
                        g = a.parse(g, d);
                    c(g.geometry, g.materials)
                } else console.warn("THREE.JSONLoader: [" + b + "] seems to be unreachable or file there is empty");
                a.onLoadComplete()
            } else console.error("THREE.JSONLoader: Couldn't load [" + b + "] [" + f.status + "]");
        else f.readyState === f.LOADING ? e && (0 === h && (h = f.getResponseHeader("Content-Length")), e({
            total: h,
            loaded: f.responseText.length
        })) : f.readyState === f.HEADERS_RECEIVED && void 0 !== e && (h = f.getResponseHeader("Content-Length"))
    };
    f.open("GET", b, !0);
    f.withCredentials = this.withCredentials;
    f.send(null)
};
THREE.JSONLoader.prototype.parse = function (a, b) {
    var c = new THREE.Geometry,
        d = void 0 !== a.scale ? 1 / a.scale : 1,
        e, f, h, g, i, k, m, l, p, r, t, n, s, q, u = a.faces;
    p = a.vertices;
    var w = a.normals,
        E = a.colors,
        C = 0;
    if (void 0 !== a.uvs) {
        for (e = 0; e < a.uvs.length; e++) a.uvs[e].length && C++;
        for (e = 0; e < C; e++) c.faceVertexUvs[e] = []
    }
    g = 0;
    for (i = p.length; g < i;) k = new THREE.Vector3, k.x = p[g++] * d, k.y = p[g++] * d, k.z = p[g++] * d, c.vertices.push(k);
    g = 0;
    for (i = u.length; g < i;)
        if (p = u[g++], r = p & 1, h = p & 2, e = p & 8, m = p & 16, t = p & 32, k = p & 64, p &= 128, r) {
            r = new THREE.Face3;
            r.a = u[g];
            r.b = u[g + 1];
            r.c = u[g + 3];
            n = new THREE.Face3;
            n.a = u[g + 1];
            n.b = u[g + 2];
            n.c = u[g + 3];
            g += 4;
            h && (h = u[g++], r.materialIndex = h, n.materialIndex = h);
            h = c.faces.length;
            if (e)
                for (e = 0; e < C; e++) {
                    s = a.uvs[e];
                    c.faceVertexUvs[e][h] = [];
                    c.faceVertexUvs[e][h + 1] = [];
                    for (f = 0; 4 > f; f++) l = u[g++], q = s[2 * l], l = s[2 * l + 1], q = new THREE.Vector2(q, l), 2 !== f && c.faceVertexUvs[e][h].push(q), 0 !== f && c.faceVertexUvs[e][h + 1].push(q)
                }
            m && (m = 3 * u[g++], r.normal.set(w[m++], w[m++], w[m]), n.normal.copy(r.normal));
            if (t)
                for (e = 0; 4 > e; e++) m = 3 * u[g++], t = new THREE.Vector3(w[m++], w[m++], w[m]), 2 !== e && r.vertexNormals.push(t), 0 !== e && n.vertexNormals.push(t);
            k && (k = u[g++], k = E[k], r.color.setHex(k), n.color.setHex(k));
            if (p)
                for (e = 0; 4 > e; e++) k = u[g++], k = E[k], 2 !== e && r.vertexColors.push(new THREE.Color(k)), 0 !== e && n.vertexColors.push(new THREE.Color(k));
            c.faces.push(r);
            c.faces.push(n)
        } else {
            r = new THREE.Face3;
            r.a = u[g++];
            r.b = u[g++];
            r.c = u[g++];
            h && (h = u[g++], r.materialIndex = h);
            h = c.faces.length;
            if (e)
                for (e = 0; e < C; e++) {
                    s = a.uvs[e];
                    c.faceVertexUvs[e][h] = [];
                    for (f = 0; 3 > f; f++) l = u[g++], q = s[2 * l], l = s[2 * l + 1], q = new THREE.Vector2(q, l), c.faceVertexUvs[e][h].push(q)
                }
            m && (m = 3 * u[g++], r.normal.set(w[m++], w[m++], w[m]));
            if (t)
                for (e = 0; 3 > e; e++) m = 3 * u[g++], t = new THREE.Vector3(w[m++], w[m++], w[m]), r.vertexNormals.push(t);
            k && (k = u[g++], r.color.setHex(E[k]));
            if (p)
                for (e = 0; 3 > e; e++) k = u[g++], r.vertexColors.push(new THREE.Color(E[k]));
            c.faces.push(r)
        }
    if (a.skinWeights) {
        g = 0;
        for (i = a.skinWeights.length; g < i; g += 2) u = a.skinWeights[g], w = a.skinWeights[g + 1], c.skinWeights.push(new THREE.Vector4(u, w, 0, 0))
    }
    if (a.skinIndices) {
        g = 0;
        for (i = a.skinIndices.length; g < i; g += 2) u = a.skinIndices[g], w = a.skinIndices[g + 1], c.skinIndices.push(new THREE.Vector4(u, w, 0, 0))
    }
    c.bones = a.bones;
    c.animation = a.animation;
    if (void 0 !== a.morphTargets) {
        g = 0;
        for (i = a.morphTargets.length; g < i; g++) {
            c.morphTargets[g] = {};
            c.morphTargets[g].name = a.morphTargets[g].name;
            c.morphTargets[g].vertices = [];
            E = c.morphTargets[g].vertices;
            C = a.morphTargets[g].vertices;
            u = 0;
            for (w = C.length; u < w; u += 3) p = new THREE.Vector3, p.x = C[u] * d, p.y = C[u + 1] * d, p.z = C[u + 2] * d, E.push(p)
        }
    }
    if (void 0 !== a.morphColors) {
        g = 0;
        for (i = a.morphColors.length; g < i; g++) {
            c.morphColors[g] = {};
            c.morphColors[g].name = a.morphColors[g].name;
            c.morphColors[g].colors = [];
            w = c.morphColors[g].colors;
            E = a.morphColors[g].colors;
            d = 0;
            for (u = E.length; d < u; d += 3) C = new THREE.Color(16755200), C.setRGB(E[d], E[d + 1], E[d + 2]), w.push(C)
        }
    }
    c.computeCentroids();
    c.computeFaceNormals();
    c.computeBoundingSphere();
    if (void 0 === a.materials) return {
        geometry: c
    };
    d = this.initMaterials(a.materials, b);
    this.needsTangents(d) && c.computeTangents();
    return {
        geometry: c,
        materials: d
    }
};
THREE.LoadingManager = function (a, b, c) {
    var d = this,
        e = 0,
        f = 0;
    this.onLoad = a;
    this.onProgress = b;
    this.onError = c;
    this.itemStart = function () {
        f++
    };
    this.itemEnd = function (a) {
        e++;
        if (void 0 !== d.onProgress) d.onProgress(a, e, f);
        if (e === f && void 0 !== d.onLoad) d.onLoad()
    }
};
THREE.DefaultLoadingManager = new THREE.LoadingManager;
THREE.BufferGeometryLoader = function (a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.BufferGeometryLoader.prototype = {
    constructor: THREE.BufferGeometryLoader,
    load: function (a, b) {
        var c = this,
            d = new THREE.XHRLoader;
        d.setCrossOrigin(this.crossOrigin);
        d.load(a, function (a) {
            b(c.parse(JSON.parse(a)))
        })
    },
    setCrossOrigin: function (a) {
        this.crossOrigin = a
    },
    parse: function (a) {
        var b = new THREE.BufferGeometry,
            c = a.attributes,
            d = a.offsets,
            a = a.boundingSphere,
            e;
        for (e in c) {
            var f = c[e];
            b.attributes[e] = {
                itemSize: f.itemSize,
                array: new self[f.type](f.array)
            }
        }
        void 0 !== d && (b.offsets = JSON.parse(JSON.stringify(d)));
        void 0 !== a && (b.boundingSphere = new THREE.Sphere((new THREE.Vector3).fromArray(void 0 !== a.center ? a.center : [0, 0, 0]), a.radius));
        return b
    }
};
THREE.GeometryLoader = function (a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.GeometryLoader.prototype = {
    constructor: THREE.GeometryLoader,
    load: function (a, b) {
        var c = this,
            d = new THREE.XHRLoader;
        d.setCrossOrigin(this.crossOrigin);
        d.load(a, function (a) {
            b(c.parse(JSON.parse(a)))
        })
    },
    setCrossOrigin: function (a) {
        this.crossOrigin = a
    },
    parse: function () {}
};
THREE.MaterialLoader = function (a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.MaterialLoader.prototype = {
    constructor: THREE.MaterialLoader,
    load: function (a, b) {
        var c = this,
            d = new THREE.XHRLoader;
        d.setCrossOrigin(this.crossOrigin);
        d.load(a, function (a) {
            b(c.parse(JSON.parse(a)))
        })
    },
    setCrossOrigin: function (a) {
        this.crossOrigin = a
    },
    parse: function (a) {
        var b = new THREE[a.type];
        void 0 !== a.color && b.color.setHex(a.color);
        void 0 !== a.ambient && b.ambient.setHex(a.ambient);
        void 0 !== a.emissive && b.emissive.setHex(a.emissive);
        void 0 !== a.specular && b.specular.setHex(a.specular);
        void 0 !== a.shininess && (b.shininess = a.shininess);
        void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors);
        void 0 !== a.blending && (b.blending = a.blending);
        void 0 !== a.opacity && (b.opacity = a.opacity);
        void 0 !== a.transparent && (b.transparent = a.transparent);
        void 0 !== a.wireframe && (b.wireframe = a.wireframe);
        if (void 0 !== a.materials)
            for (var c = 0, d = a.materials.length; c < d; c++) b.materials.push(this.parse(a.materials[c]));
        return b
    }
};
THREE.ObjectLoader = function (a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.ObjectLoader.prototype = {
    constructor: THREE.ObjectLoader,
    load: function (a, b) {
        var c = this,
            d = new THREE.XHRLoader(c.manager);
        d.setCrossOrigin(this.crossOrigin);
        d.load(a, function (a) {
            b(c.parse(JSON.parse(a)))
        })
    },
    setCrossOrigin: function (a) {
        this.crossOrigin = a
    },
    parse: function (a) {
        var b = this.parseGeometries(a.geometries),
            c = this.parseMaterials(a.materials);
        return this.parseObject(a.object, b, c)
    },
    parseGeometries: function (a) {
        var b = {};
        if (void 0 !== a)
            for (var c = new THREE.JSONLoader, d = new THREE.BufferGeometryLoader, e = 0, f = a.length; e < f; e++) {
                var h, g = a[e];
                switch (g.type) {
                case "PlaneGeometry":
                    h = new THREE.PlaneGeometry(g.width, g.height, g.widthSegments, g.heightSegments);
                    break;
                case "CircleGeometry":
                    h = new THREE.CircleGeometry(g.radius, g.segments);
                    break;
                case "CubeGeometry":
                    h = new THREE.CubeGeometry(g.width, g.height, g.depth, g.widthSegments, g.heightSegments, g.depthSegments);
                    break;
                case "CylinderGeometry":
                    h = new THREE.CylinderGeometry(g.radiusTop, g.radiusBottom, g.height, g.radiusSegments, g.heightSegments, g.openEnded);
                    break;
                case "SphereGeometry":
                    h = new THREE.SphereGeometry(g.radius, g.widthSegments, g.heightSegments, g.phiStart, g.phiLength, g.thetaStart, g.thetaLength);
                    break;
                case "IcosahedronGeometry":
                    h = new THREE.IcosahedronGeometry(g.radius, g.detail);
                    break;
                case "TorusGeometry":
                    h = new THREE.TorusGeometry(g.radius, g.tube, g.radialSegments, g.tubularSegments, g.arc);
                    break;
                case "TorusKnotGeometry":
                    h = new THREE.TorusKnotGeometry(g.radius, g.tube, g.radialSegments, g.tubularSegments, g.p, g.q, g.heightScale);
                    break;
                case "BufferGeometry":
                    h = d.parse(g.data);
                    break;
                case "Geometry":
                    h = c.parse(g.data).geometry
                }
                h.uuid = g.uuid;
                void 0 !== g.name && (h.name = g.name);
                b[g.uuid] = h
            }
        return b
    },
    parseMaterials: function (a) {
        var b = {};
        if (void 0 !== a)
            for (var c = new THREE.MaterialLoader, d = 0, e = a.length; d < e; d++) {
                var f = a[d],
                    h = c.parse(f);
                h.uuid = f.uuid;
                void 0 !== f.name && (h.name = f.name);
                b[f.uuid] = h
            }
        return b
    },
    parseObject: function () {
        var a = new THREE.Matrix4;
        return function (b, c, d) {
            var e;
            switch (b.type) {
            case "Scene":
                e = new THREE.Scene;
                break;
            case "PerspectiveCamera":
                e = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far);
                break;
            case "OrthographicCamera":
                e = new THREE.OrthographicCamera(b.left, b.right, b.top, b.bottom, b.near, b.far);
                break;
            case "AmbientLight":
                e = new THREE.AmbientLight(b.color);
                break;
            case "DirectionalLight":
                e = new THREE.DirectionalLight(b.color, b.intensity);
                break;
            case "PointLight":
                e = new THREE.PointLight(b.color, b.intensity, b.distance);
                break;
            case "SpotLight":
                e = new THREE.SpotLight(b.color, b.intensity, b.distance, b.angle, b.exponent);
                break;
            case "HemisphereLight":
                e = new THREE.HemisphereLight(b.color, b.groundColor, b.intensity);
                break;
            case "Mesh":
                e = c[b.geometry];
                var f = d[b.material];
                void 0 === e && console.error("THREE.ObjectLoader: Undefined geometry " + b.geometry);
                void 0 === f && console.error("THREE.ObjectLoader: Undefined material " + b.material);
                e = new THREE.Mesh(e, f);
                break;
            default:
                e = new THREE.Object3D
            }
            e.uuid = b.uuid;
            void 0 !== b.name && (e.name = b.name);
            void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(e.position, e.quaternion, e.scale)) : (void 0 !== b.position && e.position.fromArray(b.position), void 0 !== b.rotation && e.rotation.fromArray(b.rotation), void 0 !== b.scale && e.scale.fromArray(b.scale));
            void 0 !== b.visible && (e.visible = b.visible);
            void 0 !== b.userData && (e.userData = b.userData);
            if (void 0 !== b.children)
                for (var h in b.children) e.add(this.parseObject(b.children[h], c, d));
            return e
        }
    }()
};
THREE.SceneLoader = function () {
    this.onLoadStart = function () {};
    this.onLoadProgress = function () {};
    this.onLoadComplete = function () {};
    this.callbackSync = function () {};
    this.callbackProgress = function () {};
    this.geometryHandlers = {};
    this.hierarchyHandlers = {};
    this.addGeometryHandler("ascii", THREE.JSONLoader)
};
THREE.SceneLoader.prototype = {
    constructor: THREE.SceneLoader,
    load: function (a, b) {
        var c = this,
            d = new THREE.XHRLoader(c.manager);
        d.setCrossOrigin(this.crossOrigin);
        d.load(a, function (d) {
            c.parse(JSON.parse(d), b, a)
        })
    },
    setCrossOrigin: function (a) {
        this.crossOrigin = a
    },
    addGeometryHandler: function (a, b) {
        this.geometryHandlers[a] = {
            loaderClass: b
        }
    },
    addHierarchyHandler: function (a, b) {
        this.hierarchyHandlers[a] = {
            loaderClass: b
        }
    },
    parse: function (a, b, c) {
        function d(a, b) {
            return "relativeToHTML" == b ? a : p + "/" + a
        }

        function e() {
            f(z.scene, B.objects)
        }

        function f(a, b) {
            var c, e, h, i, k, m, p;
            for (p in b) {
                var s = z.objects[p],
                    q = b[p];
                if (void 0 === s) {
                    if (q.type && q.type in l.hierarchyHandlers) {
                        if (void 0 === q.loading) {
                            e = {
                                type: 1,
                                url: 1,
                                material: 1,
                                position: 1,
                                rotation: 1,
                                scale: 1,
                                visible: 1,
                                children: 1,
                                userData: 1,
                                skin: 1,
                                morph: 1,
                                mirroredLoop: 1,
                                duration: 1
                            };
                            h = {};
                            for (var C in q) C in e || (h[C] = q[C]);
                            t = z.materials[q.material];
                            q.loading = !0;
                            e = l.hierarchyHandlers[q.type].loaderObject;
                            e.options ? e.load(d(q.url, B.urlBaseType), g(p, a, t, q)) : e.load(d(q.url, B.urlBaseType), g(p, a, t, q), h)
                        }
                    } else if (void 0 !== q.geometry) {
                        if (r = z.geometries[q.geometry]) {
                            s = !1;
                            t = z.materials[q.material];
                            s = t instanceof THREE.ShaderMaterial;
                            h = q.position;
                            i = q.rotation;
                            k = q.scale;
                            c = q.matrix;
                            m = q.quaternion;
                            q.material || (t = new THREE.MeshFaceMaterial(z.face_materials[q.geometry]));
                            t instanceof THREE.MeshFaceMaterial && 0 === t.materials.length && (t = new THREE.MeshFaceMaterial(z.face_materials[q.geometry]));
                            if (t instanceof THREE.MeshFaceMaterial)
                                for (e = 0; e < t.materials.length; e++) s = s || t.materials[e] instanceof THREE.ShaderMaterial;
                            s && r.computeTangents();
                            q.skin ? s = new THREE.SkinnedMesh(r, t) : q.morph ? (s = new THREE.MorphAnimMesh(r, t), void 0 !== q.duration && (s.duration = q.duration), void 0 !== q.time && (s.time = q.time), void 0 !== q.mirroredLoop && (s.mirroredLoop = q.mirroredLoop), t.morphNormals && r.computeMorphNormals()) : s = new THREE.Mesh(r, t);
                            s.name = p;
                            c ? (s.matrixAutoUpdate = !1, s.matrix.set(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10], c[11], c[12], c[13], c[14], c[15])) : (s.position.fromArray(h), m ? s.quaternion.fromArray(m) : s.rotation.fromArray(i), s.scale.fromArray(k));
                            s.visible = q.visible;
                            s.castShadow = q.castShadow;
                            s.receiveShadow = q.receiveShadow;
                            a.add(s);
                            z.objects[p] = s
                        }
                    } else "DirectionalLight" === q.type || "PointLight" === q.type || "AmbientLight" === q.type ? (w = void 0 !== q.color ? q.color : 16777215, E = void 0 !== q.intensity ? q.intensity : 1, "DirectionalLight" === q.type ? (h = q.direction, u = new THREE.DirectionalLight(w, E), u.position.fromArray(h), q.target && (O.push({
                        object: u,
                        targetName: q.target
                    }), u.target = null)) : "PointLight" === q.type ? (h = q.position, e = q.distance, u = new THREE.PointLight(w, E, e), u.position.fromArray(h)) : "AmbientLight" === q.type && (u = new THREE.AmbientLight(w)), a.add(u), u.name = p, z.lights[p] = u, z.objects[p] = u) : "PerspectiveCamera" === q.type || "OrthographicCamera" === q.type ? (h = q.position, i = q.rotation, m = q.quaternion, "PerspectiveCamera" === q.type ? n = new THREE.PerspectiveCamera(q.fov, q.aspect, q.near, q.far) : "OrthographicCamera" === q.type && (n = new THREE.OrthographicCamera(q.left, q.right, q.top, q.bottom, q.near, q.far)), n.name = p, n.position.fromArray(h), void 0 !== m ? n.quaternion.fromArray(m) : void 0 !== i && n.rotation.fromArray(i), a.add(n), z.cameras[p] = n, z.objects[p] = n) : (h = q.position, i = q.rotation, k = q.scale, m = q.quaternion, s = new THREE.Object3D, s.name = p, s.position.fromArray(h), m ? s.quaternion.fromArray(m) : s.rotation.fromArray(i), s.scale.fromArray(k), s.visible = void 0 !== q.visible ? q.visible : !1, a.add(s), z.objects[p] = s, z.empties[p] = s); if (s) {
                        if (void 0 !== q.userData)
                            for (var A in q.userData) s.userData[A] = q.userData[A];
                        if (void 0 !== q.groups)
                            for (e = 0; e < q.groups.length; e++) h = q.groups[e], void 0 === z.groups[h] && (z.groups[h] = []), z.groups[h].push(p)
                    }
                }
                void 0 !== s && void 0 !== q.children && f(s, q.children)
            }
        }

        function h(a) {
            return function (b, c) {
                b.name = a;
                z.geometries[a] = b;
                z.face_materials[a] = c;
                e();
                C -= 1;
                l.onLoadComplete();
                k()
            }
        }

        function g(a, b, c, d) {
            return function (f) {
                var f = f.content ? f.content : f.dae ? f.scene : f,
                    h = d.rotation,
                    g = d.quaternion,
                    i = d.scale;
                f.position.fromArray(d.position);
                g ? f.quaternion.fromArray(g) : f.rotation.fromArray(h);
                f.scale.fromArray(i);
                c && f.traverse(function (a) {
                    a.material = c
                });
                var m = void 0 !== d.visible ? d.visible : !0;
                f.traverse(function (a) {
                    a.visible = m
                });
                b.add(f);
                f.name = a;
                z.objects[a] = f;
                e();
                C -= 1;
                l.onLoadComplete();
                k()
            }
        }

        function i(a) {
            return function (b, c) {
                b.name = a;
                z.geometries[a] = b;
                z.face_materials[a] = c
            }
        }

        function k() {
            l.callbackProgress({
                totalModels: y,
                totalTextures: A,
                loadedModels: y - C,
                loadedTextures: A - F
            }, z);
            l.onLoadProgress();
            if (0 === C && 0 === F) {
                for (var a = 0; a < O.length; a++) {
                    var c = O[a],
                        d = z.objects[c.targetName];
                    d ? c.object.target = d : (c.object.target = new THREE.Object3D, z.scene.add(c.object.target));
                    c.object.target.userData.targetInverse = c.object
                }
                b(z)
            }
        }

        function m(a, b) {
            b(a);
            if (void 0 !== a.children)
                for (var c in a.children) m(a.children[c], b)
        }
        var l = this,
            p = THREE.Loader.prototype.extractUrlBase(c),
            r, t, n, s, q, u, w, E, C, F, y, A, z, O = [],
            B = a,
            D;
        for (D in this.geometryHandlers) a = this.geometryHandlers[D].loaderClass, this.geometryHandlers[D].loaderObject = new a;
        for (D in this.hierarchyHandlers) a = this.hierarchyHandlers[D].loaderClass, this.hierarchyHandlers[D].loaderObject = new a;
        F = C = 0;
        z = {
            scene: new THREE.Scene,
            geometries: {},
            face_materials: {},
            materials: {},
            textures: {},
            objects: {},
            cameras: {},
            lights: {},
            fogs: {},
            empties: {},
            groups: {}
        };
        if (B.transform && (D = B.transform.position, a = B.transform.rotation, c = B.transform.scale, D && z.scene.position.fromArray(D), a && z.scene.rotation.fromArray(a), c && z.scene.scale.fromArray(c), D || a || c)) z.scene.updateMatrix(), z.scene.updateMatrixWorld();
        D = function (a) {
            return function () {
                F -= a;
                k();
                l.onLoadComplete()
            }
        };
        for (var I in B.fogs) a = B.fogs[I], "linear" === a.type ? s = new THREE.Fog(0, a.near, a.far) : "exp2" === a.type && (s = new THREE.FogExp2(0, a.density)), a = a.color, s.color.setRGB(a[0], a[1], a[2]), z.fogs[I] = s;
        for (var v in B.geometries) s = B.geometries[v], s.type in this.geometryHandlers && (C += 1, l.onLoadStart());
        for (var x in B.objects) m(B.objects[x], function (a) {
            a.type && a.type in l.hierarchyHandlers && (C += 1, l.onLoadStart())
        });
        y = C;
        for (v in B.geometries)
            if (s = B.geometries[v], "cube" === s.type) r = new THREE.CubeGeometry(s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments), r.name = v, z.geometries[v] = r;
            else if ("plane" === s.type) r = new THREE.PlaneGeometry(s.width, s.height, s.widthSegments, s.heightSegments), r.name = v, z.geometries[v] = r;
        else if ("sphere" === s.type) r = new THREE.SphereGeometry(s.radius, s.widthSegments, s.heightSegments), r.name = v, z.geometries[v] = r;
        else if ("cylinder" === s.type) r = new THREE.CylinderGeometry(s.topRad, s.botRad, s.height, s.radSegs, s.heightSegs), r.name = v, z.geometries[v] = r;
        else if ("torus" === s.type) r = new THREE.TorusGeometry(s.radius, s.tube, s.segmentsR, s.segmentsT), r.name = v, z.geometries[v] = r;
        else if ("icosahedron" === s.type) r = new THREE.IcosahedronGeometry(s.radius, s.subdivisions), r.name = v, z.geometries[v] = r;
        else if (s.type in this.geometryHandlers) {
            x = {};
            for (q in s) "type" !== q && "url" !== q && (x[q] = s[q]);
            this.geometryHandlers[s.type].loaderObject.load(d(s.url, B.urlBaseType), h(v), x)
        } else "embedded" === s.type && (x = B.embeds[s.id], x.metadata = B.metadata, x && (x = this.geometryHandlers.ascii.loaderObject.parse(x, ""), i(v)(x.geometry, x.materials)));
        for (var G in B.textures)
            if (v = B.textures[G], v.url instanceof Array) {
                F += v.url.length;
                for (q = 0; q < v.url.length; q++) l.onLoadStart()
            } else F += 1, l.onLoadStart();
        A = F;
        for (G in B.textures) {
            v = B.textures[G];
            void 0 !== v.mapping && void 0 !== THREE[v.mapping] && (v.mapping = new THREE[v.mapping]);
            if (v.url instanceof Array) {
                x = v.url.length;
                s = [];
                for (q = 0; q < x; q++) s[q] = d(v.url[q], B.urlBaseType);
                q = (q = /\.dds$/i.test(s[0])) ? THREE.ImageUtils.loadCompressedTextureCube(s, v.mapping, D(x)) : THREE.ImageUtils.loadTextureCube(s, v.mapping, D(x))
            } else q = /\.dds$/i.test(v.url), x = d(v.url, B.urlBaseType), s = D(1), q = q ? THREE.ImageUtils.loadCompressedTexture(x, v.mapping, s) : THREE.ImageUtils.loadTexture(x, v.mapping, s), void 0 !== THREE[v.minFilter] && (q.minFilter = THREE[v.minFilter]), void 0 !== THREE[v.magFilter] && (q.magFilter = THREE[v.magFilter]), v.anisotropy && (q.anisotropy = v.anisotropy), v.repeat && (q.repeat.set(v.repeat[0], v.repeat[1]), 1 !== v.repeat[0] && (q.wrapS = THREE.RepeatWrapping), 1 !== v.repeat[1] && (q.wrapT = THREE.RepeatWrapping)), v.offset && q.offset.set(v.offset[0], v.offset[1]), v.wrap && (x = {
                repeat: THREE.RepeatWrapping,
                mirror: THREE.MirroredRepeatWrapping
            }, void 0 !== x[v.wrap[0]] && (q.wrapS = x[v.wrap[0]]), void 0 !== x[v.wrap[1]] && (q.wrapT = x[v.wrap[1]]));
            z.textures[G] = q
        }
        var Q, J;
        for (Q in B.materials) {
            G = B.materials[Q];
            for (J in G.parameters) "envMap" === J || "map" === J || "lightMap" === J || "bumpMap" === J ? G.parameters[J] = z.textures[G.parameters[J]] : "shading" === J ? G.parameters[J] = "flat" === G.parameters[J] ? THREE.FlatShading : THREE.SmoothShading : "side" === J ? G.parameters[J] = "double" == G.parameters[J] ? THREE.DoubleSide : "back" == G.parameters[J] ? THREE.BackSide : THREE.FrontSide : "blending" === J ? G.parameters[J] = G.parameters[J] in THREE ? THREE[G.parameters[J]] : THREE.NormalBlending : "combine" === J ? G.parameters[J] = G.parameters[J] in THREE ? THREE[G.parameters[J]] : THREE.MultiplyOperation : "vertexColors" === J ? "face" == G.parameters[J] ? G.parameters[J] = THREE.FaceColors : G.parameters[J] && (G.parameters[J] = THREE.VertexColors) : "wrapRGB" === J && (D = G.parameters[J], G.parameters[J] = new THREE.Vector3(D[0], D[1], D[2]));
            void 0 !== G.parameters.opacity && 1 > G.parameters.opacity && (G.parameters.transparent = !0);
            G.parameters.normalMap ? (D = THREE.ShaderLib.normalmap, v = THREE.UniformsUtils.clone(D.uniforms), q = G.parameters.color, x = G.parameters.specular, s = G.parameters.ambient, I = G.parameters.shininess, v.tNormal.value = z.textures[G.parameters.normalMap], G.parameters.normalScale && v.uNormalScale.value.set(G.parameters.normalScale[0], G.parameters.normalScale[1]), G.parameters.map && (v.tDiffuse.value = G.parameters.map, v.enableDiffuse.value = !0), G.parameters.envMap && (v.tCube.value = G.parameters.envMap, v.enableReflection.value = !0, v.uReflectivity.value = G.parameters.reflectivity), G.parameters.lightMap && (v.tAO.value = G.parameters.lightMap, v.enableAO.value = !0), G.parameters.specularMap && (v.tSpecular.value = z.textures[G.parameters.specularMap], v.enableSpecular.value = !0), G.parameters.displacementMap && (v.tDisplacement.value = z.textures[G.parameters.displacementMap], v.enableDisplacement.value = !0, v.uDisplacementBias.value = G.parameters.displacementBias, v.uDisplacementScale.value = G.parameters.displacementScale), v.uDiffuseColor.value.setHex(q), v.uSpecularColor.value.setHex(x), v.uAmbientColor.value.setHex(s), v.uShininess.value = I, G.parameters.opacity && (v.uOpacity.value = G.parameters.opacity), t = new THREE.ShaderMaterial({
                fragmentShader: D.fragmentShader,
                vertexShader: D.vertexShader,
                uniforms: v,
                lights: !0,
                fog: !0
            })) : t = new THREE[G.type](G.parameters);
            t.name = Q;
            z.materials[Q] = t
        }
        for (Q in B.materials)
            if (G = B.materials[Q], G.parameters.materials) {
                J = [];
                for (q = 0; q < G.parameters.materials.length; q++) J.push(z.materials[G.parameters.materials[q]]);
                z.materials[Q].materials = J
            }
        e();
        z.cameras && B.defaults.camera && (z.currentCamera = z.cameras[B.defaults.camera]);
        z.fogs && B.defaults.fog && (z.scene.fog = z.fogs[B.defaults.fog]);
        l.callbackSync(z);
        k()
    }
};
THREE.TextureLoader = function (a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.TextureLoader.prototype = {
    constructor: THREE.TextureLoader,
    load: function (a, b) {
        var c = new THREE.ImageLoader(this.manager);
        c.setCrossOrigin(this.crossOrigin);
        c.load(a, function (a) {
            a = new THREE.Texture(a);
            a.needsUpdate = !0;
            void 0 !== b && b(a)
        })
    },
    setCrossOrigin: function (a) {
        this.crossOrigin = a
    }
};
THREE.Material = function () {
    this.id = THREE.MaterialIdCount++;
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.side = THREE.FrontSide;
    this.opacity = 1;
    this.transparent = !1;
    this.blending = THREE.NormalBlending;
    this.blendSrc = THREE.SrcAlphaFactor;
    this.blendDst = THREE.OneMinusSrcAlphaFactor;
    this.blendEquation = THREE.AddEquation;
    this.depthWrite = this.depthTest = !0;
    this.polygonOffset = !1;
    this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
    this.needsUpdate = this.visible = !0
};
THREE.Material.prototype = {
    constructor: THREE.Material,
    setValues: function (a) {
        if (void 0 !== a)
            for (var b in a) {
                var c = a[b];
                if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
                else if (b in this) {
                    var d = this[b];
                    d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) : this[b] = "overdraw" == b ? Number(c) : c
                }
            }
    },
    clone: function (a) {
        void 0 === a && (a = new THREE.Material);
        a.name = this.name;
        a.side = this.side;
        a.opacity = this.opacity;
        a.transparent = this.transparent;
        a.blending = this.blending;
        a.blendSrc = this.blendSrc;
        a.blendDst = this.blendDst;
        a.blendEquation = this.blendEquation;
        a.depthTest = this.depthTest;
        a.depthWrite = this.depthWrite;
        a.polygonOffset = this.polygonOffset;
        a.polygonOffsetFactor = this.polygonOffsetFactor;
        a.polygonOffsetUnits = this.polygonOffsetUnits;
        a.alphaTest = this.alphaTest;
        a.overdraw = this.overdraw;
        a.visible = this.visible;
        return a
    },
    dispose: function () {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount = 0;
THREE.LineBasicMaterial = function (a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.linewidth = 1;
    this.linejoin = this.linecap = "round";
    this.vertexColors = !1;
    this.fog = !0;
    this.setValues(a)
};
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.clone = function () {
    var a = new THREE.LineBasicMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.linewidth = this.linewidth;
    a.linecap = this.linecap;
    a.linejoin = this.linejoin;
    a.vertexColors = this.vertexColors;
    a.fog = this.fog;
    return a
};
THREE.LineDashedMaterial = function (a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.scale = this.linewidth = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.vertexColors = !1;
    this.fog = !0;
    this.setValues(a)
};
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.clone = function () {
    var a = new THREE.LineDashedMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.linewidth = this.linewidth;
    a.scale = this.scale;
    a.dashSize = this.dashSize;
    a.gapSize = this.gapSize;
    a.vertexColors = this.vertexColors;
    a.fog = this.fog;
    return a
};
THREE.MeshBasicMaterial = function (a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.envMap = this.specularMap = this.lightMap = this.map = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.fog = !0;
    this.shading = THREE.SmoothShading;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.vertexColors = THREE.NoColors;
    this.morphTargets = this.skinning = !1;
    this.setValues(a)
};
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.clone = function () {
    var a = new THREE.MeshBasicMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.map = this.map;
    a.lightMap = this.lightMap;
    a.specularMap = this.specularMap;
    a.envMap = this.envMap;
    a.combine = this.combine;
    a.reflectivity = this.reflectivity;
    a.refractionRatio = this.refractionRatio;
    a.fog = this.fog;
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    a.wireframeLinecap = this.wireframeLinecap;
    a.wireframeLinejoin = this.wireframeLinejoin;
    a.vertexColors = this.vertexColors;
    a.skinning = this.skinning;
    a.morphTargets = this.morphTargets;
    return a
};
THREE.MeshLambertMaterial = function (a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.ambient = new THREE.Color(16777215);
    this.emissive = new THREE.Color(0);
    this.wrapAround = !1;
    this.wrapRGB = new THREE.Vector3(1, 1, 1);
    this.envMap = this.specularMap = this.lightMap = this.map = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.fog = !0;
    this.shading = THREE.SmoothShading;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.vertexColors = THREE.NoColors;
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(a)
};
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.clone = function () {
    var a = new THREE.MeshLambertMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.ambient.copy(this.ambient);
    a.emissive.copy(this.emissive);
    a.wrapAround = this.wrapAround;
    a.wrapRGB.copy(this.wrapRGB);
    a.map = this.map;
    a.lightMap = this.lightMap;
    a.specularMap = this.specularMap;
    a.envMap = this.envMap;
    a.combine = this.combine;
    a.reflectivity = this.reflectivity;
    a.refractionRatio = this.refractionRatio;
    a.fog = this.fog;
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    a.wireframeLinecap = this.wireframeLinecap;
    a.wireframeLinejoin = this.wireframeLinejoin;
    a.vertexColors = this.vertexColors;
    a.skinning = this.skinning;
    a.morphTargets = this.morphTargets;
    a.morphNormals = this.morphNormals;
    return a
};
THREE.MeshPhongMaterial = function (a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.ambient = new THREE.Color(16777215);
    this.emissive = new THREE.Color(0);
    this.specular = new THREE.Color(1118481);
    this.shininess = 30;
    this.metal = !1;
    this.perPixel = !0;
    this.wrapAround = !1;
    this.wrapRGB = new THREE.Vector3(1, 1, 1);
    this.bumpMap = this.lightMap = this.map = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalScale = new THREE.Vector2(1, 1);
    this.envMap = this.specularMap = null;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.fog = !0;
    this.shading = THREE.SmoothShading;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.vertexColors = THREE.NoColors;
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(a)
};
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.clone = function () {
    var a = new THREE.MeshPhongMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.ambient.copy(this.ambient);
    a.emissive.copy(this.emissive);
    a.specular.copy(this.specular);
    a.shininess = this.shininess;
    a.metal = this.metal;
    a.perPixel = this.perPixel;
    a.wrapAround = this.wrapAround;
    a.wrapRGB.copy(this.wrapRGB);
    a.map = this.map;
    a.lightMap = this.lightMap;
    a.bumpMap = this.bumpMap;
    a.bumpScale = this.bumpScale;
    a.normalMap = this.normalMap;
    a.normalScale.copy(this.normalScale);
    a.specularMap = this.specularMap;
    a.envMap = this.envMap;
    a.combine = this.combine;
    a.reflectivity = this.reflectivity;
    a.refractionRatio = this.refractionRatio;
    a.fog = this.fog;
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    a.wireframeLinecap = this.wireframeLinecap;
    a.wireframeLinejoin = this.wireframeLinejoin;
    a.vertexColors = this.vertexColors;
    a.skinning = this.skinning;
    a.morphTargets = this.morphTargets;
    a.morphNormals = this.morphNormals;
    return a
};
THREE.MeshDepthMaterial = function (a) {
    THREE.Material.call(this);
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.setValues(a)
};
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.clone = function () {
    var a = new THREE.MeshDepthMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    return a
};
THREE.MeshNormalMaterial = function (a) {
    THREE.Material.call(this, a);
    this.shading = THREE.FlatShading;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.morphTargets = !1;
    this.setValues(a)
};
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshNormalMaterial.prototype.clone = function () {
    var a = new THREE.MeshNormalMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    return a
};
THREE.MeshFaceMaterial = function (a) {
    this.materials = a instanceof Array ? a : []
};
THREE.MeshFaceMaterial.prototype.clone = function () {
    for (var a = new THREE.MeshFaceMaterial, b = 0; b < this.materials.length; b++) a.materials.push(this.materials[b].clone());
    return a
};
THREE.ParticleBasicMaterial = function (a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.map = null;
    this.size = 1;
    this.sizeAttenuation = !0;
    this.vertexColors = !1;
    this.fog = !0;
    this.setValues(a)
};
THREE.ParticleBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ParticleBasicMaterial.prototype.clone = function () {
    var a = new THREE.ParticleBasicMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.map = this.map;
    a.size = this.size;
    a.sizeAttenuation = this.sizeAttenuation;
    a.vertexColors = this.vertexColors;
    a.fog = this.fog;
    return a
};
THREE.ParticleCanvasMaterial = function (a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.program = function () {};
    this.setValues(a)
};
THREE.ParticleCanvasMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ParticleCanvasMaterial.prototype.clone = function () {
    var a = new THREE.ParticleCanvasMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.program = this.program;
    return a
};
THREE.ShaderMaterial = function (a) {
    THREE.Material.call(this);
    this.vertexShader = this.fragmentShader = "void main() {}";
    this.uniforms = {};
    this.defines = {};
    this.attributes = null;
    this.shading = THREE.SmoothShading;
    this.linewidth = 1;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.lights = this.fog = !1;
    this.vertexColors = THREE.NoColors;
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0]
    };
    this.index0AttributeName = "position";
    this.setValues(a)
};
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.clone = function () {
    var a = new THREE.ShaderMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.fragmentShader = this.fragmentShader;
    a.vertexShader = this.vertexShader;
    a.uniforms = THREE.UniformsUtils.clone(this.uniforms);
    a.attributes = this.attributes;
    a.defines = this.defines;
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    a.fog = this.fog;
    a.lights = this.lights;
    a.vertexColors = this.vertexColors;
    a.skinning = this.skinning;
    a.morphTargets = this.morphTargets;
    a.morphNormals = this.morphNormals;
    return a
};
THREE.SpriteMaterial = function (a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.map = new THREE.Texture;
    this.useScreenCoordinates = !0;
    this.depthTest = !this.useScreenCoordinates;
    this.sizeAttenuation = !this.useScreenCoordinates;
    this.scaleByViewport = !this.sizeAttenuation;
    this.alignment = THREE.SpriteAlignment.center.clone();
    this.fog = !1;
    this.uvOffset = new THREE.Vector2(0, 0);
    this.uvScale = new THREE.Vector2(1, 1);
    this.setValues(a);
    a = a || {};
    void 0 === a.depthTest && (this.depthTest = !this.useScreenCoordinates);
    void 0 === a.sizeAttenuation && (this.sizeAttenuation = !this.useScreenCoordinates);
    void 0 === a.scaleByViewport && (this.scaleByViewport = !this.sizeAttenuation)
};
THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.SpriteMaterial.prototype.clone = function () {
    var a = new THREE.SpriteMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.map = this.map;
    a.useScreenCoordinates = this.useScreenCoordinates;
    a.sizeAttenuation = this.sizeAttenuation;
    a.scaleByViewport = this.scaleByViewport;
    a.alignment.copy(this.alignment);
    a.uvOffset.copy(this.uvOffset);
    a.uvScale.copy(this.uvScale);
    a.fog = this.fog;
    return a
};
THREE.SpriteAlignment = {};
THREE.SpriteAlignment.topLeft = new THREE.Vector2(1, -1);
THREE.SpriteAlignment.topCenter = new THREE.Vector2(0, -1);
THREE.SpriteAlignment.topRight = new THREE.Vector2(-1, -1);
THREE.SpriteAlignment.centerLeft = new THREE.Vector2(1, 0);
THREE.SpriteAlignment.center = new THREE.Vector2(0, 0);
THREE.SpriteAlignment.centerRight = new THREE.Vector2(-1, 0);
THREE.SpriteAlignment.bottomLeft = new THREE.Vector2(1, 1);
THREE.SpriteAlignment.bottomCenter = new THREE.Vector2(0, 1);
THREE.SpriteAlignment.bottomRight = new THREE.Vector2(-1, 1);
THREE.Texture = function (a, b, c, d, e, f, h, g, i) {
    this.id = THREE.TextureIdCount++;
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.image = a;
    this.mipmaps = [];
    this.mapping = void 0 !== b ? b : new THREE.UVMapping;
    this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping;
    this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping;
    this.magFilter = void 0 !== e ? e : THREE.LinearFilter;
    this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter;
    this.anisotropy = void 0 !== i ? i : 1;
    this.format = void 0 !== h ? h : THREE.RGBAFormat;
    this.type = void 0 !== g ? g : THREE.UnsignedByteType;
    this.offset = new THREE.Vector2(0, 0);
    this.repeat = new THREE.Vector2(1, 1);
    this.generateMipmaps = !0;
    this.premultiplyAlpha = !1;
    this.flipY = !0;
    this.unpackAlignment = 4;
    this.needsUpdate = !1;
    this.onUpdate = null
};
THREE.Texture.prototype = {
    constructor: THREE.Texture,
    clone: function (a) {
        void 0 === a && (a = new THREE.Texture);
        a.image = this.image;
        a.mipmaps = this.mipmaps.slice(0);
        a.mapping = this.mapping;
        a.wrapS = this.wrapS;
        a.wrapT = this.wrapT;
        a.magFilter = this.magFilter;
        a.minFilter = this.minFilter;
        a.anisotropy = this.anisotropy;
        a.format = this.format;
        a.type = this.type;
        a.offset.copy(this.offset);
        a.repeat.copy(this.repeat);
        a.generateMipmaps = this.generateMipmaps;
        a.premultiplyAlpha = this.premultiplyAlpha;
        a.flipY = this.flipY;
        a.unpackAlignment = this.unpackAlignment;
        return a
    },
    dispose: function () {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
THREE.TextureIdCount = 0;
THREE.CompressedTexture = function (a, b, c, d, e, f, h, g, i, k, m) {
    THREE.Texture.call(this, null, f, h, g, i, k, d, e, m);
    this.image = {
        width: b,
        height: c
    };
    this.mipmaps = a;
    this.generateMipmaps = !1
};
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.clone = function () {
    var a = new THREE.CompressedTexture;
    THREE.Texture.prototype.clone.call(this, a);
    return a
};
THREE.DataTexture = function (a, b, c, d, e, f, h, g, i, k, m) {
    THREE.Texture.call(this, null, f, h, g, i, k, d, e, m);
    this.image = {
        data: a,
        width: b,
        height: c
    }
};
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DataTexture.prototype.clone = function () {
    var a = new THREE.DataTexture;
    THREE.Texture.prototype.clone.call(this, a);
    return a
};
THREE.Particle = function (a) {
    THREE.Object3D.call(this);
    this.material = a
};
THREE.Particle.prototype = Object.create(THREE.Object3D.prototype);
THREE.Particle.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.Particle(this.material));
    THREE.Object3D.prototype.clone.call(this, a);
    return a
};
THREE.ParticleSystem = function (a, b) {
    THREE.Object3D.call(this);
    this.geometry = void 0 !== a ? a : new THREE.Geometry;
    this.material = void 0 !== b ? b : new THREE.ParticleBasicMaterial({
        color: 16777215 * Math.random()
    });
    this.frustumCulled = this.sortParticles = !1
};
THREE.ParticleSystem.prototype = Object.create(THREE.Object3D.prototype);
THREE.ParticleSystem.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.ParticleSystem(this.geometry, this.material));
    a.sortParticles = this.sortParticles;
    THREE.Object3D.prototype.clone.call(this, a);
    return a
};
THREE.Line = function (a, b, c) {
    THREE.Object3D.call(this);
    this.geometry = void 0 !== a ? a : new THREE.Geometry;
    this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({
        color: 16777215 * Math.random()
    });
    this.type = void 0 !== c ? c : THREE.LineStrip
};
THREE.LineStrip = 0;
THREE.LinePieces = 1;
THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.Line(this.geometry, this.material, this.type));
    THREE.Object3D.prototype.clone.call(this, a);
    return a
};
THREE.Mesh = function (a, b) {
    THREE.Object3D.call(this);
    this.geometry = void 0 !== a ? a : new THREE.Geometry;
    this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({
        color: 16777215 * Math.random()
    });
    this.updateMorphTargets()
};
THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.updateMorphTargets = function () {
    if (0 < this.geometry.morphTargets.length) {
        this.morphTargetBase = -1;
        this.morphTargetForcedOrder = [];
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a
    }
};
THREE.Mesh.prototype.getMorphTargetIndexByName = function (a) {
    if (void 0 !== this.morphTargetDictionary[a]) return this.morphTargetDictionary[a];
    console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + a + " does not exist. Returning 0.");
    return 0
};
THREE.Mesh.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.Mesh(this.geometry, this.material));
    THREE.Object3D.prototype.clone.call(this, a);
    return a
};
THREE.Bone = function (a) {
    THREE.Object3D.call(this);
    this.skin = a;
    this.skinMatrix = new THREE.Matrix4
};
THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
THREE.Bone.prototype.update = function (a, b) {
    this.matrixAutoUpdate && (b |= this.updateMatrix());
    if (b || this.matrixWorldNeedsUpdate) a ? this.skinMatrix.multiplyMatrices(a, this.matrix) : this.skinMatrix.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, b = !0;
    var c, d = this.children.length;
    for (c = 0; c < d; c++) this.children[c].update(this.skinMatrix, b)
};
THREE.SkinnedMesh = function (a, b, c) {
    THREE.Mesh.call(this, a, b);
    this.useVertexTexture = void 0 !== c ? c : !0;
    this.identityMatrix = new THREE.Matrix4;
    this.bones = [];
    this.boneMatrices = [];
    var d, e, f;
    if (this.geometry && void 0 !== this.geometry.bones) {
        for (a = 0; a < this.geometry.bones.length; a++) c = this.geometry.bones[a], d = c.pos, e = c.rotq, f = c.scl, b = this.addBone(), b.name = c.name, b.position.set(d[0], d[1], d[2]), b.quaternion.set(e[0], e[1], e[2], e[3]), void 0 !== f ? b.scale.set(f[0], f[1], f[2]) : b.scale.set(1, 1, 1);
        for (a = 0; a < this.bones.length; a++) c = this.geometry.bones[a], b = this.bones[a], -1 === c.parent ? this.add(b) : this.bones[c.parent].add(b);
        a = this.bones.length;
        this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = a = 256 < a ? 64 : 64 < a ? 32 : 16 < a ? 16 : 8, this.boneMatrices = new Float32Array(4 * this.boneTextureWidth * this.boneTextureHeight), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * a);
        this.pose()
    }
};
THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.SkinnedMesh.prototype.addBone = function (a) {
    void 0 === a && (a = new THREE.Bone(this));
    this.bones.push(a);
    return a
};
THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {
    var a = new THREE.Matrix4;
    return function (b) {
        this.matrixAutoUpdate && this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || b) this.parent ? this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1;
        for (var b = 0, c = this.children.length; b < c; b++) {
            var d = this.children[b];
            d instanceof THREE.Bone ? d.update(this.identityMatrix, !1) : d.updateMatrixWorld(!0)
        }
        if (void 0 == this.boneInverses) {
            this.boneInverses = [];
            b = 0;
            for (c = this.bones.length; b < c; b++) d = new THREE.Matrix4, d.getInverse(this.bones[b].skinMatrix), this.boneInverses.push(d)
        }
        b = 0;
        for (c = this.bones.length; b < c; b++) a.multiplyMatrices(this.bones[b].skinMatrix, this.boneInverses[b]), a.flattenToArrayOffset(this.boneMatrices, 16 * b);
        this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
    }
}();
THREE.SkinnedMesh.prototype.pose = function () {
    this.updateMatrixWorld(!0);
    this.normalizeSkinWeights()
};
THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
    if (this.geometry instanceof THREE.Geometry)
        for (var a = 0; a < this.geometry.skinIndices.length; a++) {
            var b = this.geometry.skinWeights[a],
                c = 1 / b.lengthManhattan();
            Infinity !== c ? b.multiplyScalar(c) : b.set(1)
        }
};
THREE.SkinnedMesh.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture));
    THREE.Mesh.prototype.clone.call(this, a);
    return a
};
THREE.MorphAnimMesh = function (a, b) {
    THREE.Mesh.call(this, a, b);
    this.duration = 1e3;
    this.mirroredLoop = !1;
    this.currentKeyframe = this.lastKeyframe = this.time = 0;
    this.direction = 1;
    this.directionBackwards = !1;
    this.setFrameRange(0, this.geometry.morphTargets.length - 1)
};
THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphAnimMesh.prototype.setFrameRange = function (a, b) {
    this.startKeyframe = a;
    this.endKeyframe = b;
    this.length = this.endKeyframe - this.startKeyframe + 1
};
THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
    this.direction = 1;
    this.directionBackwards = !1
};
THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
    this.direction = -1;
    this.directionBackwards = !0
};
THREE.MorphAnimMesh.prototype.parseAnimations = function () {
    var a = this.geometry;
    a.animations || (a.animations = {});
    for (var b, c = a.animations, d = /([a-z]+)(\d+)/, e = 0, f = a.morphTargets.length; e < f; e++) {
        var h = a.morphTargets[e].name.match(d);
        if (h && 1 < h.length) {
            h = h[1];
            c[h] || (c[h] = {
                start: Infinity,
                end: -Infinity
            });
            var g = c[h];
            e < g.start && (g.start = e);
            e > g.end && (g.end = e);
            b || (b = h)
        }
    }
    a.firstAnimation = b
};
THREE.MorphAnimMesh.prototype.setAnimationLabel = function (a, b, c) {
    this.geometry.animations || (this.geometry.animations = {});
    this.geometry.animations[a] = {
        start: b,
        end: c
    }
};
THREE.MorphAnimMesh.prototype.playAnimation = function (a, b) {
    var c = this.geometry.animations[a];
    c ? (this.setFrameRange(c.start, c.end), this.duration = 1e3 * ((c.end - c.start) / b), this.time = 0) : console.warn("animation[" + a + "] undefined")
};
THREE.MorphAnimMesh.prototype.updateAnimation = function (a) {
    var b = this.duration / this.length;
    this.time += this.direction * a;
    if (this.mirroredLoop) {
        if (this.time > this.duration || 0 > this.time) this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 0 > this.time && (this.time = 0, this.directionBackwards = !1)
    } else this.time %= this.duration, 0 > this.time && (this.time += this.duration);
    a = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / b), 0, this.length - 1);
    a !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[a] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = a);
    b = this.time % b / b;
    this.directionBackwards && (b = 1 - b);
    this.morphTargetInfluences[this.currentKeyframe] = b;
    this.morphTargetInfluences[this.lastKeyframe] = 1 - b
};
THREE.MorphAnimMesh.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.MorphAnimMesh(this.geometry, this.material));
    a.duration = this.duration;
    a.mirroredLoop = this.mirroredLoop;
    a.time = this.time;
    a.lastKeyframe = this.lastKeyframe;
    a.currentKeyframe = this.currentKeyframe;
    a.direction = this.direction;
    a.directionBackwards = this.directionBackwards;
    THREE.Mesh.prototype.clone.call(this, a);
    return a
};
THREE.LOD = function () {
    THREE.Object3D.call(this);
    this.objects = []
};
THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
THREE.LOD.prototype.addLevel = function (a, b) {
    void 0 === b && (b = 0);
    for (var b = Math.abs(b), c = 0; c < this.objects.length && !(b < this.objects[c].distance); c++);
    this.objects.splice(c, 0, {
        distance: b,
        object: a
    });
    this.add(a)
};
THREE.LOD.prototype.getObjectForDistance = function (a) {
    for (var b = 1, c = this.objects.length; b < c && !(a < this.objects[b].distance); b++);
    return this.objects[b - 1].object
};
THREE.LOD.prototype.update = function () {
    var a = new THREE.Vector3,
        b = new THREE.Vector3;
    return function (c) {
        if (1 < this.objects.length) {
            a.getPositionFromMatrix(c.matrixWorld);
            b.getPositionFromMatrix(this.matrixWorld);
            c = a.distanceTo(b);
            this.objects[0].object.visible = !0;
            for (var d = 1, e = this.objects.length; d < e; d++)
                if (c >= this.objects[d].distance) this.objects[d - 1].object.visible = !1, this.objects[d].object.visible = !0;
                else break;
            for (; d < e; d++) this.objects[d].object.visible = !1
        }
    }
}();
THREE.LOD.prototype.clone = function () {};
THREE.Sprite = function (a) {
    THREE.Object3D.call(this);
    this.material = void 0 !== a ? a : new THREE.SpriteMaterial;
    this.rotation3d = this.rotation;
    this.rotation = 0
};
THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
THREE.Sprite.prototype.updateMatrix = function () {
    this.rotation3d.set(0, 0, this.rotation, this.rotation3d.order);
    this.quaternion.setFromEuler(this.rotation3d);
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = !0
};
THREE.Sprite.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.Sprite(this.material));
    THREE.Object3D.prototype.clone.call(this, a);
    return a
};
THREE.Scene = function () {
    THREE.Object3D.call(this);
    this.overrideMaterial = this.fog = null;
    this.autoUpdate = !0;
    this.matrixAutoUpdate = !1;
    this.__lights = [];
    this.__objectsAdded = [];
    this.__objectsRemoved = []
};
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.__addObject = function (a) {
    if (a instanceof THREE.Light) - 1 === this.__lights.indexOf(a) && this.__lights.push(a), a.target && void 0 === a.target.parent && this.add(a.target);
    else if (!(a instanceof THREE.Camera || a instanceof THREE.Bone)) {
        this.__objectsAdded.push(a);
        var b = this.__objectsRemoved.indexOf(a); - 1 !== b && this.__objectsRemoved.splice(b, 1)
    }
    for (b = 0; b < a.children.length; b++) this.__addObject(a.children[b])
};
THREE.Scene.prototype.__removeObject = function (a) {
    if (a instanceof THREE.Light) {
        var b = this.__lights.indexOf(a); - 1 !== b && this.__lights.splice(b, 1);
        if (a.shadowCascadeArray)
            for (b = 0; b < a.shadowCascadeArray.length; b++) this.__removeObject(a.shadowCascadeArray[b])
    } else a instanceof THREE.Camera || (this.__objectsRemoved.push(a), b = this.__objectsAdded.indexOf(a), -1 !== b && this.__objectsAdded.splice(b, 1));
    for (b = 0; b < a.children.length; b++) this.__removeObject(a.children[b])
};
THREE.Scene.prototype.clone = function (a) {
    void 0 === a && (a = new THREE.Scene);
    THREE.Object3D.prototype.clone.call(this, a);
    null !== this.fog && (a.fog = this.fog.clone());
    null !== this.overrideMaterial && (a.overrideMaterial = this.overrideMaterial.clone());
    a.autoUpdate = this.autoUpdate;
    a.matrixAutoUpdate = this.matrixAutoUpdate;
    return a
};
THREE.Fog = function (a, b, c) {
    this.name = "";
    this.color = new THREE.Color(a);
    this.near = void 0 !== b ? b : 1;
    this.far = void 0 !== c ? c : 1e3
};
THREE.Fog.prototype.clone = function () {
    return new THREE.Fog(this.color.getHex(), this.near, this.far)
};
THREE.FogExp2 = function (a, b) {
    this.name = "";
    this.color = new THREE.Color(a);
    this.density = void 0 !== b ? b : 25e-5
};
THREE.FogExp2.prototype.clone = function () {
    return new THREE.FogExp2(this.color.getHex(), this.density)
};
THREE.CanvasRenderer = function (a) {
    function b(a, b, c) {
        for (var d = 0, e = E.length; d < e; d++) {
            var f = E[d];
            La.copy(f.color);
            if (f instanceof THREE.DirectionalLight) {
                var h = ua.getPositionFromMatrix(f.matrixWorld).normalize(),
                    g = b.dot(h);
                0 >= g || (g *= f.intensity, c.add(La.multiplyScalar(g)))
            } else f instanceof THREE.PointLight && (h = ua.getPositionFromMatrix(f.matrixWorld), g = b.dot(ua.subVectors(h, a).normalize()), 0 >= g || (g *= 0 == f.distance ? 1 : 1 - Math.min(a.distanceTo(h) / f.distance, 1), 0 != g && (g *= f.intensity, c.add(La.multiplyScalar(g)))))
        }
    }

    function c(a, b, c, d) {
        m(b);
        l(c);
        p(d);
        r(a.getStyle());
        B.stroke();
        ra.expandByScalar(2 * b)
    }

    function d(a) {
        t(a.getStyle());
        B.fill()
    }

    function e(a, b, c, e, f, h, g, j, i, k, m, l, p) {
        if (!(p instanceof THREE.DataTexture || void 0 === p.image || 0 == p.image.width)) {
            if (!0 === p.needsUpdate) {
                var n = p.wrapS == THREE.RepeatWrapping,
                    s = p.wrapT == THREE.RepeatWrapping;
                Ga[p.id] = B.createPattern(p.image, !0 === n && !0 === s ? "repeat" : !0 === n && !1 === s ? "repeat-x" : !1 === n && !0 === s ? "repeat-y" : "no-repeat");
                p.needsUpdate = !1
            }
            void 0 === Ga[p.id] ? t("rgba(0,0,0,1)") : t(Ga[p.id]);
            var n = p.offset.x / p.repeat.x,
                s = p.offset.y / p.repeat.y,
                r = p.image.width * p.repeat.x,
                q = p.image.height * p.repeat.y,
                g = (g + n) * r,
                j = (1 - j + s) * q,
                c = c - a,
                e = e - b,
                f = f - a,
                h = h - b,
                i = (i + n) * r - g,
                k = (1 - k + s) * q - j,
                m = (m + n) * r - g,
                l = (1 - l + s) * q - j,
                n = i * l - m * k;
            0 === n ? (void 0 === fa[p.id] && (b = document.createElement("canvas"), b.width = p.image.width, b.height = p.image.height, b = b.getContext("2d"), b.drawImage(p.image, 0, 0), fa[p.id] = b.getImageData(0, 0, p.image.width, p.image.height).data), b = fa[p.id], g = 4 * (Math.floor(g) + Math.floor(j) * p.image.width), V.setRGB(b[g] / 255, b[g + 1] / 255, b[g + 2] / 255), d(V)) : (n = 1 / n, p = (l * c - k * f) * n, k = (l * e - k * h) * n, c = (i * f - m * c) * n, e = (i * h - m * e) * n, a = a - p * g - c * j, g = b - k * g - e * j, B.save(), B.transform(p, k, c, e, a, g), B.fill(), B.restore())
        }
    }

    function f(a, b, c, d, e, f, h, g, j, i, k, m, l) {
        var p, n;
        p = l.width - 1;
        n = l.height - 1;
        h *= p;
        g *= n;
        c -= a;
        d -= b;
        e -= a;
        f -= b;
        j = j * p - h;
        i = i * n - g;
        k = k * p - h;
        m = m * n - g;
        n = 1 / (j * m - k * i);
        p = (m * c - i * e) * n;
        i = (m * d - i * f) * n;
        c = (j * e - k * c) * n;
        d = (j * f - k * d) * n;
        a = a - p * h - c * g;
        b = b - i * h - d * g;
        B.save();
        B.transform(p, i, c, d, a, b);
        B.clip();
        B.drawImage(l, 0, 0);
        B.restore()
    }

    function h(a, b, c, d) {
        va[0] = 255 * a.r | 0;
        va[1] = 255 * a.g | 0;
        va[2] = 255 * a.b | 0;
        va[4] = 255 * b.r | 0;
        va[5] = 255 * b.g | 0;
        va[6] = 255 * b.b | 0;
        va[8] = 255 * c.r | 0;
        va[9] = 255 * c.g | 0;
        va[10] = 255 * c.b | 0;
        va[12] = 255 * d.r | 0;
        va[13] = 255 * d.g | 0;
        va[14] = 255 * d.b | 0;
        j.putImageData(Na, 0, 0);
        Fa.drawImage(Oa, 0, 0);
        return wa
    }

    function g(a, b, c) {
        var d = b.x - a.x,
            e = b.y - a.y,
            f = d * d + e * e;
        0 !== f && (c /= Math.sqrt(f), d *= c, e *= c, b.x += d, b.y += e, a.x -= d, a.y -= e)
    }

    function i(a) {
        v !== a && (v = B.globalAlpha = a)
    }

    function k(a) {
        x !== a && (a === THREE.NormalBlending ? B.globalCompositeOperation = "source-over" : a === THREE.AdditiveBlending ? B.globalCompositeOperation = "lighter" : a === THREE.SubtractiveBlending && (B.globalCompositeOperation = "darker"), x = a)
    }

    function m(a) {
        J !== a && (J = B.lineWidth = a)
    }

    function l(a) {
        ca !== a && (ca = B.lineCap = a)
    }

    function p(a) {
        oa !== a && (oa = B.lineJoin = a)
    }

    function r(a) {
        G !== a && (G = B.strokeStyle = a)
    }

    function t(a) {
        Q !== a && (Q = B.fillStyle = a)
    }

    function n(a, b) {
        if (pa !== a || N !== b) B.setLineDash([a, b]), pa = a, N = b
    }
    console.log("THREE.CanvasRenderer", THREE.REVISION);
    var s = THREE.Math.smoothstep,
        a = a || {},
        q = this,
        u, w, E, C = new THREE.Projector,
        F = void 0 !== a.canvas ? a.canvas : document.createElement("canvas"),
        y, A, z, O, B = F.getContext("2d"),
        D = new THREE.Color(0),
        I = 0,
        v = 1,
        x = 0,
        G = null,
        Q = null,
        J = null,
        ca = null,
        oa = null,
        pa = null,
        N = 0,
        M, R, K, da;
    new THREE.RenderableVertex;
    new THREE.RenderableVertex;
    var Aa, Ca, ba, Ba, $, ea, V = new THREE.Color,
        P = new THREE.Color,
        Y = new THREE.Color,
        U = new THREE.Color,
        ka = new THREE.Color,
        ta = new THREE.Color,
        ia = new THREE.Color,
        La = new THREE.Color,
        Ga = {},
        fa = {},
        Ea, Ta, Pa, xa, cb, db, ob, pb, qb, eb, Ha = new THREE.Box2,
        la = new THREE.Box2,
        ra = new THREE.Box2,
        fb = new THREE.Color,
        sa = new THREE.Color,
        ga = new THREE.Color,
        ua = new THREE.Vector3,
        Oa, j, Na, va, wa, Fa, Qa = 16;
    Oa = document.createElement("canvas");
    Oa.width = Oa.height = 2;
    j = Oa.getContext("2d");
    j.fillStyle = "rgba(0,0,0,1)";
    j.fillRect(0, 0, 2, 2);
    Na = j.getImageData(0, 0, 2, 2);
    va = Na.data;
    wa = document.createElement("canvas");
    wa.width = wa.height = Qa;
    Fa = wa.getContext("2d");
    Fa.translate(-Qa / 2, -Qa / 2);
    Fa.scale(Qa, Qa);
    Qa--;
    void 0 === B.setLineDash && (B.setLineDash = void 0 !== B.mozDash ? function (a) {
        B.mozDash = null !== a[0] ? a : null
    } : function () {});
    this.domElement = F;
    this.devicePixelRatio = void 0 !== a.devicePixelRatio ? a.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1;
    this.sortElements = this.sortObjects = this.autoClear = !0;
    this.info = {
        render: {
            vertices: 0,
            faces: 0
        }
    };
    this.supportsVertexTextures = function () {};
    this.setFaceCulling = function () {};
    this.setSize = function (a, b, c) {
        y = a * this.devicePixelRatio;
        A = b * this.devicePixelRatio;
        z = Math.floor(y / 2);
        O = Math.floor(A / 2);
        F.width = y;
        F.height = A;
        1 !== this.devicePixelRatio && !1 !== c && (F.style.width = a + "px", F.style.height = b + "px");
        Ha.set(new THREE.Vector2(-z, -O), new THREE.Vector2(z, O));
        la.set(new THREE.Vector2(-z, -O), new THREE.Vector2(z, O));
        v = 1;
        x = 0;
        oa = ca = J = Q = G = null
    };
    this.setClearColor = function (a, b) {
        D.set(a);
        I = void 0 !== b ? b : 1;
        la.set(new THREE.Vector2(-z, -O), new THREE.Vector2(z, O))
    };
    this.setClearColorHex = function (a, b) {
        console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.");
        this.setClearColor(a, b)
    };
    this.getMaxAnisotropy = function () {
        return 0
    };
    this.clear = function () {
        B.setTransform(1, 0, 0, -1, z, O);
        !1 === la.empty() && (la.intersect(Ha), la.expandByScalar(2), 1 > I && B.clearRect(la.min.x | 0, la.min.y | 0, la.max.x - la.min.x | 0, la.max.y - la.min.y | 0), 0 < I && (k(THREE.NormalBlending), i(1), t("rgba(" + Math.floor(255 * D.r) + "," + Math.floor(255 * D.g) + "," + Math.floor(255 * D.b) + "," + I + ")"), B.fillRect(la.min.x | 0, la.min.y | 0, la.max.x - la.min.x | 0, la.max.y - la.min.y | 0)), la.makeEmpty())
    };
    this.render = function (a, j) {
        if (!1 === j instanceof THREE.Camera) console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.");
        else {
            !0 === this.autoClear && this.clear();
            B.setTransform(1, 0, 0, -1, z, O);
            q.info.render.vertices = 0;
            q.info.render.faces = 0;
            u = C.projectScene(a, j, this.sortObjects, this.sortElements);
            w = u.elements;
            E = u.lights;
            M = j;
            fb.setRGB(0, 0, 0);
            sa.setRGB(0, 0, 0);
            ga.setRGB(0, 0, 0);
            for (var A = 0, G = E.length; A < G; A++) {
                var y = E[A],
                    F = y.color;
                y instanceof THREE.AmbientLight ? fb.add(F) : y instanceof THREE.DirectionalLight ? sa.add(F) : y instanceof THREE.PointLight && ga.add(F)
            }
            A = 0;
            for (G = w.length; A < G; A++) {
                var v = w[A],
                    x = v.material;
                if (!(void 0 === x || !1 === x.visible)) {
                    ra.makeEmpty();
                    if (v instanceof THREE.RenderableParticle) {
                        R = v;
                        R.x *= z;
                        R.y *= O;
                        var y = R,
                            F = v,
                            J = x;
                        i(J.opacity);
                        k(J.blending);
                        var N = x = v = void 0,
                            D = void 0,
                            I = void 0,
                            Q = void 0,
                            ca = void 0;
                        J instanceof THREE.ParticleBasicMaterial ? null === J.map ? (N = F.object.scale.x, D = F.object.scale.y, N *= F.scale.x * z, D *= F.scale.y * O, ra.min.set(y.x - N, y.y - D), ra.max.set(y.x + N, y.y + D), !1 === Ha.isIntersectionBox(ra) ? ra.makeEmpty() : (t(J.color.getStyle()), B.save(), B.translate(y.x, y.y), B.rotate(-F.rotation), B.scale(N, D), B.fillRect(-1, -1, 2, 2), B.restore())) : (I = J.map.image, Q = I.width >> 1, ca = I.height >> 1, N = F.scale.x * z, D = F.scale.y * O, v = N * Q, x = D * ca, ra.min.set(y.x - v, y.y - x), ra.max.set(y.x + v, y.y + x), !1 === Ha.isIntersectionBox(ra) ? ra.makeEmpty() : (B.save(), B.translate(y.x, y.y), B.rotate(-F.rotation), B.scale(N, -D), B.translate(-Q, -ca), B.drawImage(I, 0, 0), B.restore())) : J instanceof THREE.ParticleCanvasMaterial && (v = F.scale.x * z, x = F.scale.y * O, ra.min.set(y.x - v, y.y - x), ra.max.set(y.x + v, y.y + x), !1 === Ha.isIntersectionBox(ra) ? ra.makeEmpty() : (r(J.color.getStyle()), t(J.color.getStyle()), B.save(), B.translate(y.x, y.y), B.rotate(-F.rotation), B.scale(v, x), J.program(B), B.restore()))
                    } else if (v instanceof THREE.RenderableLine) {
                        if (R = v.v1, K = v.v2, R.positionScreen.x *= z, R.positionScreen.y *= O, K.positionScreen.x *= z, K.positionScreen.y *= O, ra.setFromPoints([R.positionScreen, K.positionScreen]), !0 === Ha.isIntersectionBox(ra))
                            if (y = R, F = K, J = v, v = x, i(v.opacity), k(v.blending), B.beginPath(), B.moveTo(y.positionScreen.x, y.positionScreen.y), B.lineTo(F.positionScreen.x, F.positionScreen.y), v instanceof THREE.LineBasicMaterial) {
                                m(v.linewidth);
                                l(v.linecap);
                                p(v.linejoin);
                                if (v.vertexColors !== THREE.VertexColors) r(v.color.getStyle());
                                else if (x = J.vertexColors[0].getStyle(), J = J.vertexColors[1].getStyle(), x === J) r(x);
                                else {
                                    try {
                                        var fa = B.createLinearGradient(y.positionScreen.x, y.positionScreen.y, F.positionScreen.x, F.positionScreen.y);
                                        fa.addColorStop(0, x);
                                        fa.addColorStop(1, J)
                                    } catch (oa) {
                                        fa = x
                                    }
                                    r(fa)
                                }
                                B.stroke();
                                ra.expandByScalar(2 * v.linewidth)
                            } else v instanceof THREE.LineDashedMaterial && (m(v.linewidth), l(v.linecap), p(v.linejoin), r(v.color.getStyle()), n(v.dashSize, v.gapSize), B.stroke(), ra.expandByScalar(2 * v.linewidth), n(null, null))
                    } else if (v instanceof THREE.RenderableFace3) {
                        R = v.v1;
                        K = v.v2;
                        da = v.v3;
                        if (-1 > R.positionScreen.z || 1 < R.positionScreen.z) continue;
                        if (-1 > K.positionScreen.z || 1 < K.positionScreen.z) continue;
                        if (-1 > da.positionScreen.z || 1 < da.positionScreen.z) continue;
                        R.positionScreen.x *= z;
                        R.positionScreen.y *= O;
                        K.positionScreen.x *= z;
                        K.positionScreen.y *= O;
                        da.positionScreen.x *= z;
                        da.positionScreen.y *= O;
                        0 < x.overdraw && (g(R.positionScreen, K.positionScreen, x.overdraw), g(K.positionScreen, da.positionScreen, x.overdraw), g(da.positionScreen, R.positionScreen, x.overdraw));
                        ra.setFromPoints([R.positionScreen, K.positionScreen, da.positionScreen]);
                        if (!0 === Ha.isIntersectionBox(ra)) {
                            y = R;
                            F = K;
                            J = da;
                            q.info.render.vertices += 3;
                            q.info.render.faces++;
                            i(x.opacity);
                            k(x.blending);
                            Aa = y.positionScreen.x;
                            Ca = y.positionScreen.y;
                            ba = F.positionScreen.x;
                            Ba = F.positionScreen.y;
                            $ = J.positionScreen.x;
                            ea = J.positionScreen.y;
                            var N = Aa,
                                D = Ca,
                                I = ba,
                                Q = Ba,
                                ca = $,
                                pa = ea;
                            B.beginPath();
                            B.moveTo(N, D);
                            B.lineTo(I, Q);
                            B.lineTo(ca, pa);
                            B.closePath();
                            (x instanceof THREE.MeshLambertMaterial || x instanceof THREE.MeshPhongMaterial) && null === x.map ? (ta.copy(x.color), ia.copy(x.emissive), x.vertexColors === THREE.FaceColors && ta.multiply(v.color), !1 === x.wireframe && x.shading == THREE.SmoothShading && 3 == v.vertexNormalsLength ? (P.copy(fb), Y.copy(fb), U.copy(fb), b(v.v1.positionWorld, v.vertexNormalsModel[0], P), b(v.v2.positionWorld, v.vertexNormalsModel[1], Y), b(v.v3.positionWorld, v.vertexNormalsModel[2], U), P.multiply(ta).add(ia), Y.multiply(ta).add(ia), U.multiply(ta).add(ia), ka.addColors(Y, U).multiplyScalar(.5), Pa = h(P, Y, U, ka), f(Aa, Ca, ba, Ba, $, ea, 0, 0, 1, 0, 0, 1, Pa)) : (V.copy(fb), b(v.centroidModel, v.normalModel, V), V.multiply(ta).add(ia), !0 === x.wireframe ? c(V, x.wireframeLinewidth, x.wireframeLinecap, x.wireframeLinejoin) : d(V))) : x instanceof THREE.MeshBasicMaterial || x instanceof THREE.MeshLambertMaterial || x instanceof THREE.MeshPhongMaterial ? null !== x.map ? x.map.mapping instanceof THREE.UVMapping && (xa = v.uvs[0], e(Aa, Ca, ba, Ba, $, ea, xa[0].x, xa[0].y, xa[1].x, xa[1].y, xa[2].x, xa[2].y, x.map)) : null !== x.envMap ? x.envMap.mapping instanceof THREE.SphericalReflectionMapping && (ua.copy(v.vertexNormalsModelView[0]), cb = .5 * ua.x + .5, db = .5 * ua.y + .5, ua.copy(v.vertexNormalsModelView[1]), ob = .5 * ua.x + .5, pb = .5 * ua.y + .5, ua.copy(v.vertexNormalsModelView[2]), qb = .5 * ua.x + .5, eb = .5 * ua.y + .5, e(Aa, Ca, ba, Ba, $, ea, cb, db, ob, pb, qb, eb, x.envMap)) : (V.copy(x.color), x.vertexColors === THREE.FaceColors && V.multiply(v.color), !0 === x.wireframe ? c(V, x.wireframeLinewidth, x.wireframeLinecap, x.wireframeLinejoin) : d(V)) : x instanceof THREE.MeshDepthMaterial ? (Ea = M.near, Ta = M.far, P.r = P.g = P.b = 1 - s(y.positionScreen.z * y.positionScreen.w, Ea, Ta), Y.r = Y.g = Y.b = 1 - s(F.positionScreen.z * F.positionScreen.w, Ea, Ta), U.r = U.g = U.b = 1 - s(J.positionScreen.z * J.positionScreen.w, Ea, Ta), ka.addColors(Y, U).multiplyScalar(.5), Pa = h(P, Y, U, ka), f(Aa, Ca, ba, Ba, $, ea, 0, 0, 1, 0, 0, 1, Pa)) : x instanceof THREE.MeshNormalMaterial && (y = void 0, x.shading == THREE.FlatShading ? (y = v.normalModelView, V.setRGB(y.x, y.y, y.z).multiplyScalar(.5).addScalar(.5), !0 === x.wireframe ? c(V, x.wireframeLinewidth, x.wireframeLinecap, x.wireframeLinejoin) : d(V)) : x.shading == THREE.SmoothShading && (y = v.vertexNormalsModelView[0], P.setRGB(y.x, y.y, y.z).multiplyScalar(.5).addScalar(.5), y = v.vertexNormalsModelView[1], Y.setRGB(y.x, y.y, y.z).multiplyScalar(.5).addScalar(.5), y = v.vertexNormalsModelView[2], U.setRGB(y.x, y.y, y.z).multiplyScalar(.5).addScalar(.5), ka.addColors(Y, U).multiplyScalar(.5), Pa = h(P, Y, U, ka), f(Aa, Ca, ba, Ba, $, ea, 0, 0, 1, 0, 0, 1, Pa)))
                        }
                    }
                    la.union(ra)
                }
            }
            B.setTransform(1, 0, 0, 1, 0, 0)
        }
    }
};
THREE.ShaderChunk = {
    fog_pars_fragment: "#ifdef USE_FOG\nuniform vec3 fogColor;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif",
    fog_fragment: "#ifdef USE_FOG\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n#ifdef FOG_EXP2\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n#else\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n#endif\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif",
    envmap_pars_fragment: "#ifdef USE_ENVMAP\nuniform float reflectivity;\nuniform samplerCube envMap;\nuniform float flipEnvMap;\nuniform int combine;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nuniform bool useRefract;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif",
    envmap_fragment: "#ifdef USE_ENVMAP\nvec3 reflectVec;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\n} else { \nreflectVec = reflect( cameraToVertex, normal );\n}\n#else\nreflectVec = vReflect;\n#endif\n#ifdef DOUBLE_SIDED\nfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\nvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#else\nvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#endif\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\nif ( combine == 1 ) {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n} else if ( combine == 2 ) {\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n} else {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n}\n#endif",
    envmap_pars_vertex: "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvarying vec3 vReflect;\nuniform float refractionRatio;\nuniform bool useRefract;\n#endif",
    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n#ifdef USE_SKINNING\nvec4 worldPosition = modelMatrix * skinned;\n#endif\n#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n#endif\n#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n#endif\n#endif",
    envmap_vertex: "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\nworldNormal = normalize( worldNormal );\nvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, worldNormal );\n}\n#endif",
    map_particle_pars_fragment: "#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
    map_particle_fragment: "#ifdef USE_MAP\ngl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n#endif",
    map_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\nuniform vec4 offsetRepeat;\n#endif",
    map_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
    map_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
    map_fragment: "#ifdef USE_MAP\nvec4 texelColor = texture2D( map, vUv );\n#ifdef GAMMA_INPUT\ntexelColor.xyz *= texelColor.xyz;\n#endif\ngl_FragColor = gl_FragColor * texelColor;\n#endif",
    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\nuniform sampler2D lightMap;\n#endif",
    lightmap_pars_vertex: "#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\n#endif",
    lightmap_fragment: "#ifdef USE_LIGHTMAP\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n#endif",
    lightmap_vertex: "#ifdef USE_LIGHTMAP\nvUv2 = uv2;\n#endif",
    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx( vUv );\nvec2 dSTdy = dFdy( vUv );\nfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\nfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\nfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\nreturn vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\nvec3 vSigmaX = dFdx( surf_pos );\nvec3 vSigmaY = dFdy( surf_pos );\nvec3 vN = surf_norm;\nvec3 R1 = cross( vSigmaY, vN );\nvec3 R2 = cross( vN, vSigmaX );\nfloat fDet = dot( vSigmaX, R1 );\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif",
    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\nvec3 q0 = dFdx( eye_pos.xyz );\nvec3 q1 = dFdy( eye_pos.xyz );\nvec2 st0 = dFdx( vUv.st );\nvec2 st1 = dFdy( vUv.st );\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\nvec3 N = normalize( surf_norm );\nvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\nmapN.xy = normalScale * mapN.xy;\nmat3 tsn = mat3( S, T, N );\nreturn normalize( tsn * mapN );\n}\n#endif",
    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif",
    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D( specularMap, vUv );\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif",
    lights_lambert_pars_vertex: "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif",
    lights_lambert_vertex: "vLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\nvLightBack = vec3( 0.0 );\n#endif\ntransformedNormal = normalize( transformedNormal );\n#if MAX_DIR_LIGHTS > 0\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, dirVector );\nvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\ndirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\ndirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n#ifdef DOUBLE_SIDED\nvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n#endif\n}\n#endif\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\npointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\npointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n#ifdef DOUBLE_SIDED\nvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\nspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\nspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n#ifdef DOUBLE_SIDED\nvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\nvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n#ifdef DOUBLE_SIDED\nvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n#endif\n}\n#endif\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n#ifdef DOUBLE_SIDED\nvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n#endif",
    lights_phong_pars_vertex: "#ifndef PHONG_PER_PIXEL\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\nvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\nvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif",
    lights_phong_vertex: "#ifndef PHONG_PER_PIXEL\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nvPointLight[ i ] = vec4( lVector, lDistance );\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nvSpotLight[ i ] = vec4( lVector, lDistance );\n}\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvWorldPosition = worldPosition.xyz;\n#endif",
    lights_phong_pars_fragment: "uniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n#ifdef PHONG_PER_PIXEL\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#else\nvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#ifdef PHONG_PER_PIXEL\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#else\nvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;",
    lights_phong_fragment: "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#ifdef DOUBLE_SIDED\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#ifdef USE_NORMALMAP\nnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse  = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n#ifdef PHONG_PER_PIXEL\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\n#else\nvec3 lVector = normalize( vPointLight[ i ].xyz );\nfloat lDistance = vPointLight[ i ].w;\n#endif\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n#endif\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\nvec3 pointHalfVector = normalize( lVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n#else\npointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse  = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n#ifdef PHONG_PER_PIXEL\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\n#else\nvec3 lVector = normalize( vSpotLight[ i ].xyz );\nfloat lDistance = vSpotLight[ i ].w;\n#endif\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n#endif\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\nvec3 spotHalfVector = normalize( lVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n#else\nspotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse  = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, dirVector );\n#ifdef WRAP_AROUND\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n#endif\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n#else\ndirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;\n#endif\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n#else\nhemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\n#endif\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif",
    color_pars_fragment: "#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",
    color_fragment: "#ifdef USE_COLOR\ngl_FragColor = gl_FragColor * vec4( vColor, opacity );\n#endif",
    color_pars_vertex: "#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",
    color_vertex: "#ifdef USE_COLOR\n#ifdef GAMMA_INPUT\nvColor = color * color;\n#else\nvColor = color;\n#endif\n#endif",
    skinning_pars_vertex: "#ifdef USE_SKINNING\n#ifdef BONE_TEXTURE\nuniform sampler2D boneTexture;\nuniform int boneTextureWidth;\nuniform int boneTextureHeight;\nmat4 getBoneMatrix( const in float i ) {\nfloat j = i * 4.0;\nfloat x = mod( j, float( boneTextureWidth ) );\nfloat y = floor( j / float( boneTextureWidth ) );\nfloat dx = 1.0 / float( boneTextureWidth );\nfloat dy = 1.0 / float( boneTextureHeight );\ny = dy * ( y + 0.5 );\nvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\nvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\nvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\nvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\nmat4 bone = mat4( v1, v2, v3, v4 );\nreturn bone;\n}\n#else\nuniform mat4 boneGlobalMatrices[ MAX_BONES ];\nmat4 getBoneMatrix( const in float i ) {\nmat4 bone = boneGlobalMatrices[ int(i) ];\nreturn bone;\n}\n#endif\n#endif",
    skinbase_vertex: "#ifdef USE_SKINNING\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\n#endif",
    skinning_vertex: "#ifdef USE_SKINNING\n#ifdef USE_MORPHTARGETS\nvec4 skinVertex = vec4( morphed, 1.0 );\n#else\nvec4 skinVertex = vec4( position, 1.0 );\n#endif\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned      += boneMatY * skinVertex * skinWeight.y;\n#endif",
    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[ 8 ];\n#else\nuniform float morphTargetInfluences[ 4 ];\n#endif\n#endif",
    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\nvec3 morphed = vec3( 0.0 );\nmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\nmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\nmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\nmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n#ifndef USE_MORPHNORMALS\nmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\nmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\nmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\nmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n#endif\nmorphed += position;\n#endif",
    default_vertex: "vec4 mvPosition;\n#ifdef USE_SKINNING\nmvPosition = modelViewMatrix * skinned;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;",
    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\nvec3 morphedNormal = vec3( 0.0 );\nmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\nmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\nmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\nmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\nmorphedNormal += normal;\n#endif",
    skinnormal_vertex: "#ifdef USE_SKINNING\nmat4 skinMatrix = skinWeight.x * boneMatX;\nskinMatrix     += skinWeight.y * boneMatY;\n#ifdef USE_MORPHNORMALS\nvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n#else\nvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n#endif\n#endif",
    defaultnormal_vertex: "vec3 objectNormal;\n#ifdef USE_SKINNING\nobjectNormal = skinnedNormal.xyz;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\nobjectNormal = morphedNormal;\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\nobjectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;",
    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\nuniform float shadowDarkness[ MAX_SHADOWS ];\nuniform float shadowBias[ MAX_SHADOWS ];\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\n#endif",
    shadowmap_fragment: "#ifdef USE_SHADOWMAP\n#ifdef SHADOWMAP_DEBUG\nvec3 frustumColors[3];\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n#endif\n#ifdef SHADOWMAP_CASCADE\nint inFrustumCount = 0;\n#endif\nfloat fDepth;\nvec3 shadowColor = vec3( 1.0 );\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\nbool inFrustum = all( inFrustumVec );\n#ifdef SHADOWMAP_CASCADE\ninFrustumCount += int( inFrustum );\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n#else\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n#endif\nbool frustumTest = all( frustumTestVec );\nif ( frustumTest ) {\nshadowCoord.z += shadowBias[ i ];\n#if defined( SHADOWMAP_TYPE_PCF )\nfloat shadow = 0.0;\nconst float shadowDelta = 1.0 / 9.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.25 * xPixelOffset;\nfloat dy0 = -1.25 * yPixelOffset;\nfloat dx1 = 1.25 * xPixelOffset;\nfloat dy1 = 1.25 * yPixelOffset;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\nfloat shadow = 0.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.0 * xPixelOffset;\nfloat dy0 = -1.0 * yPixelOffset;\nfloat dx1 = 1.0 * xPixelOffset;\nfloat dy1 = 1.0 * yPixelOffset;\nmat3 shadowKernel;\nmat3 depthKernel;\ndepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\ndepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\ndepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\ndepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\ndepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\ndepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\ndepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\ndepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\ndepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nvec3 shadowZ = vec3( shadowCoord.z );\nshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\nshadowKernel[0] *= vec3(0.25);\nshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\nshadowKernel[1] *= vec3(0.25);\nshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\nshadowKernel[2] *= vec3(0.25);\nvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\nshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\nshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\nvec4 shadowValues;\nshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\nshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\nshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\nshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\nshadow = dot( shadowValues, vec4( 1.0 ) );\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#else\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\nfloat fDepth = unpackDepth( rgbaDepth );\nif ( fDepth < shadowCoord.z )\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n#endif\n}\n#ifdef SHADOWMAP_DEBUG\n#ifdef SHADOWMAP_CASCADE\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n#else\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n#endif\n#endif\n}\n#ifdef GAMMA_OUTPUT\nshadowColor *= shadowColor;\n#endif\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n#endif",
    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n#endif",
    shadowmap_vertex: "#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif",
    alphatest_fragment: "#ifdef ALPHATEST\nif ( gl_FragColor.a < ALPHATEST ) discard;\n#endif",
    linear_to_gamma_fragment: "#ifdef GAMMA_OUTPUT\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n#endif"
};
THREE.UniformsUtils = {
    merge: function (a) {
        var b, c, d, e = {};
        for (b = 0; b < a.length; b++)
            for (c in d = this.clone(a[b]), d) e[c] = d[c];
        return e
    },
    clone: function (a) {
        var b, c, d, e = {};
        for (b in a)
            for (c in e[b] = {}, a[b]) d = a[b][c], e[b][c] = d instanceof THREE.Color || d instanceof THREE.Vector2 || d instanceof THREE.Vector3 || d instanceof THREE.Vector4 || d instanceof THREE.Matrix4 || d instanceof THREE.Texture ? d.clone() : d instanceof Array ? d.slice() : d;
        return e
    }
};
THREE.UniformsLib = {
    common: {
        diffuse: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        offsetRepeat: {
            type: "v4",
            value: new THREE.Vector4(0, 0, 1, 1)
        },
        lightMap: {
            type: "t",
            value: null
        },
        specularMap: {
            type: "t",
            value: null
        },
        envMap: {
            type: "t",
            value: null
        },
        flipEnvMap: {
            type: "f",
            value: -1
        },
        useRefract: {
            type: "i",
            value: 0
        },
        reflectivity: {
            type: "f",
            value: 1
        },
        refractionRatio: {
            type: "f",
            value: .98
        },
        combine: {
            type: "i",
            value: 0
        },
        morphTargetInfluences: {
            type: "f",
            value: 0
        }
    },
    bump: {
        bumpMap: {
            type: "t",
            value: null
        },
        bumpScale: {
            type: "f",
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            type: "t",
            value: null
        },
        normalScale: {
            type: "v2",
            value: new THREE.Vector2(1, 1)
        }
    },
    fog: {
        fogDensity: {
            type: "f",
            value: 25e-5
        },
        fogNear: {
            type: "f",
            value: 1
        },
        fogFar: {
            type: "f",
            value: 2e3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            type: "fv",
            value: []
        },
        directionalLightDirection: {
            type: "fv",
            value: []
        },
        directionalLightColor: {
            type: "fv",
            value: []
        },
        hemisphereLightDirection: {
            type: "fv",
            value: []
        },
        hemisphereLightSkyColor: {
            type: "fv",
            value: []
        },
        hemisphereLightGroundColor: {
            type: "fv",
            value: []
        },
        pointLightColor: {
            type: "fv",
            value: []
        },
        pointLightPosition: {
            type: "fv",
            value: []
        },
        pointLightDistance: {
            type: "fv1",
            value: []
        },
        spotLightColor: {
            type: "fv",
            value: []
        },
        spotLightPosition: {
            type: "fv",
            value: []
        },
        spotLightDirection: {
            type: "fv",
            value: []
        },
        spotLightDistance: {
            type: "fv1",
            value: []
        },
        spotLightAngleCos: {
            type: "fv1",
            value: []
        },
        spotLightExponent: {
            type: "fv1",
            value: []
        }
    },
    particle: {
        psColor: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        size: {
            type: "f",
            value: 1
        },
        scale: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        fogDensity: {
            type: "f",
            value: 25e-5
        },
        fogNear: {
            type: "f",
            value: 1
        },
        fogFar: {
            type: "f",
            value: 2e3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    shadowmap: {
        shadowMap: {
            type: "tv",
            value: []
        },
        shadowMapSize: {
            type: "v2v",
            value: []
        },
        shadowBias: {
            type: "fv1",
            value: []
        },
        shadowDarkness: {
            type: "fv1",
            value: []
        },
        shadowMatrix: {
            type: "m4v",
            value: []
        }
    }
};
THREE.ShaderLib = {
    basic: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
        vertexShader: [THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, "void main() {\ngl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
    },
    lambert: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
            ambient: {
                type: "c",
                value: new THREE.Color(16777215)
            },
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1, 1, 1)
            }
        }]),
        vertexShader: ["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
        fragmentShader: ["uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "#ifdef DOUBLE_SIDED\nif ( gl_FrontFacing )\ngl_FragColor.xyz *= vLightFront;\nelse\ngl_FragColor.xyz *= vLightBack;\n#else\ngl_FragColor.xyz *= vLightFront;\n#endif", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
    },
    phong: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
            ambient: {
                type: "c",
                value: new THREE.Color(16777215)
            },
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            specular: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            shininess: {
                type: "f",
                value: 30
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1, 1, 1)
            }
        }]),
        vertexShader: ["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "vNormal = normalize( transformedNormal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, "vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
    },
    particle_basic: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),
        vertexShader: ["uniform float size;\nuniform float scale;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n#ifdef USE_SIZEATTENUATION\ngl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n#else\ngl_PointSize = size;\n#endif\ngl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
        fragmentShader: ["uniform vec3 psColor;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, "void main() {\ngl_FragColor = vec4( psColor, opacity );", THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
    },
    dashed: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
            scale: {
                type: "f",
                value: 1
            },
            dashSize: {
                type: "f",
                value: 1
            },
            totalSize: {
                type: "f",
                value: 2
            }
        }]),
        vertexShader: ["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "vLineDistance = scale * lineDistance;\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, "void main() {\nif ( mod( vLineDistance, totalSize ) > dashSize ) {\ndiscard;\n}\ngl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
    },
    depth: {
        uniforms: {
            mNear: {
                type: "f",
                value: 1
            },
            mFar: {
                type: "f",
                value: 2e3
            },
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: "void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: "uniform float mNear;\nuniform float mFar;\nuniform float opacity;\nvoid main() {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\ngl_FragColor = vec4( vec3( color ), opacity );\n}"
    },
    normal: {
        uniforms: {
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.morphtarget_pars_vertex, "void main() {\nvNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, "}"].join("\n"),
        fragmentShader: "uniform float opacity;\nvarying vec3 vNormal;\nvoid main() {\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\n}"
    },
    normalmap: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
            enableAO: {
                type: "i",
                value: 0
            },
            enableDiffuse: {
                type: "i",
                value: 0
            },
            enableSpecular: {
                type: "i",
                value: 0
            },
            enableReflection: {
                type: "i",
                value: 0
            },
            enableDisplacement: {
                type: "i",
                value: 0
            },
            tDisplacement: {
                type: "t",
                value: null
            },
            tDiffuse: {
                type: "t",
                value: null
            },
            tCube: {
                type: "t",
                value: null
            },
            tNormal: {
                type: "t",
                value: null
            },
            tSpecular: {
                type: "t",
                value: null
            },
            tAO: {
                type: "t",
                value: null
            },
            uNormalScale: {
                type: "v2",
                value: new THREE.Vector2(1, 1)
            },
            uDisplacementBias: {
                type: "f",
                value: 0
            },
            uDisplacementScale: {
                type: "f",
                value: 1
            },
            uDiffuseColor: {
                type: "c",
                value: new THREE.Color(16777215)
            },
            uSpecularColor: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            uAmbientColor: {
                type: "c",
                value: new THREE.Color(16777215)
            },
            uShininess: {
                type: "f",
                value: 30
            },
            uOpacity: {
                type: "f",
                value: 1
            },
            useRefract: {
                type: "i",
                value: 0
            },
            uRefractionRatio: {
                type: "f",
                value: .98
            },
            uReflectivity: {
                type: "f",
                value: .5
            },
            uOffset: {
                type: "v2",
                value: new THREE.Vector2(0, 0)
            },
            uRepeat: {
                type: "v2",
                value: new THREE.Vector2(1, 1)
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1, 1, 1)
            }
        }]),
        fragmentShader: ["uniform vec3 uAmbientColor;\nuniform vec3 uDiffuseColor;\nuniform vec3 uSpecularColor;\nuniform float uShininess;\nuniform float uOpacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float uRefractionRatio;\nuniform float uReflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;", THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3( 1.0 ), uOpacity );\nvec3 specularTex = vec3( 1.0 );\nvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\nnormalTex.xy *= uNormalScale;\nnormalTex = normalize( normalTex );\nif( enableDiffuse ) {\n#ifdef GAMMA_INPUT\nvec4 texelColor = texture2D( tDiffuse, vUv );\ntexelColor.xyz *= texelColor.xyz;\ngl_FragColor = gl_FragColor * texelColor;\n#else\ngl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n#endif\n}\nif( enableAO ) {\n#ifdef GAMMA_INPUT\nvec4 aoColor = texture2D( tAO, vUv );\naoColor.xyz *= aoColor.xyz;\ngl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n#endif\n}\nif( enableSpecular )\nspecularTex = texture2D( tSpecular, vUv ).xyz;\nmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\nvec3 finalNormal = tsb * normalTex;\n#ifdef FLIP_SIDED\nfinalNormal = -finalNormal;\n#endif\nvec3 normal = normalize( finalNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\nfloat pointDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\npointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\npointVector = normalize( pointVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n#endif\npointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;\nvec3 pointHalfVector = normalize( pointVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\nvec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n#else\npointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\nfloat spotDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\nspotVector = normalize( spotVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n#endif\nspotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;\nvec3 spotHalfVector = normalize( spotVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\nvec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n#else\nspotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\n#ifdef WRAP_AROUND\nfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\nfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n#endif\ndirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\nvec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n#else\ndirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;\n#endif\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += uDiffuseColor * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\nvec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n#else\nhemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\n#endif\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;\n#endif\nif ( enableReflection ) {\nvec3 vReflect;\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, normal, uRefractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, normal );\n}\nvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );\n}", THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n"),
        vertexShader: ["attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\nuniform sampler2D tDisplacement;\nuniform float uDisplacementScale;\nuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;", THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, "#ifdef USE_SKINNING\nvNormal = normalize( normalMatrix * skinnedNormal.xyz );\nvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\nvTangent = normalize( normalMatrix * skinnedTangent.xyz );\n#else\nvNormal = normalize( normalMatrix * normal );\nvTangent = normalize( normalMatrix * tangent.xyz );\n#endif\nvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\nvUv = uv * uRepeat + uOffset;\nvec3 displacedPosition;\n#ifdef VERTEX_TEXTURES\nif ( enableDisplacement ) {\nvec3 dv = texture2D( tDisplacement, uv ).xyz;\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\ndisplacedPosition = position + normalize( normal ) * df;\n} else {\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned      += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n}\n#else\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned      += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n#endif\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\nvWorldPosition = worldPosition.xyz;\nvViewPosition = -mvPosition.xyz;\n#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif\n}"].join("\n")
    },
    cube: {
        uniforms: {
            tCube: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "f",
                value: -1
            }
        },
        vertexShader: "varying vec3 vWorldPosition;\nvoid main() {\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvWorldPosition = worldPosition.xyz;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\nvoid main() {\ngl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n}"
    },
    depthRGBA: {
        uniforms: {},
        vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, "}"].join("\n"),
        fragmentShader: "vec4 pack_depth( const in float depth ) {\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\nvec4 res = fract( depth * bit_shift );\nres -= res.xxyz * bit_mask;\nreturn res;\n}\nvoid main() {\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n}"
    }
};
THREE.WebGLRenderer = function (a) {
    function b(a, b) {
        var c = a.vertices.length,
            d = b.material;
        if (d.attributes) {
            void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);
            for (var e in d.attributes) {
                var f = d.attributes[e];
                if (!f.__webglInitialized || f.createUniqueBuffers) {
                    f.__webglInitialized = !0;
                    var h = 1;
                    "v2" === f.type ? h = 2 : "v3" === f.type ? h = 3 : "v4" === f.type ? h = 4 : "c" === f.type && (h = 3);
                    f.size = h;
                    f.array = new Float32Array(c * h);
                    f.buffer = j.createBuffer();
                    f.buffer.belongsToAttribute = e;
                    f.needsUpdate = !0
                }
                a.__webglCustomAttributesList.push(f)
            }
        }
    }

    function c(a, b) {
        var c = b.geometry,
            h = a.faces3,
            g = 3 * h.length,
            i = 1 * h.length,
            k = 3 * h.length,
            h = d(b, a),
            m = f(h),
            l = e(h),
            p = h.vertexColors ? h.vertexColors : !1;
        a.__vertexArray = new Float32Array(3 * g);
        l && (a.__normalArray = new Float32Array(3 * g));
        c.hasTangents && (a.__tangentArray = new Float32Array(4 * g));
        p && (a.__colorArray = new Float32Array(3 * g));
        m && (0 < c.faceVertexUvs.length && (a.__uvArray = new Float32Array(2 * g)), 1 < c.faceVertexUvs.length && (a.__uv2Array = new Float32Array(2 * g)));
        b.geometry.skinWeights.length && b.geometry.skinIndices.length && (a.__skinIndexArray = new Float32Array(4 * g), a.__skinWeightArray = new Float32Array(4 * g));
        a.__faceArray = new Uint16Array(3 * i);
        a.__lineArray = new Uint16Array(2 * k);
        if (a.numMorphTargets) {
            a.__morphTargetsArrays = [];
            c = 0;
            for (m = a.numMorphTargets; c < m; c++) a.__morphTargetsArrays.push(new Float32Array(3 * g))
        }
        if (a.numMorphNormals) {
            a.__morphNormalsArrays = [];
            c = 0;
            for (m = a.numMorphNormals; c < m; c++) a.__morphNormalsArrays.push(new Float32Array(3 * g))
        }
        a.__webglFaceCount = 3 * i;
        a.__webglLineCount = 2 * k;
        if (h.attributes) {
            void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);
            for (var n in h.attributes) {
                var i = h.attributes[n],
                    k = {},
                    s;
                for (s in i) k[s] = i[s];
                if (!k.__webglInitialized || k.createUniqueBuffers) k.__webglInitialized = !0, c = 1, "v2" === k.type ? c = 2 : "v3" === k.type ? c = 3 : "v4" === k.type ? c = 4 : "c" === k.type && (c = 3), k.size = c, k.array = new Float32Array(g * c), k.buffer = j.createBuffer(), k.buffer.belongsToAttribute = n, i.needsUpdate = !0, k.__original = i;
                a.__webglCustomAttributesList.push(k)
            }
        }
        a.__inittedArrays = !0
    }

    function d(a, b) {
        return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material
    }

    function e(a) {
        return a instanceof THREE.MeshBasicMaterial && !a.envMap || a instanceof THREE.MeshDepthMaterial ? !1 : a && void 0 !== a.shading && a.shading === THREE.SmoothShading ? THREE.SmoothShading : THREE.FlatShading
    }

    function f(a) {
        return a.map || a.lightMap || a.bumpMap || a.normalMap || a.specularMap || a instanceof THREE.ShaderMaterial ? !0 : !1
    }

    function h(a) {
        Ha[a] || (j.enableVertexAttribArray(a), Ha[a] = !0)
    }

    function g() {
        for (var a in Ha) Ha[a] && (j.disableVertexAttribArray(a), Ha[a] = !1)
    }

    function i(a, b) {
        return a.z !== b.z ? b.z - a.z : a.id - b.id
    }

    function k(a, b) {
        return b[0] - a[0]
    }

    function m(a, b, c) {
        if (a.length)
            for (var d = 0, e = a.length; d < e; d++) ea = Ca = null, Ba = $ = U = Y = fa = Ga = ka = -1, ua = !0, a[d].render(b, c, qb, eb), ea = Ca = null, Ba = $ = U = Y = fa = Ga = ka = -1, ua = !0
    }

    function l(a, b, c, d, e, f, h, g) {
        var j, i, k, m;
        b ? (i = a.length - 1, m = b = -1) : (i = 0, b = a.length, m = 1);
        for (var l = i; l !== b; l += m)
            if (j = a[l], j.render) {
                i = j.object;
                k = j.buffer;
                if (g) j = g;
                else {
                    j = j[c];
                    if (!j) continue;
                    h && K.setBlending(j.blending, j.blendEquation, j.blendSrc, j.blendDst);
                    K.setDepthTest(j.depthTest);
                    K.setDepthWrite(j.depthWrite);
                    z(j.polygonOffset, j.polygonOffsetFactor, j.polygonOffsetUnits)
                }
                K.setMaterialFaces(j);
                k instanceof THREE.BufferGeometry ? K.renderBufferDirect(d, e, f, j, k, i) : K.renderBuffer(d, e, f, j, k, i)
            }
    }

    function p(a, b, c, d, e, f, h) {
        for (var g, j, i = 0, k = a.length; i < k; i++)
            if (g = a[i], j = g.object, j.visible) {
                if (h) g = h;
                else {
                    g = g[b];
                    if (!g) continue;
                    f && K.setBlending(g.blending, g.blendEquation, g.blendSrc, g.blendDst);
                    K.setDepthTest(g.depthTest);
                    K.setDepthWrite(g.depthWrite);
                    z(g.polygonOffset, g.polygonOffsetFactor, g.polygonOffsetUnits)
                }
                K.renderImmediateObject(c, d, e, g, j)
            }
    }

    function r(a, d) {
        var e, f, h, g;
        if (void 0 === a.__webglInit && (a.__webglInit = !0, a._modelViewMatrix = new THREE.Matrix4, a._normalMatrix = new THREE.Matrix3, void 0 !== a.geometry && void 0 === a.geometry.__webglInit && (a.geometry.__webglInit = !0, a.geometry.addEventListener("dispose", Db)), f = a.geometry, void 0 !== f))
            if (f instanceof THREE.BufferGeometry) {
                var i, k;
                for (i in f.attributes) k = "index" === i ? j.ELEMENT_ARRAY_BUFFER : j.ARRAY_BUFFER, g = f.attributes[i], void 0 === g.numItems && (g.numItems = g.array.length), g.buffer = j.createBuffer(), j.bindBuffer(k, g.buffer), j.bufferData(k, g.array, j.STATIC_DRAW)
            } else if (a instanceof THREE.Mesh) {
            h = a.material;
            if (void 0 === f.geometryGroups) {
                i = f;
                var m, l, p;
                k = {};
                var n = i.morphTargets.length,
                    s = i.morphNormals.length,
                    r = h instanceof THREE.MeshFaceMaterial;
                i.geometryGroups = {};
                h = 0;
                for (m = i.faces.length; h < m; h++) l = i.faces[h], l = r ? l.materialIndex : 0, void 0 === k[l] && (k[l] = {
                    hash: l,
                    counter: 0
                }), p = k[l].hash + "_" + k[l].counter, void 0 === i.geometryGroups[p] && (i.geometryGroups[p] = {
                    faces3: [],
                    materialIndex: l,
                    vertices: 0,
                    numMorphTargets: n,
                    numMorphNormals: s
                }), 65535 < i.geometryGroups[p].vertices + 3 && (k[l].counter += 1, p = k[l].hash + "_" + k[l].counter, void 0 === i.geometryGroups[p] && (i.geometryGroups[p] = {
                    faces3: [],
                    materialIndex: l,
                    vertices: 0,
                    numMorphTargets: n,
                    numMorphNormals: s
                })), i.geometryGroups[p].faces3.push(h), i.geometryGroups[p].vertices += 3;
                i.geometryGroupsList = [];
                for (g in i.geometryGroups) i.geometryGroups[g].id = V++, i.geometryGroupsList.push(i.geometryGroups[g])
            }
            for (e in f.geometryGroups)
                if (g = f.geometryGroups[e], !g.__webglVertexBuffer) {
                    i = g;
                    i.__webglVertexBuffer = j.createBuffer();
                    i.__webglNormalBuffer = j.createBuffer();
                    i.__webglTangentBuffer = j.createBuffer();
                    i.__webglColorBuffer = j.createBuffer();
                    i.__webglUVBuffer = j.createBuffer();
                    i.__webglUV2Buffer = j.createBuffer();
                    i.__webglSkinIndicesBuffer = j.createBuffer();
                    i.__webglSkinWeightsBuffer = j.createBuffer();
                    i.__webglFaceBuffer = j.createBuffer();
                    i.__webglLineBuffer = j.createBuffer();
                    n = k = void 0;
                    if (i.numMorphTargets) {
                        i.__webglMorphTargetsBuffers = [];
                        k = 0;
                        for (n = i.numMorphTargets; k < n; k++) i.__webglMorphTargetsBuffers.push(j.createBuffer())
                    }
                    if (i.numMorphNormals) {
                        i.__webglMorphNormalsBuffers = [];
                        k = 0;
                        for (n = i.numMorphNormals; k < n; k++) i.__webglMorphNormalsBuffers.push(j.createBuffer())
                    }
                    K.info.memory.geometries++;
                    c(g, a);
                    f.verticesNeedUpdate = !0;
                    f.morphTargetsNeedUpdate = !0;
                    f.elementsNeedUpdate = !0;
                    f.uvsNeedUpdate = !0;
                    f.normalsNeedUpdate = !0;
                    f.tangentsNeedUpdate = !0;
                    f.colorsNeedUpdate = !0
                }
        } else a instanceof THREE.Line ? f.__webglVertexBuffer || (g = f, g.__webglVertexBuffer = j.createBuffer(), g.__webglColorBuffer = j.createBuffer(), g.__webglLineDistanceBuffer = j.createBuffer(), K.info.memory.geometries++, g = f, i = g.vertices.length, g.__vertexArray = new Float32Array(3 * i), g.__colorArray = new Float32Array(3 * i), g.__lineDistanceArray = new Float32Array(1 * i), g.__webglLineCount = i, b(g, a), f.verticesNeedUpdate = !0, f.colorsNeedUpdate = !0, f.lineDistancesNeedUpdate = !0) : a instanceof THREE.ParticleSystem && !f.__webglVertexBuffer && (g = f, g.__webglVertexBuffer = j.createBuffer(), g.__webglColorBuffer = j.createBuffer(), K.info.memory.geometries++, g = f, i = g.vertices.length, g.__vertexArray = new Float32Array(3 * i), g.__colorArray = new Float32Array(3 * i), g.__sortArray = [], g.__webglParticleCount = i, b(g, a), f.verticesNeedUpdate = !0, f.colorsNeedUpdate = !0); if (void 0 === a.__webglActive) {
            if (a instanceof THREE.Mesh)
                if (f = a.geometry, f instanceof THREE.BufferGeometry) t(d.__webglObjects, f, a);
                else {
                    if (f instanceof THREE.Geometry)
                        for (e in f.geometryGroups) g = f.geometryGroups[e], t(d.__webglObjects, g, a)
                } else a instanceof THREE.Line || a instanceof THREE.ParticleSystem ? (f = a.geometry, t(d.__webglObjects, f, a)) : a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback ? d.__webglObjectsImmediate.push({
                id: null,
                object: a,
                opaque: null,
                transparent: null,
                z: 0
            }) : a instanceof THREE.Sprite ? d.__webglSprites.push(a) : a instanceof THREE.LensFlare && d.__webglFlares.push(a);
            a.__webglActive = !0
        }
    }

    function t(a, b, c) {
        a.push({
            id: null,
            buffer: b,
            object: c,
            opaque: null,
            transparent: null,
            z: 0
        })
    }

    function n(a) {
        for (var b in a.attributes)
            if (a.attributes[b].needsUpdate) return !0;
        return !1
    }

    function s(a) {
        for (var b in a.attributes) a.attributes[b].needsUpdate = !1
    }

    function q(a, b) {
        a instanceof THREE.Mesh || a instanceof THREE.ParticleSystem || a instanceof THREE.Line ? u(b.__webglObjects, a) : a instanceof THREE.Sprite ? w(b.__webglSprites, a) : a instanceof THREE.LensFlare ? w(b.__webglFlares, a) : (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) && u(b.__webglObjectsImmediate, a);
        delete a.__webglActive
    }

    function u(a, b) {
        for (var c = a.length - 1; 0 <= c; c--) a[c].object === b && a.splice(c, 1)
    }

    function w(a, b) {
        for (var c = a.length - 1; 0 <= c; c--) a[c] === b && a.splice(c, 1)
    }

    function E(a, b, c, d, e) {
        P = 0;
        d.needsUpdate && (d.program && Hb(d), K.initMaterial(d, b, c, e), d.needsUpdate = !1);
        d.morphTargets && !e.__webglMorphTargetInfluences && (e.__webglMorphTargetInfluences = new Float32Array(K.maxMorphTargets));
        var f = !1,
            g = d.program,
            h = g.uniforms,
            i = d.uniforms;
        g !== Ca && (j.useProgram(g), Ca = g, f = !0);
        d.id !== Ba && (Ba = d.id, f = !0);
        if (f || a !== ea) j.uniformMatrix4fv(h.projectionMatrix, !1, a.projectionMatrix.elements), a !== ea && (ea = a);
        if (d.skinning)
            if (zb && e.useVertexTexture) {
                if (null !== h.boneTexture) {
                    var k = C();
                    j.uniform1i(h.boneTexture, k);
                    K.setTexture(e.boneTexture, k)
                }
                null !== h.boneTextureWidth && j.uniform1i(h.boneTextureWidth, e.boneTextureWidth);
                null !== h.boneTextureHeight && j.uniform1i(h.boneTextureHeight, e.boneTextureHeight)
            } else null !== h.boneGlobalMatrices && j.uniformMatrix4fv(h.boneGlobalMatrices, !1, e.boneMatrices);
        if (f) {
            c && d.fog && (i.fogColor.value = c.color, c instanceof THREE.Fog ? (i.fogNear.value = c.near, i.fogFar.value = c.far) : c instanceof THREE.FogExp2 && (i.fogDensity.value = c.density));
            if (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d.lights) {
                if (ua) {
                    for (var m, l = k = 0, p = 0, n, s, r, q = Oa, t = q.directional.colors, u = q.directional.positions, w = q.point.colors, v = q.point.positions, z = q.point.distances, E = q.spot.colors, A = q.spot.positions, B = q.spot.distances, J = q.spot.directions, N = q.spot.anglesCos, O = q.spot.exponents, I = q.hemi.skyColors, V = q.hemi.groundColors, Q = q.hemi.positions, M = 0, U = 0, Y = 0, Aa = 0, $ = 0, dc = 0, X = 0, W = 0, R = m = 0, c = r = R = 0, f = b.length; c < f; c++) m = b[c], m.onlyShadow || (n = m.color, s = m.intensity, r = m.distance, m instanceof THREE.AmbientLight ? m.visible && (K.gammaInput ? (k += n.r * n.r, l += n.g * n.g, p += n.b * n.b) : (k += n.r, l += n.g, p += n.b)) : m instanceof THREE.DirectionalLight ? ($ += 1, m.visible && (ga.getPositionFromMatrix(m.matrixWorld), sa.getPositionFromMatrix(m.target.matrixWorld), ga.sub(sa), ga.normalize(), 0 === ga.x && 0 === ga.y && 0 === ga.z || (m = 3 * M, u[m] = ga.x, u[m + 1] = ga.y, u[m + 2] = ga.z, K.gammaInput ? F(t, m, n, s * s) : y(t, m, n, s), M += 1))) : m instanceof THREE.PointLight ? (dc += 1, m.visible && (R = 3 * U, K.gammaInput ? F(w, R, n, s * s) : y(w, R, n, s), sa.getPositionFromMatrix(m.matrixWorld), v[R] = sa.x, v[R + 1] = sa.y, v[R + 2] = sa.z, z[U] = r, U += 1)) : m instanceof THREE.SpotLight ? (X += 1, m.visible && (R = 3 * Y, K.gammaInput ? F(E, R, n, s * s) : y(E, R, n, s), sa.getPositionFromMatrix(m.matrixWorld), A[R] = sa.x, A[R + 1] = sa.y, A[R + 2] = sa.z, B[Y] = r, ga.copy(sa), sa.getPositionFromMatrix(m.target.matrixWorld), ga.sub(sa), ga.normalize(), J[R] = ga.x, J[R + 1] = ga.y, J[R + 2] = ga.z, N[Y] = Math.cos(m.angle), O[Y] = m.exponent, Y += 1)) : m instanceof THREE.HemisphereLight && (W += 1, m.visible && (ga.getPositionFromMatrix(m.matrixWorld), ga.normalize(), 0 === ga.x && 0 === ga.y && 0 === ga.z || (r = 3 * Aa, Q[r] = ga.x, Q[r + 1] = ga.y, Q[r + 2] = ga.z, n = m.color, m = m.groundColor, K.gammaInput ? (s *= s, F(I, r, n, s), F(V, r, m, s)) : (y(I, r, n, s), y(V, r, m, s)), Aa += 1))));
                    c = 3 * M;
                    for (f = Math.max(t.length, 3 * $); c < f; c++) t[c] = 0;
                    c = 3 * U;
                    for (f = Math.max(w.length, 3 * dc); c < f; c++) w[c] = 0;
                    c = 3 * Y;
                    for (f = Math.max(E.length, 3 * X); c < f; c++) E[c] = 0;
                    c = 3 * Aa;
                    for (f = Math.max(I.length, 3 * W); c < f; c++) I[c] = 0;
                    c = 3 * Aa;
                    for (f = Math.max(V.length, 3 * W); c < f; c++) V[c] = 0;
                    q.directional.length = M;
                    q.point.length = U;
                    q.spot.length = Y;
                    q.hemi.length = Aa;
                    q.ambient[0] = k;
                    q.ambient[1] = l;
                    q.ambient[2] = p;
                    ua = !1
                }
                c = Oa;
                i.ambientLightColor.value = c.ambient;
                i.directionalLightColor.value = c.directional.colors;
                i.directionalLightDirection.value = c.directional.positions;
                i.pointLightColor.value = c.point.colors;
                i.pointLightPosition.value = c.point.positions;
                i.pointLightDistance.value = c.point.distances;
                i.spotLightColor.value = c.spot.colors;
                i.spotLightPosition.value = c.spot.positions;
                i.spotLightDistance.value = c.spot.distances;
                i.spotLightDirection.value = c.spot.directions;
                i.spotLightAngleCos.value = c.spot.anglesCos;
                i.spotLightExponent.value = c.spot.exponents;
                i.hemisphereLightSkyColor.value = c.hemi.skyColors;
                i.hemisphereLightGroundColor.value = c.hemi.groundColors;
                i.hemisphereLightDirection.value = c.hemi.positions
            }
            if (d instanceof THREE.MeshBasicMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshPhongMaterial) {
                i.opacity.value = d.opacity;
                K.gammaInput ? i.diffuse.value.copyGammaToLinear(d.color) : i.diffuse.value = d.color;
                i.map.value = d.map;
                i.lightMap.value = d.lightMap;
                i.specularMap.value = d.specularMap;
                d.bumpMap && (i.bumpMap.value = d.bumpMap, i.bumpScale.value = d.bumpScale);
                d.normalMap && (i.normalMap.value = d.normalMap, i.normalScale.value.copy(d.normalScale));
                var ba;
                d.map ? ba = d.map : d.specularMap ? ba = d.specularMap : d.normalMap ? ba = d.normalMap : d.bumpMap && (ba = d.bumpMap);
                void 0 !== ba && (c = ba.offset, ba = ba.repeat, i.offsetRepeat.value.set(c.x, c.y, ba.x, ba.y));
                i.envMap.value = d.envMap;
                i.flipEnvMap.value = d.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;
                i.reflectivity.value = d.reflectivity;
                i.refractionRatio.value = d.refractionRatio;
                i.combine.value = d.combine;
                i.useRefract.value = d.envMap && d.envMap.mapping instanceof THREE.CubeRefractionMapping
            }
            d instanceof THREE.LineBasicMaterial ? (i.diffuse.value = d.color, i.opacity.value = d.opacity) : d instanceof THREE.LineDashedMaterial ? (i.diffuse.value = d.color, i.opacity.value = d.opacity, i.dashSize.value = d.dashSize, i.totalSize.value = d.dashSize + d.gapSize, i.scale.value = d.scale) : d instanceof THREE.ParticleBasicMaterial ? (i.psColor.value = d.color, i.opacity.value = d.opacity, i.size.value = d.size, i.scale.value = G.height / 2, i.map.value = d.map) : d instanceof THREE.MeshPhongMaterial ? (i.shininess.value = d.shininess, K.gammaInput ? (i.ambient.value.copyGammaToLinear(d.ambient), i.emissive.value.copyGammaToLinear(d.emissive), i.specular.value.copyGammaToLinear(d.specular)) : (i.ambient.value = d.ambient, i.emissive.value = d.emissive, i.specular.value = d.specular), d.wrapAround && i.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshLambertMaterial ? (K.gammaInput ? (i.ambient.value.copyGammaToLinear(d.ambient), i.emissive.value.copyGammaToLinear(d.emissive)) : (i.ambient.value = d.ambient, i.emissive.value = d.emissive), d.wrapAround && i.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshDepthMaterial ? (i.mNear.value = a.near, i.mFar.value = a.far, i.opacity.value = d.opacity) : d instanceof THREE.MeshNormalMaterial && (i.opacity.value = d.opacity);
            if (e.receiveShadow && !d._shadowPass && i.shadowMatrix) {
                c = ba = 0;
                for (f = b.length; c < f; c++)
                    if (k = b[c], k.castShadow && (k instanceof THREE.SpotLight || k instanceof THREE.DirectionalLight && !k.shadowCascade)) i.shadowMap.value[ba] = k.shadowMap, i.shadowMapSize.value[ba] = k.shadowMapSize, i.shadowMatrix.value[ba] = k.shadowMatrix, i.shadowDarkness.value[ba] = k.shadowDarkness, i.shadowBias.value[ba] = k.shadowBias, ba++
            }
            b = d.uniformsList;
            i = 0;
            for (ba = b.length; i < ba; i++)
                if (f = g.uniforms[b[i][1]])
                    if (c = b[i][0], l = c.type, k = c.value, "i" === l) j.uniform1i(f, k);
                    else if ("f" === l) j.uniform1f(f, k);
            else if ("v2" === l) j.uniform2f(f, k.x, k.y);
            else if ("v3" === l) j.uniform3f(f, k.x, k.y, k.z);
            else if ("v4" === l) j.uniform4f(f, k.x, k.y, k.z, k.w);
            else if ("c" === l) j.uniform3f(f, k.r, k.g, k.b);
            else if ("iv1" === l) j.uniform1iv(f, k);
            else if ("iv" === l) j.uniform3iv(f, k);
            else if ("fv1" === l) j.uniform1fv(f, k);
            else if ("fv" === l) j.uniform3fv(f, k);
            else if ("v2v" === l) {
                void 0 === c._array && (c._array = new Float32Array(2 * k.length));
                l = 0;
                for (p = k.length; l < p; l++) q = 2 * l, c._array[q] = k[l].x, c._array[q + 1] = k[l].y;
                j.uniform2fv(f, c._array)
            } else if ("v3v" === l) {
                void 0 === c._array && (c._array = new Float32Array(3 * k.length));
                l = 0;
                for (p = k.length; l < p; l++) q = 3 * l, c._array[q] = k[l].x, c._array[q + 1] = k[l].y, c._array[q + 2] = k[l].z;
                j.uniform3fv(f, c._array)
            } else if ("v4v" === l) {
                void 0 === c._array && (c._array = new Float32Array(4 * k.length));
                l = 0;
                for (p = k.length; l < p; l++) q = 4 * l, c._array[q] = k[l].x, c._array[q + 1] = k[l].y, c._array[q + 2] = k[l].z, c._array[q + 3] = k[l].w;
                j.uniform4fv(f, c._array)
            } else if ("m4" === l) void 0 === c._array && (c._array = new Float32Array(16)), k.flattenToArray(c._array), j.uniformMatrix4fv(f, !1, c._array);
            else if ("m4v" === l) {
                void 0 === c._array && (c._array = new Float32Array(16 * k.length));
                l = 0;
                for (p = k.length; l < p; l++) k[l].flattenToArrayOffset(c._array, 16 * l);
                j.uniformMatrix4fv(f, !1, c._array)
            } else if ("t" === l) {
                if (q = k, k = C(), j.uniform1i(f, k), q)
                    if (q.image instanceof Array && 6 === q.image.length) {
                        if (c = q, f = k, 6 === c.image.length)
                            if (c.needsUpdate) {
                                c.image.__webglTextureCube || (c.addEventListener("dispose", Eb), c.image.__webglTextureCube = j.createTexture(), K.info.memory.textures++);
                                j.activeTexture(j.TEXTURE0 + f);
                                j.bindTexture(j.TEXTURE_CUBE_MAP, c.image.__webglTextureCube);
                                j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, c.flipY);
                                f = c instanceof THREE.CompressedTexture;
                                k = [];
                                for (l = 0; 6 > l; l++) K.autoScaleCubemaps && !f ? (p = k, q = l, t = c.image[l], w = ac, t.width <= w && t.height <= w || (v = Math.max(t.width, t.height), u = Math.floor(t.width * w / v), w = Math.floor(t.height * w / v), v = document.createElement("canvas"), v.width = u, v.height = w, v.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, u, w), t = v), p[q] = t) : k[l] = c.image[l];
                                l = k[0];
                                p = 0 === (l.width & l.width - 1) && 0 === (l.height & l.height - 1);
                                q = x(c.format);
                                t = x(c.type);
                                D(j.TEXTURE_CUBE_MAP, c, p);
                                for (l = 0; 6 > l; l++)
                                    if (f) {
                                        w = k[l].mipmaps;
                                        v = 0;
                                        for (z = w.length; v < z; v++) u = w[v], c.format !== THREE.RGBAFormat ? j.compressedTexImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X + l, v, q, u.width, u.height, 0, u.data) : j.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X + l, v, q, u.width, u.height, 0, q, t, u.data)
                                    } else j.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X + l, 0, q, q, t, k[l]);
                                c.generateMipmaps && p && j.generateMipmap(j.TEXTURE_CUBE_MAP);
                                c.needsUpdate = !1;
                                if (c.onUpdate) c.onUpdate()
                            } else j.activeTexture(j.TEXTURE0 + f), j.bindTexture(j.TEXTURE_CUBE_MAP, c.image.__webglTextureCube)
                    } else q instanceof THREE.WebGLRenderTargetCube ? (c = q, j.activeTexture(j.TEXTURE0 + k), j.bindTexture(j.TEXTURE_CUBE_MAP, c.__webglTexture)) : K.setTexture(q, k)
            } else if ("tv" === l) {
                void 0 === c._array && (c._array = []);
                l = 0;
                for (p = c.value.length; l < p; l++) c._array[l] = C();
                j.uniform1iv(f, c._array);
                l = 0;
                for (p = c.value.length; l < p; l++) q = c.value[l], k = c._array[l], q && K.setTexture(q, k)
            } else console.warn("THREE.WebGLRenderer: Unknown uniform type: " + l); if ((d instanceof THREE.ShaderMaterial || d instanceof THREE.MeshPhongMaterial || d.envMap) && null !== h.cameraPosition) sa.getPositionFromMatrix(a.matrixWorld), j.uniform3f(h.cameraPosition, sa.x, sa.y, sa.z);
            (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.ShaderMaterial || d.skinning) && null !== h.viewMatrix && j.uniformMatrix4fv(h.viewMatrix, !1, a.matrixWorldInverse.elements)
        }
        j.uniformMatrix4fv(h.modelViewMatrix, !1, e._modelViewMatrix.elements);
        h.normalMatrix && j.uniformMatrix3fv(h.normalMatrix, !1, e._normalMatrix.elements);
        null !== h.modelMatrix && j.uniformMatrix4fv(h.modelMatrix, !1, e.matrixWorld.elements);
        return g
    }

    function C() {
        var a = P;
        a >= Nb && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + Nb);
        P += 1;
        return a
    }

    function F(a, b, c, d) {
        a[b] = c.r * c.r * d;
        a[b + 1] = c.g * c.g * d;
        a[b + 2] = c.b * c.b * d
    }

    function y(a, b, c, d) {
        a[b] = c.r * d;
        a[b + 1] = c.g * d;
        a[b + 2] = c.b * d
    }

    function A(a) {
        a !== xa && (j.lineWidth(a), xa = a)
    }

    function z(a, b, c) {
        Ea !== a && (a ? j.enable(j.POLYGON_OFFSET_FILL) : j.disable(j.POLYGON_OFFSET_FILL), Ea = a);
        if (a && (Ta !== b || Pa !== c)) j.polygonOffset(b, c), Ta = b, Pa = c
    }

    function O(a) {
        for (var a = a.split("\n"), b = 0, c = a.length; b < c; b++) a[b] = b + 1 + ": " + a[b];
        return a.join("\n")
    }

    function B(a, b) {
        var c;
        "fragment" === a ? c = j.createShader(j.FRAGMENT_SHADER) : "vertex" === a && (c = j.createShader(j.VERTEX_SHADER));
        j.shaderSource(c, b);
        j.compileShader(c);
        return !j.getShaderParameter(c, j.COMPILE_STATUS) ? (console.error(j.getShaderInfoLog(c)), console.error(O(b)), null) : c
    }

    function D(a, b, c) {
        c ? (j.texParameteri(a, j.TEXTURE_WRAP_S, x(b.wrapS)), j.texParameteri(a, j.TEXTURE_WRAP_T, x(b.wrapT)), j.texParameteri(a, j.TEXTURE_MAG_FILTER, x(b.magFilter)), j.texParameteri(a, j.TEXTURE_MIN_FILTER, x(b.minFilter))) : (j.texParameteri(a, j.TEXTURE_WRAP_S, j.CLAMP_TO_EDGE), j.texParameteri(a, j.TEXTURE_WRAP_T, j.CLAMP_TO_EDGE), j.texParameteri(a, j.TEXTURE_MAG_FILTER, v(b.magFilter)), j.texParameteri(a, j.TEXTURE_MIN_FILTER, v(b.minFilter)));
        if (wa && b.type !== THREE.FloatType && (1 < b.anisotropy || b.__oldAnisotropy)) j.texParameterf(a, wa.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, Ob)), b.__oldAnisotropy = b.anisotropy
    }

    function I(a, b) {
        j.bindRenderbuffer(j.RENDERBUFFER, a);
        b.depthBuffer && !b.stencilBuffer ? (j.renderbufferStorage(j.RENDERBUFFER, j.DEPTH_COMPONENT16, b.width, b.height), j.framebufferRenderbuffer(j.FRAMEBUFFER, j.DEPTH_ATTACHMENT, j.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (j.renderbufferStorage(j.RENDERBUFFER, j.DEPTH_STENCIL, b.width, b.height), j.framebufferRenderbuffer(j.FRAMEBUFFER, j.DEPTH_STENCIL_ATTACHMENT, j.RENDERBUFFER, a)) : j.renderbufferStorage(j.RENDERBUFFER, j.RGBA4, b.width, b.height)
    }

    function v(a) {
        return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? j.NEAREST : j.LINEAR
    }

    function x(a) {
        if (a === THREE.RepeatWrapping) return j.REPEAT;
        if (a === THREE.ClampToEdgeWrapping) return j.CLAMP_TO_EDGE;
        if (a === THREE.MirroredRepeatWrapping) return j.MIRRORED_REPEAT;
        if (a === THREE.NearestFilter) return j.NEAREST;
        if (a === THREE.NearestMipMapNearestFilter) return j.NEAREST_MIPMAP_NEAREST;
        if (a === THREE.NearestMipMapLinearFilter) return j.NEAREST_MIPMAP_LINEAR;
        if (a === THREE.LinearFilter) return j.LINEAR;
        if (a === THREE.LinearMipMapNearestFilter) return j.LINEAR_MIPMAP_NEAREST;
        if (a === THREE.LinearMipMapLinearFilter) return j.LINEAR_MIPMAP_LINEAR;
        if (a === THREE.UnsignedByteType) return j.UNSIGNED_BYTE;
        if (a === THREE.UnsignedShort4444Type) return j.UNSIGNED_SHORT_4_4_4_4;
        if (a === THREE.UnsignedShort5551Type) return j.UNSIGNED_SHORT_5_5_5_1;
        if (a === THREE.UnsignedShort565Type) return j.UNSIGNED_SHORT_5_6_5;
        if (a === THREE.ByteType) return j.BYTE;
        if (a === THREE.ShortType) return j.SHORT;
        if (a === THREE.UnsignedShortType) return j.UNSIGNED_SHORT;
        if (a === THREE.IntType) return j.INT;
        if (a === THREE.UnsignedIntType) return j.UNSIGNED_INT;
        if (a === THREE.FloatType) return j.FLOAT;
        if (a === THREE.AlphaFormat) return j.ALPHA;
        if (a === THREE.RGBFormat) return j.RGB;
        if (a === THREE.RGBAFormat) return j.RGBA;
        if (a === THREE.LuminanceFormat) return j.LUMINANCE;
        if (a === THREE.LuminanceAlphaFormat) return j.LUMINANCE_ALPHA;
        if (a === THREE.AddEquation) return j.FUNC_ADD;
        if (a === THREE.SubtractEquation) return j.FUNC_SUBTRACT;
        if (a === THREE.ReverseSubtractEquation) return j.FUNC_REVERSE_SUBTRACT;
        if (a === THREE.ZeroFactor) return j.ZERO;
        if (a === THREE.OneFactor) return j.ONE;
        if (a === THREE.SrcColorFactor) return j.SRC_COLOR;
        if (a === THREE.OneMinusSrcColorFactor) return j.ONE_MINUS_SRC_COLOR;
        if (a === THREE.SrcAlphaFactor) return j.SRC_ALPHA;
        if (a === THREE.OneMinusSrcAlphaFactor) return j.ONE_MINUS_SRC_ALPHA;
        if (a === THREE.DstAlphaFactor) return j.DST_ALPHA;
        if (a === THREE.OneMinusDstAlphaFactor) return j.ONE_MINUS_DST_ALPHA;
        if (a === THREE.DstColorFactor) return j.DST_COLOR;
        if (a === THREE.OneMinusDstColorFactor) return j.ONE_MINUS_DST_COLOR;
        if (a === THREE.SrcAlphaSaturateFactor) return j.SRC_ALPHA_SATURATE;
        if (void 0 !== Fa) {
            if (a === THREE.RGB_S3TC_DXT1_Format) return Fa.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT1_Format) return Fa.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT3_Format) return Fa.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (a === THREE.RGBA_S3TC_DXT5_Format) return Fa.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        return 0;
    }
    console.log("THREE.WebGLRenderer", THREE.REVISION);
    var a = a || {},
        G = void 0 !== a.canvas ? a.canvas : document.createElement("canvas"),
        Q = void 0 !== a.precision ? a.precision : "highp",
        J = void 0 !== a.alpha ? a.alpha : !0,
        ca = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,
        oa = void 0 !== a.antialias ? a.antialias : !1,
        pa = void 0 !== a.stencil ? a.stencil : !0,
        N = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,
        M = new THREE.Color(0),
        R = 0;
    this.domElement = G;
    this.context = null;
    this.devicePixelRatio = void 0 !== a.devicePixelRatio ? a.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1;
    this.autoUpdateObjects = this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
    this.shadowMapEnabled = this.physicallyBasedShading = this.gammaOutput = this.gammaInput = !1;
    this.shadowMapAutoUpdate = !0;
    this.shadowMapType = THREE.PCFShadowMap;
    this.shadowMapCullFace = THREE.CullFaceFront;
    this.shadowMapCascade = this.shadowMapDebug = !1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    this.autoScaleCubemaps = !0;
    this.renderPluginsPre = [];
    this.renderPluginsPost = [];
    this.info = {
        memory: {
            programs: 0,
            geometries: 0,
            textures: 0
        },
        render: {
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        }
    };
    var K = this,
        da = [],
        Aa = 0,
        Ca = null,
        ba = null,
        Ba = -1,
        $ = null,
        ea = null,
        V = 0,
        P = 0,
        Y = -1,
        U = -1,
        ka = -1,
        ta = -1,
        ia = -1,
        La = -1,
        Ga = -1,
        fa = -1,
        Ea = null,
        Ta = null,
        Pa = null,
        xa = null,
        cb = 0,
        db = 0,
        ob = 0,
        pb = 0,
        qb = 0,
        eb = 0,
        Ha = {},
        la = new THREE.Frustum,
        ra = new THREE.Matrix4,
        fb = new THREE.Matrix4,
        sa = new THREE.Vector3,
        ga = new THREE.Vector3,
        ua = !0,
        Oa = {
            ambient: [0, 0, 0],
            directional: {
                length: 0,
                colors: [],
                positions: []
            },
            point: {
                length: 0,
                colors: [],
                positions: [],
                distances: []
            },
            spot: {
                length: 0,
                colors: [],
                positions: [],
                distances: [],
                directions: [],
                anglesCos: [],
                exponents: []
            },
            hemi: {
                length: 0,
                skyColors: [],
                groundColors: [],
                positions: []
            }
        },
        j, Na, va, wa, Fa;
    try {
        var Qa = {
            alpha: J,
            premultipliedAlpha: ca,
            antialias: oa,
            stencil: pa,
            preserveDrawingBuffer: N
        };
        j = G.getContext("webgl", Qa) || G.getContext("experimental-webgl", Qa);
        if (null === j) throw "Error creating WebGL context."
    } catch (Zb) {
        console.error(Zb)
    }
    Na = j.getExtension("OES_texture_float");
    j.getExtension("OES_texture_float_linear");
    va = j.getExtension("OES_standard_derivatives");
    wa = j.getExtension("EXT_texture_filter_anisotropic") || j.getExtension("MOZ_EXT_texture_filter_anisotropic") || j.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
    Fa = j.getExtension("WEBGL_compressed_texture_s3tc") || j.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || j.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
    Na || console.log("THREE.WebGLRenderer: Float textures not supported.");
    va || console.log("THREE.WebGLRenderer: Standard derivatives not supported.");
    wa || console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported.");
    Fa || console.log("THREE.WebGLRenderer: S3TC compressed textures not supported.");
    void 0 === j.getShaderPrecisionFormat && (j.getShaderPrecisionFormat = function () {
        return {
            rangeMin: 1,
            rangeMax: 1,
            precision: 1
        }
    });
    j.clearColor(0, 0, 0, 1);
    j.clearDepth(1);
    j.clearStencil(0);
    j.enable(j.DEPTH_TEST);
    j.depthFunc(j.LEQUAL);
    j.frontFace(j.CCW);
    j.cullFace(j.BACK);
    j.enable(j.CULL_FACE);
    j.enable(j.BLEND);
    j.blendEquation(j.FUNC_ADD);
    j.blendFunc(j.SRC_ALPHA, j.ONE_MINUS_SRC_ALPHA);
    j.clearColor(M.r, M.g, M.b, R);
    this.context = j;
    var Nb = j.getParameter(j.MAX_TEXTURE_IMAGE_UNITS),
        $b = j.getParameter(j.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    j.getParameter(j.MAX_TEXTURE_SIZE);
    var ac = j.getParameter(j.MAX_CUBE_MAP_TEXTURE_SIZE),
        Ob = wa ? j.getParameter(wa.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
        Cb = 0 < $b,
        zb = Cb && Na;
    Fa && j.getParameter(j.COMPRESSED_TEXTURE_FORMATS);
    var bc = j.getShaderPrecisionFormat(j.VERTEX_SHADER, j.HIGH_FLOAT),
        cc = j.getShaderPrecisionFormat(j.VERTEX_SHADER, j.MEDIUM_FLOAT);
    j.getShaderPrecisionFormat(j.VERTEX_SHADER, j.LOW_FLOAT);
    var qc = j.getShaderPrecisionFormat(j.FRAGMENT_SHADER, j.HIGH_FLOAT),
        rc = j.getShaderPrecisionFormat(j.FRAGMENT_SHADER, j.MEDIUM_FLOAT);
    j.getShaderPrecisionFormat(j.FRAGMENT_SHADER, j.LOW_FLOAT);
    j.getShaderPrecisionFormat(j.VERTEX_SHADER, j.HIGH_INT);
    j.getShaderPrecisionFormat(j.VERTEX_SHADER, j.MEDIUM_INT);
    j.getShaderPrecisionFormat(j.VERTEX_SHADER, j.LOW_INT);
    j.getShaderPrecisionFormat(j.FRAGMENT_SHADER, j.HIGH_INT);
    j.getShaderPrecisionFormat(j.FRAGMENT_SHADER, j.MEDIUM_INT);
    j.getShaderPrecisionFormat(j.FRAGMENT_SHADER, j.LOW_INT);
    var sc = 0 < bc.precision && 0 < qc.precision,
        Pb = 0 < cc.precision && 0 < rc.precision;
    "highp" === Q && !sc && (Pb ? (Q = "mediump", console.warn("WebGLRenderer: highp not supported, using mediump")) : (Q = "lowp", console.warn("WebGLRenderer: highp and mediump not supported, using lowp")));
    "mediump" === Q && !Pb && (Q = "lowp", console.warn("WebGLRenderer: mediump not supported, using lowp"));
    this.getContext = function () {
        return j
    };
    this.supportsVertexTextures = function () {
        return Cb
    };
    this.supportsFloatTextures = function () {
        return Na
    };
    this.supportsStandardDerivatives = function () {
        return va
    };
    this.supportsCompressedTextureS3TC = function () {
        return Fa
    };
    this.getMaxAnisotropy = function () {
        return Ob
    };
    this.getPrecision = function () {
        return Q
    };
    this.setSize = function (a, b, c) {
        G.width = a * this.devicePixelRatio;
        G.height = b * this.devicePixelRatio;
        1 !== this.devicePixelRatio && !1 !== c && (G.style.width = a + "px", G.style.height = b + "px");
        this.setViewport(0, 0, G.width, G.height)
    };
    this.setViewport = function (a, b, c, d) {
        cb = void 0 !== a ? a : 0;
        db = void 0 !== b ? b : 0;
        ob = void 0 !== c ? c : G.width;
        pb = void 0 !== d ? d : G.height;
        j.viewport(cb, db, ob, pb)
    };
    this.setScissor = function (a, b, c, d) {
        j.scissor(a, b, c, d)
    };
    this.enableScissorTest = function (a) {
        a ? j.enable(j.SCISSOR_TEST) : j.disable(j.SCISSOR_TEST)
    };
    this.setClearColor = function (a, b) {
        M.set(a);
        R = void 0 !== b ? b : 1;
        j.clearColor(M.r, M.g, M.b, R)
    };
    this.setClearColorHex = function (a, b) {
        console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.");
        this.setClearColor(a, b)
    };
    this.getClearColor = function () {
        return M
    };
    this.getClearAlpha = function () {
        return R
    };
    this.clear = function (a, b, c) {
        var d = 0;
        if (void 0 === a || a) d |= j.COLOR_BUFFER_BIT;
        if (void 0 === b || b) d |= j.DEPTH_BUFFER_BIT;
        if (void 0 === c || c) d |= j.STENCIL_BUFFER_BIT;
        j.clear(d)
    };
    this.clearTarget = function (a, b, c, d) {
        this.setRenderTarget(a);
        this.clear(b, c, d)
    };
    this.addPostPlugin = function (a) {
        a.init(this);
        this.renderPluginsPost.push(a)
    };
    this.addPrePlugin = function (a) {
        a.init(this);
        this.renderPluginsPre.push(a)
    };
    this.updateShadowMap = function (a, b) {
        Ca = null;
        Ba = $ = fa = Ga = ka = -1;
        ua = !0;
        U = Y = -1;
        this.shadowMapPlugin.update(a, b)
    };
    var Db = function (a) {
            a = a.target;
            a.removeEventListener("dispose", Db);
            a.__webglInit = void 0;
            if (a instanceof THREE.BufferGeometry) {
                var b = a.attributes,
                    c;
                for (c in b) void 0 !== b[c].buffer && j.deleteBuffer(b[c].buffer);
                K.info.memory.geometries--
            } else if (void 0 !== a.geometryGroups)
                for (b in a.geometryGroups) {
                    c = a.geometryGroups[b];
                    if (void 0 !== c.numMorphTargets)
                        for (var d = 0, e = c.numMorphTargets; d < e; d++) j.deleteBuffer(c.__webglMorphTargetsBuffers[d]);
                    if (void 0 !== c.numMorphNormals) {
                        d = 0;
                        for (e = c.numMorphNormals; d < e; d++) j.deleteBuffer(c.__webglMorphNormalsBuffers[d])
                    }
                    Ib(c)
                } else Ib(a)
        },
        Eb = function (a) {
            a = a.target;
            a.removeEventListener("dispose", Eb);
            a.image && a.image.__webglTextureCube ? j.deleteTexture(a.image.__webglTextureCube) : a.__webglInit && (a.__webglInit = !1, j.deleteTexture(a.__webglTexture));
            K.info.memory.textures--
        },
        Fb = function (a) {
            a = a.target;
            a.removeEventListener("dispose", Fb);
            if (a && a.__webglTexture)
                if (j.deleteTexture(a.__webglTexture), a instanceof THREE.WebGLRenderTargetCube)
                    for (var b = 0; 6 > b; b++) j.deleteFramebuffer(a.__webglFramebuffer[b]), j.deleteRenderbuffer(a.__webglRenderbuffer[b]);
                else j.deleteFramebuffer(a.__webglFramebuffer), j.deleteRenderbuffer(a.__webglRenderbuffer);
            K.info.memory.textures--
        },
        Gb = function (a) {
            a = a.target;
            a.removeEventListener("dispose", Gb);
            Hb(a)
        },
        Ib = function (a) {
            void 0 !== a.__webglVertexBuffer && j.deleteBuffer(a.__webglVertexBuffer);
            void 0 !== a.__webglNormalBuffer && j.deleteBuffer(a.__webglNormalBuffer);
            void 0 !== a.__webglTangentBuffer && j.deleteBuffer(a.__webglTangentBuffer);
            void 0 !== a.__webglColorBuffer && j.deleteBuffer(a.__webglColorBuffer);
            void 0 !== a.__webglUVBuffer && j.deleteBuffer(a.__webglUVBuffer);
            void 0 !== a.__webglUV2Buffer && j.deleteBuffer(a.__webglUV2Buffer);
            void 0 !== a.__webglSkinIndicesBuffer && j.deleteBuffer(a.__webglSkinIndicesBuffer);
            void 0 !== a.__webglSkinWeightsBuffer && j.deleteBuffer(a.__webglSkinWeightsBuffer);
            void 0 !== a.__webglFaceBuffer && j.deleteBuffer(a.__webglFaceBuffer);
            void 0 !== a.__webglLineBuffer && j.deleteBuffer(a.__webglLineBuffer);
            void 0 !== a.__webglLineDistanceBuffer && j.deleteBuffer(a.__webglLineDistanceBuffer);
            if (void 0 !== a.__webglCustomAttributesList)
                for (var b in a.__webglCustomAttributesList) j.deleteBuffer(a.__webglCustomAttributesList[b].buffer);
            K.info.memory.geometries--
        },
        Hb = function (a) {
            var b = a.program;
            if (void 0 !== b) {
                a.program = void 0;
                var c, d, e = !1,
                    a = 0;
                for (c = da.length; a < c; a++)
                    if (d = da[a], d.program === b) {
                        d.usedTimes--;
                        0 === d.usedTimes && (e = !0);
                        break
                    }
                if (!0 === e) {
                    e = [];
                    a = 0;
                    for (c = da.length; a < c; a++) d = da[a], d.program !== b && e.push(d);
                    da = e;
                    j.deleteProgram(b);
                    K.info.memory.programs--
                }
            }
        };
    this.renderBufferImmediate = function (a, b, c) {
        a.hasPositions && !a.__webglVertexBuffer && (a.__webglVertexBuffer = j.createBuffer());
        a.hasNormals && !a.__webglNormalBuffer && (a.__webglNormalBuffer = j.createBuffer());
        a.hasUvs && !a.__webglUvBuffer && (a.__webglUvBuffer = j.createBuffer());
        a.hasColors && !a.__webglColorBuffer && (a.__webglColorBuffer = j.createBuffer());
        a.hasPositions && (j.bindBuffer(j.ARRAY_BUFFER, a.__webglVertexBuffer), j.bufferData(j.ARRAY_BUFFER, a.positionArray, j.DYNAMIC_DRAW), j.enableVertexAttribArray(b.attributes.position), j.vertexAttribPointer(b.attributes.position, 3, j.FLOAT, !1, 0, 0));
        if (a.hasNormals) {
            j.bindBuffer(j.ARRAY_BUFFER, a.__webglNormalBuffer);
            if (c.shading === THREE.FlatShading) {
                var d, e, f, h, g, i, k, l, m, p, n, q = 3 * a.count;
                for (n = 0; n < q; n += 9) p = a.normalArray, d = p[n], e = p[n + 1], f = p[n + 2], h = p[n + 3], i = p[n + 4], l = p[n + 5], g = p[n + 6], k = p[n + 7], m = p[n + 8], d = (d + h + g) / 3, e = (e + i + k) / 3, f = (f + l + m) / 3, p[n] = d, p[n + 1] = e, p[n + 2] = f, p[n + 3] = d, p[n + 4] = e, p[n + 5] = f, p[n + 6] = d, p[n + 7] = e, p[n + 8] = f
            }
            j.bufferData(j.ARRAY_BUFFER, a.normalArray, j.DYNAMIC_DRAW);
            j.enableVertexAttribArray(b.attributes.normal);
            j.vertexAttribPointer(b.attributes.normal, 3, j.FLOAT, !1, 0, 0)
        }
        a.hasUvs && c.map && (j.bindBuffer(j.ARRAY_BUFFER, a.__webglUvBuffer), j.bufferData(j.ARRAY_BUFFER, a.uvArray, j.DYNAMIC_DRAW), j.enableVertexAttribArray(b.attributes.uv), j.vertexAttribPointer(b.attributes.uv, 2, j.FLOAT, !1, 0, 0));
        a.hasColors && c.vertexColors !== THREE.NoColors && (j.bindBuffer(j.ARRAY_BUFFER, a.__webglColorBuffer), j.bufferData(j.ARRAY_BUFFER, a.colorArray, j.DYNAMIC_DRAW), j.enableVertexAttribArray(b.attributes.color), j.vertexAttribPointer(b.attributes.color, 3, j.FLOAT, !1, 0, 0));
        j.drawArrays(j.TRIANGLES, 0, a.count);
        a.count = 0
    };
    this.renderBufferDirect = function (a, b, c, d, e, f) {
        if (!1 !== d.visible) {
            var i, k, l, m;
            i = E(a, b, c, d, f);
            b = i.attributes;
            a = e.attributes;
            c = !1;
            i = 16777215 * e.id + 2 * i.id + (d.wireframe ? 1 : 0);
            i !== $ && ($ = i, c = !0);
            c && g();
            if (f instanceof THREE.Mesh)
                if (f = a.index) {
                    e = e.offsets;
                    1 < e.length && (c = !0);
                    for (var p = 0, n = e.length; p < n; p++) {
                        var q = e[p].index;
                        if (c) {
                            for (k in b) l = b[k], i = a[k], 0 <= l && (i ? (m = i.itemSize, j.bindBuffer(j.ARRAY_BUFFER, i.buffer), h(l), j.vertexAttribPointer(l, m, j.FLOAT, !1, 0, 4 * q * m)) : d.defaultAttributeValues && (2 === d.defaultAttributeValues[k].length ? j.vertexAttrib2fv(l, d.defaultAttributeValues[k]) : 3 === d.defaultAttributeValues[k].length && j.vertexAttrib3fv(l, d.defaultAttributeValues[k])));
                            j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, f.buffer)
                        }
                        j.drawElements(j.TRIANGLES, e[p].count, j.UNSIGNED_SHORT, 2 * e[p].start);
                        K.info.render.calls++;
                        K.info.render.vertices += e[p].count;
                        K.info.render.faces += e[p].count / 3
                    }
                } else {
                    if (c)
                        for (k in b) "index" !== k && (l = b[k], i = a[k], 0 <= l && (i ? (m = i.itemSize, j.bindBuffer(j.ARRAY_BUFFER, i.buffer), h(l), j.vertexAttribPointer(l, m, j.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && d.defaultAttributeValues[k] && (2 === d.defaultAttributeValues[k].length ? j.vertexAttrib2fv(l, d.defaultAttributeValues[k]) : 3 === d.defaultAttributeValues[k].length && j.vertexAttrib3fv(l, d.defaultAttributeValues[k]))));
                    d = e.attributes.position;
                    j.drawArrays(j.TRIANGLES, 0, d.numItems / 3);
                    K.info.render.calls++;
                    K.info.render.vertices += d.numItems / 3;
                    K.info.render.faces += d.numItems / 3 / 3
                } else if (f instanceof THREE.ParticleSystem) {
                if (c) {
                    for (k in b) l = b[k], i = a[k], 0 <= l && (i ? (m = i.itemSize, j.bindBuffer(j.ARRAY_BUFFER, i.buffer), h(l), j.vertexAttribPointer(l, m, j.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && d.defaultAttributeValues[k] && (2 === d.defaultAttributeValues[k].length ? j.vertexAttrib2fv(l, d.defaultAttributeValues[k]) : 3 === d.defaultAttributeValues[k].length && j.vertexAttrib3fv(l, d.defaultAttributeValues[k])));
                    d = a.position;
                    j.drawArrays(j.POINTS, 0, d.numItems / 3);
                    K.info.render.calls++;
                    K.info.render.points += d.numItems / 3
                }
            } else if (f instanceof THREE.Line && c) {
                for (k in b) l = b[k], i = a[k], 0 <= l && (i ? (m = i.itemSize, j.bindBuffer(j.ARRAY_BUFFER, i.buffer), h(l), j.vertexAttribPointer(l, m, j.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && d.defaultAttributeValues[k] && (2 === d.defaultAttributeValues[k].length ? j.vertexAttrib2fv(l, d.defaultAttributeValues[k]) : 3 === d.defaultAttributeValues[k].length && j.vertexAttrib3fv(l, d.defaultAttributeValues[k])));
                k = f.type === THREE.LineStrip ? j.LINE_STRIP : j.LINES;
                A(d.linewidth);
                d = a.position;
                j.drawArrays(k, 0, d.numItems / 3);
                K.info.render.calls++;
                K.info.render.points += d.numItems
            }
        }
    };
    this.renderBuffer = function (a, b, c, d, e, f) {
        if (!1 !== d.visible) {
            var i, l, c = E(a, b, c, d, f),
                a = c.attributes,
                b = !1,
                c = 16777215 * e.id + 2 * c.id + (d.wireframe ? 1 : 0);
            c !== $ && ($ = c, b = !0);
            b && g();
            if (!d.morphTargets && 0 <= a.position) b && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglVertexBuffer), h(a.position), j.vertexAttribPointer(a.position, 3, j.FLOAT, !1, 0, 0));
            else if (f.morphTargetBase) {
                c = d.program.attributes; - 1 !== f.morphTargetBase && 0 <= c.position ? (j.bindBuffer(j.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[f.morphTargetBase]), h(c.position), j.vertexAttribPointer(c.position, 3, j.FLOAT, !1, 0, 0)) : 0 <= c.position && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglVertexBuffer), h(c.position), j.vertexAttribPointer(c.position, 3, j.FLOAT, !1, 0, 0));
                if (f.morphTargetForcedOrder.length) {
                    var m = 0;
                    l = f.morphTargetForcedOrder;
                    for (i = f.morphTargetInfluences; m < d.numSupportedMorphTargets && m < l.length;) 0 <= c["morphTarget" + m] && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[l[m]]), h(c["morphTarget" + m]), j.vertexAttribPointer(c["morphTarget" + m], 3, j.FLOAT, !1, 0, 0)), 0 <= c["morphNormal" + m] && d.morphNormals && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[l[m]]), h(c["morphNormal" + m]), j.vertexAttribPointer(c["morphNormal" + m], 3, j.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[m] = i[l[m]], m++
                } else {
                    l = [];
                    i = f.morphTargetInfluences;
                    var p, n = i.length;
                    for (p = 0; p < n; p++) m = i[p], 0 < m && l.push([m, p]);
                    l.length > d.numSupportedMorphTargets ? (l.sort(k), l.length = d.numSupportedMorphTargets) : l.length > d.numSupportedMorphNormals ? l.sort(k) : 0 === l.length && l.push([0, 0]);
                    for (m = 0; m < d.numSupportedMorphTargets;) l[m] ? (p = l[m][1], 0 <= c["morphTarget" + m] && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[p]), h(c["morphTarget" + m]), j.vertexAttribPointer(c["morphTarget" + m], 3, j.FLOAT, !1, 0, 0)), 0 <= c["morphNormal" + m] && d.morphNormals && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[p]), h(c["morphNormal" + m]), j.vertexAttribPointer(c["morphNormal" + m], 3, j.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[m] = i[p]) : f.__webglMorphTargetInfluences[m] = 0, m++
                }
                null !== d.program.uniforms.morphTargetInfluences && j.uniform1fv(d.program.uniforms.morphTargetInfluences, f.__webglMorphTargetInfluences)
            }
            if (b) {
                if (e.__webglCustomAttributesList) {
                    i = 0;
                    for (l = e.__webglCustomAttributesList.length; i < l; i++) c = e.__webglCustomAttributesList[i], 0 <= a[c.buffer.belongsToAttribute] && (j.bindBuffer(j.ARRAY_BUFFER, c.buffer), h(a[c.buffer.belongsToAttribute]), j.vertexAttribPointer(a[c.buffer.belongsToAttribute], c.size, j.FLOAT, !1, 0, 0))
                }
                0 <= a.color && (0 < f.geometry.colors.length || 0 < f.geometry.faces.length ? (j.bindBuffer(j.ARRAY_BUFFER, e.__webglColorBuffer), h(a.color), j.vertexAttribPointer(a.color, 3, j.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && j.vertexAttrib3fv(a.color, d.defaultAttributeValues.color));
                0 <= a.normal && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglNormalBuffer), h(a.normal), j.vertexAttribPointer(a.normal, 3, j.FLOAT, !1, 0, 0));
                0 <= a.tangent && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglTangentBuffer), h(a.tangent), j.vertexAttribPointer(a.tangent, 4, j.FLOAT, !1, 0, 0));
                0 <= a.uv && (f.geometry.faceVertexUvs[0] ? (j.bindBuffer(j.ARRAY_BUFFER, e.__webglUVBuffer), h(a.uv), j.vertexAttribPointer(a.uv, 2, j.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && j.vertexAttrib2fv(a.uv, d.defaultAttributeValues.uv));
                0 <= a.uv2 && (f.geometry.faceVertexUvs[1] ? (j.bindBuffer(j.ARRAY_BUFFER, e.__webglUV2Buffer), h(a.uv2), j.vertexAttribPointer(a.uv2, 2, j.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && j.vertexAttrib2fv(a.uv2, d.defaultAttributeValues.uv2));
                d.skinning && 0 <= a.skinIndex && 0 <= a.skinWeight && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglSkinIndicesBuffer), h(a.skinIndex), j.vertexAttribPointer(a.skinIndex, 4, j.FLOAT, !1, 0, 0), j.bindBuffer(j.ARRAY_BUFFER, e.__webglSkinWeightsBuffer), h(a.skinWeight), j.vertexAttribPointer(a.skinWeight, 4, j.FLOAT, !1, 0, 0));
                0 <= a.lineDistance && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglLineDistanceBuffer), h(a.lineDistance), j.vertexAttribPointer(a.lineDistance, 1, j.FLOAT, !1, 0, 0))
            }
            f instanceof THREE.Mesh ? (d.wireframe ? (A(d.wireframeLinewidth), b && j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer), j.drawElements(j.LINES, e.__webglLineCount, j.UNSIGNED_SHORT, 0)) : (b && j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), j.drawElements(j.TRIANGLES, e.__webglFaceCount, j.UNSIGNED_SHORT, 0)), K.info.render.calls++, K.info.render.vertices += e.__webglFaceCount, K.info.render.faces += e.__webglFaceCount / 3) : f instanceof THREE.Line ? (f = f.type === THREE.LineStrip ? j.LINE_STRIP : j.LINES, A(d.linewidth), j.drawArrays(f, 0, e.__webglLineCount), K.info.render.calls++) : f instanceof THREE.ParticleSystem && (j.drawArrays(j.POINTS, 0, e.__webglParticleCount), K.info.render.calls++, K.info.render.points += e.__webglParticleCount)
        }
    };
    this.render = function (a, b, c, d) {
        if (!1 === b instanceof THREE.Camera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        else {
            var e, f, h, g, k = a.__lights,
                n = a.fog;
            Ba = -1;
            ua = !0;
            !0 === a.autoUpdate && a.updateMatrixWorld();
            void 0 === b.parent && b.updateMatrixWorld();
            b.matrixWorldInverse.getInverse(b.matrixWorld);
            ra.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
            la.setFromMatrix(ra);
            this.autoUpdateObjects && this.initWebGLObjects(a);
            m(this.renderPluginsPre, a, b);
            K.info.render.calls = 0;
            K.info.render.vertices = 0;
            K.info.render.faces = 0;
            K.info.render.points = 0;
            this.setRenderTarget(c);
            (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
            g = a.__webglObjects;
            d = 0;
            for (e = g.length; d < e; d++)
                if (f = g[d], h = f.object, f.id = d, f.render = !1, h.visible && (!(h instanceof THREE.Mesh || h instanceof THREE.ParticleSystem) || !h.frustumCulled || la.intersectsObject(h))) {
                    var q = h;
                    q._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, q.matrixWorld);
                    q._normalMatrix.getNormalMatrix(q._modelViewMatrix);
                    var q = f,
                        s = q.buffer,
                        r = void 0,
                        t = r = void 0,
                        t = q.object.material;
                    if (t instanceof THREE.MeshFaceMaterial) r = s.materialIndex, r = t.materials[r], r.transparent ? (q.transparent = r, q.opaque = null) : (q.opaque = r, q.transparent = null);
                    else if (r = t) r.transparent ? (q.transparent = r, q.opaque = null) : (q.opaque = r, q.transparent = null);
                    f.render = !0;
                    !0 === this.sortObjects && (null !== h.renderDepth ? f.z = h.renderDepth : (sa.getPositionFromMatrix(h.matrixWorld), sa.applyProjection(ra), f.z = sa.z))
                }
            this.sortObjects && g.sort(i);
            g = a.__webglObjectsImmediate;
            d = 0;
            for (e = g.length; d < e; d++) f = g[d], h = f.object, h.visible && (h._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, h.matrixWorld), h._normalMatrix.getNormalMatrix(h._modelViewMatrix), h = f.object.material, h.transparent ? (f.transparent = h, f.opaque = null) : (f.opaque = h, f.transparent = null));
            a.overrideMaterial ? (d = a.overrideMaterial, this.setBlending(d.blending, d.blendEquation, d.blendSrc, d.blendDst), this.setDepthTest(d.depthTest), this.setDepthWrite(d.depthWrite), z(d.polygonOffset, d.polygonOffsetFactor, d.polygonOffsetUnits), l(a.__webglObjects, !1, "", b, k, n, !0, d), p(a.__webglObjectsImmediate, "", b, k, n, !1, d)) : (d = null, this.setBlending(THREE.NoBlending), l(a.__webglObjects, !0, "opaque", b, k, n, !1, d), p(a.__webglObjectsImmediate, "opaque", b, k, n, !1, d), l(a.__webglObjects, !1, "transparent", b, k, n, !0, d), p(a.__webglObjectsImmediate, "transparent", b, k, n, !0, d));
            m(this.renderPluginsPost, a, b);
            c && c.generateMipmaps && c.minFilter !== THREE.NearestFilter && c.minFilter !== THREE.LinearFilter && (c instanceof THREE.WebGLRenderTargetCube ? (j.bindTexture(j.TEXTURE_CUBE_MAP, c.__webglTexture), j.generateMipmap(j.TEXTURE_CUBE_MAP), j.bindTexture(j.TEXTURE_CUBE_MAP, null)) : (j.bindTexture(j.TEXTURE_2D, c.__webglTexture), j.generateMipmap(j.TEXTURE_2D), j.bindTexture(j.TEXTURE_2D, null)));
            this.setDepthTest(!0);
            this.setDepthWrite(!0)
        }
    };
    this.renderImmediateObject = function (a, b, c, d, e) {
        var f = E(a, b, c, d, e);
        $ = -1;
        K.setMaterialFaces(d);
        e.immediateRenderCallback ? e.immediateRenderCallback(f, j, la) : e.render(function (a) {
            K.renderBufferImmediate(a, f, d)
        })
    };
    this.initWebGLObjects = function (a) {
        a.__webglObjects || (a.__webglObjects = [], a.__webglObjectsImmediate = [], a.__webglSprites = [], a.__webglFlares = []);
        for (; a.__objectsAdded.length;) r(a.__objectsAdded[0], a), a.__objectsAdded.splice(0, 1);
        for (; a.__objectsRemoved.length;) q(a.__objectsRemoved[0], a), a.__objectsRemoved.splice(0, 1);
        for (var b = 0, h = a.__webglObjects.length; b < h; b++) {
            var g = a.__webglObjects[b].object;
            void 0 === g.__webglInit && (void 0 !== g.__webglActive && q(g, a), r(g, a));
            var i = g,
                l = i.geometry,
                m = void 0,
                p = void 0,
                t = void 0;
            if (l instanceof THREE.BufferGeometry) {
                var u = j.DYNAMIC_DRAW,
                    w = !l.dynamic,
                    v = l.attributes,
                    z = void 0,
                    y = void 0;
                for (z in v) y = v[z], y.needsUpdate && ("index" === z ? (j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, y.buffer), j.bufferData(j.ELEMENT_ARRAY_BUFFER, y.array, u)) : (j.bindBuffer(j.ARRAY_BUFFER, y.buffer), j.bufferData(j.ARRAY_BUFFER, y.array, u)), y.needsUpdate = !1), w && !y.dynamic && (y.array = null)
            } else if (i instanceof THREE.Mesh) {
                for (var E = 0, A = l.geometryGroupsList.length; E < A; E++)
                    if (m = l.geometryGroupsList[E], t = d(i, m), l.buffersNeedUpdate && c(m, i), p = t.attributes && n(t), l.verticesNeedUpdate || l.morphTargetsNeedUpdate || l.elementsNeedUpdate || l.uvsNeedUpdate || l.normalsNeedUpdate || l.colorsNeedUpdate || l.tangentsNeedUpdate || p) {
                        var x = m,
                            B = i,
                            C = j.DYNAMIC_DRAW,
                            F = !l.dynamic,
                            G = t;
                        if (x.__inittedArrays) {
                            var J = e(G),
                                K = G.vertexColors ? G.vertexColors : !1,
                                N = f(G),
                                O = J === THREE.SmoothShading,
                                D = void 0,
                                I = void 0,
                                V = void 0,
                                M = void 0,
                                Q = void 0,
                                U = void 0,
                                ba = void 0,
                                R = void 0,
                                Y = void 0,
                                Aa = void 0,
                                $ = void 0,
                                P = void 0,
                                X = void 0,
                                W = void 0,
                                Ca = void 0,
                                ea = void 0,
                                Ba = void 0,
                                ca = void 0,
                                da = void 0,
                                ia = void 0,
                                fa = void 0,
                                ga = void 0,
                                ka = void 0,
                                la = void 0,
                                oa = void 0,
                                pa = void 0,
                                ta = void 0,
                                ua = void 0,
                                va = void 0,
                                Da = void 0,
                                Ea = void 0,
                                Ga = void 0,
                                Fa = void 0,
                                La = void 0,
                                Ra = void 0,
                                Ha = void 0,
                                wa = void 0,
                                xa = void 0,
                                Pa = void 0,
                                Qa = void 0,
                                ab = 0,
                                bb = 0,
                                Na = 0,
                                Oa = 0,
                                Ta = 0,
                                gb = 0,
                                Sa = 0,
                                tb = 0,
                                Ya = 0,
                                qa = 0,
                                ya = 0,
                                L = 0,
                                Ma = void 0,
                                hb = x.__vertexArray,
                                cb = x.__uvArray,
                                db = x.__uv2Array,
                                vb = x.__normalArray,
                                Ua = x.__tangentArray,
                                ib = x.__colorArray,
                                Va = x.__skinIndexArray,
                                Wa = x.__skinWeightArray,
                                ob = x.__morphTargetsArrays,
                                pb = x.__morphNormalsArrays,
                                qb = x.__webglCustomAttributesList,
                                H = void 0,
                                eb = x.__faceArray,
                                wb = x.__lineArray,
                                Ia = B.geometry,
                                Cb = Ia.elementsNeedUpdate,
                                zb = Ia.uvsNeedUpdate,
                                Eb = Ia.normalsNeedUpdate,
                                Nb = Ia.tangentsNeedUpdate,
                                Ob = Ia.colorsNeedUpdate,
                                Pb = Ia.morphTargetsNeedUpdate,
                                ec = Ia.vertices,
                                aa = x.faces3,
                                jb = Ia.faces,
                                Db = Ia.faceVertexUvs[0],
                                Fb = Ia.faceVertexUvs[1],
                                fc = Ia.skinIndices,
                                Qb = Ia.skinWeights,
                                Rb = Ia.morphTargets,
                                Gb = Ia.morphNormals;
                            if (Ia.verticesNeedUpdate) {
                                D = 0;
                                for (I = aa.length; D < I; D++) M = jb[aa[D]], P = ec[M.a], X = ec[M.b], W = ec[M.c], hb[bb] = P.x, hb[bb + 1] = P.y, hb[bb + 2] = P.z, hb[bb + 3] = X.x, hb[bb + 4] = X.y, hb[bb + 5] = X.z, hb[bb + 6] = W.x, hb[bb + 7] = W.y, hb[bb + 8] = W.z, bb += 9;
                                j.bindBuffer(j.ARRAY_BUFFER, x.__webglVertexBuffer);
                                j.bufferData(j.ARRAY_BUFFER, hb, C)
                            }
                            if (Pb) {
                                Ra = 0;
                                for (Ha = Rb.length; Ra < Ha; Ra++) {
                                    D = ya = 0;
                                    for (I = aa.length; D < I; D++) Pa = aa[D], M = jb[Pa], P = Rb[Ra].vertices[M.a], X = Rb[Ra].vertices[M.b], W = Rb[Ra].vertices[M.c], wa = ob[Ra], wa[ya] = P.x, wa[ya + 1] = P.y, wa[ya + 2] = P.z, wa[ya + 3] = X.x, wa[ya + 4] = X.y, wa[ya + 5] = X.z, wa[ya + 6] = W.x, wa[ya + 7] = W.y, wa[ya + 8] = W.z, G.morphNormals && (O ? (Qa = Gb[Ra].vertexNormals[Pa], ca = Qa.a, da = Qa.b, ia = Qa.c) : ia = da = ca = Gb[Ra].faceNormals[Pa], xa = pb[Ra], xa[ya] = ca.x, xa[ya + 1] = ca.y, xa[ya + 2] = ca.z, xa[ya + 3] = da.x, xa[ya + 4] = da.y, xa[ya + 5] = da.z, xa[ya + 6] = ia.x, xa[ya + 7] = ia.y, xa[ya + 8] = ia.z), ya += 9;
                                    j.bindBuffer(j.ARRAY_BUFFER, x.__webglMorphTargetsBuffers[Ra]);
                                    j.bufferData(j.ARRAY_BUFFER, ob[Ra], C);
                                    G.morphNormals && (j.bindBuffer(j.ARRAY_BUFFER, x.__webglMorphNormalsBuffers[Ra]), j.bufferData(j.ARRAY_BUFFER, pb[Ra], C))
                                }
                            }
                            if (Qb.length) {
                                D = 0;
                                for (I = aa.length; D < I; D++) M = jb[aa[D]], la = Qb[M.a], oa = Qb[M.b], pa = Qb[M.c], Wa[qa] = la.x, Wa[qa + 1] = la.y, Wa[qa + 2] = la.z, Wa[qa + 3] = la.w, Wa[qa + 4] = oa.x, Wa[qa + 5] = oa.y, Wa[qa + 6] = oa.z, Wa[qa + 7] = oa.w, Wa[qa + 8] = pa.x, Wa[qa + 9] = pa.y, Wa[qa + 10] = pa.z, Wa[qa + 11] = pa.w, ta = fc[M.a], ua = fc[M.b], va = fc[M.c], Va[qa] = ta.x, Va[qa + 1] = ta.y, Va[qa + 2] = ta.z, Va[qa + 3] = ta.w, Va[qa + 4] = ua.x, Va[qa + 5] = ua.y, Va[qa + 6] = ua.z, Va[qa + 7] = ua.w, Va[qa + 8] = va.x, Va[qa + 9] = va.y, Va[qa + 10] = va.z, Va[qa + 11] = va.w, qa += 12;
                                0 < qa && (j.bindBuffer(j.ARRAY_BUFFER, x.__webglSkinIndicesBuffer), j.bufferData(j.ARRAY_BUFFER, Va, C), j.bindBuffer(j.ARRAY_BUFFER, x.__webglSkinWeightsBuffer), j.bufferData(j.ARRAY_BUFFER, Wa, C))
                            }
                            if (Ob && K) {
                                D = 0;
                                for (I = aa.length; D < I; D++) M = jb[aa[D]], ba = M.vertexColors, R = M.color, 3 === ba.length && K === THREE.VertexColors ? (fa = ba[0], ga = ba[1], ka = ba[2]) : ka = ga = fa = R, ib[Ya] = fa.r, ib[Ya + 1] = fa.g, ib[Ya + 2] = fa.b, ib[Ya + 3] = ga.r, ib[Ya + 4] = ga.g, ib[Ya + 5] = ga.b, ib[Ya + 6] = ka.r, ib[Ya + 7] = ka.g, ib[Ya + 8] = ka.b, Ya += 9;
                                0 < Ya && (j.bindBuffer(j.ARRAY_BUFFER, x.__webglColorBuffer), j.bufferData(j.ARRAY_BUFFER, ib, C))
                            }
                            if (Nb && Ia.hasTangents) {
                                D = 0;
                                for (I = aa.length; D < I; D++) M = jb[aa[D]], Y = M.vertexTangents, Ca = Y[0], ea = Y[1], Ba = Y[2], Ua[Sa] = Ca.x, Ua[Sa + 1] = Ca.y, Ua[Sa + 2] = Ca.z, Ua[Sa + 3] = Ca.w, Ua[Sa + 4] = ea.x, Ua[Sa + 5] = ea.y, Ua[Sa + 6] = ea.z, Ua[Sa + 7] = ea.w, Ua[Sa + 8] = Ba.x, Ua[Sa + 9] = Ba.y, Ua[Sa + 10] = Ba.z, Ua[Sa + 11] = Ba.w, Sa += 12;
                                j.bindBuffer(j.ARRAY_BUFFER, x.__webglTangentBuffer);
                                j.bufferData(j.ARRAY_BUFFER, Ua, C)
                            }
                            if (Eb && J) {
                                D = 0;
                                for (I = aa.length; D < I; D++)
                                    if (M = jb[aa[D]], Q = M.vertexNormals, U = M.normal, 3 === Q.length && O)
                                        for (Da = 0; 3 > Da; Da++) Ga = Q[Da], vb[gb] = Ga.x, vb[gb + 1] = Ga.y, vb[gb + 2] = Ga.z, gb += 3;
                                    else
                                        for (Da = 0; 3 > Da; Da++) vb[gb] = U.x, vb[gb + 1] = U.y, vb[gb + 2] = U.z, gb += 3;
                                j.bindBuffer(j.ARRAY_BUFFER, x.__webglNormalBuffer);
                                j.bufferData(j.ARRAY_BUFFER, vb, C)
                            }
                            if (zb && Db && N) {
                                D = 0;
                                for (I = aa.length; D < I; D++)
                                    if (V = aa[D], Aa = Db[V], void 0 !== Aa)
                                        for (Da = 0; 3 > Da; Da++) Fa = Aa[Da], cb[Na] = Fa.x, cb[Na + 1] = Fa.y, Na += 2;
                                0 < Na && (j.bindBuffer(j.ARRAY_BUFFER, x.__webglUVBuffer), j.bufferData(j.ARRAY_BUFFER, cb, C))
                            }
                            if (zb && Fb && N) {
                                D = 0;
                                for (I = aa.length; D < I; D++)
                                    if (V = aa[D], $ = Fb[V], void 0 !== $)
                                        for (Da = 0; 3 > Da; Da++) La = $[Da], db[Oa] = La.x, db[Oa + 1] = La.y, Oa += 2;
                                0 < Oa && (j.bindBuffer(j.ARRAY_BUFFER, x.__webglUV2Buffer), j.bufferData(j.ARRAY_BUFFER, db, C))
                            }
                            if (Cb) {
                                D = 0;
                                for (I = aa.length; D < I; D++) eb[Ta] = ab, eb[Ta + 1] = ab + 1, eb[Ta + 2] = ab + 2, Ta += 3, wb[tb] = ab, wb[tb + 1] = ab + 1, wb[tb + 2] = ab, wb[tb + 3] = ab + 2, wb[tb + 4] = ab + 1, wb[tb + 5] = ab + 2, tb += 6, ab += 3;
                                j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, x.__webglFaceBuffer);
                                j.bufferData(j.ELEMENT_ARRAY_BUFFER, eb, C);
                                j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, x.__webglLineBuffer);
                                j.bufferData(j.ELEMENT_ARRAY_BUFFER, wb, C)
                            }
                            if (qb) {
                                Da = 0;
                                for (Ea = qb.length; Da < Ea; Da++)
                                    if (H = qb[Da], H.__original.needsUpdate) {
                                        L = 0;
                                        if (1 === H.size)
                                            if (void 0 === H.boundTo || "vertices" === H.boundTo) {
                                                D = 0;
                                                for (I = aa.length; D < I; D++) M = jb[aa[D]], H.array[L] = H.value[M.a], H.array[L + 1] = H.value[M.b], H.array[L + 2] = H.value[M.c], L += 3
                                            } else {
                                                if ("faces" === H.boundTo) {
                                                    D = 0;
                                                    for (I = aa.length; D < I; D++) Ma = H.value[aa[D]], H.array[L] = Ma, H.array[L + 1] = Ma, H.array[L + 2] = Ma, L += 3
                                                }
                                            } else if (2 === H.size)
                                            if (void 0 === H.boundTo || "vertices" === H.boundTo) {
                                                D = 0;
                                                for (I = aa.length; D < I; D++) M = jb[aa[D]], P = H.value[M.a], X = H.value[M.b], W = H.value[M.c], H.array[L] = P.x, H.array[L + 1] = P.y, H.array[L + 2] = X.x, H.array[L + 3] = X.y, H.array[L + 4] = W.x, H.array[L + 5] = W.y, L += 6
                                            } else {
                                                if ("faces" === H.boundTo) {
                                                    D = 0;
                                                    for (I = aa.length; D < I; D++) W = X = P = Ma = H.value[aa[D]], H.array[L] = P.x, H.array[L + 1] = P.y, H.array[L + 2] = X.x, H.array[L + 3] = X.y, H.array[L + 4] = W.x, H.array[L + 5] = W.y, L += 6
                                                }
                                            } else if (3 === H.size) {
                                            var na;
                                            na = "c" === H.type ? ["r", "g", "b"] : ["x", "y", "z"];
                                            if (void 0 === H.boundTo || "vertices" === H.boundTo) {
                                                D = 0;
                                                for (I = aa.length; D < I; D++) M = jb[aa[D]], P = H.value[M.a], X = H.value[M.b], W = H.value[M.c], H.array[L] = P[na[0]], H.array[L + 1] = P[na[1]], H.array[L + 2] = P[na[2]], H.array[L + 3] = X[na[0]], H.array[L + 4] = X[na[1]], H.array[L + 5] = X[na[2]], H.array[L + 6] = W[na[0]], H.array[L + 7] = W[na[1]], H.array[L + 8] = W[na[2]], L += 9
                                            } else if ("faces" === H.boundTo) {
                                                D = 0;
                                                for (I = aa.length; D < I; D++) W = X = P = Ma = H.value[aa[D]], H.array[L] = P[na[0]], H.array[L + 1] = P[na[1]], H.array[L + 2] = P[na[2]], H.array[L + 3] = X[na[0]], H.array[L + 4] = X[na[1]], H.array[L + 5] = X[na[2]], H.array[L + 6] = W[na[0]], H.array[L + 7] = W[na[1]], H.array[L + 8] = W[na[2]], L += 9
                                            } else if ("faceVertices" === H.boundTo) {
                                                D = 0;
                                                for (I = aa.length; D < I; D++) Ma = H.value[aa[D]], P = Ma[0], X = Ma[1], W = Ma[2], H.array[L] = P[na[0]], H.array[L + 1] = P[na[1]], H.array[L + 2] = P[na[2]], H.array[L + 3] = X[na[0]], H.array[L + 4] = X[na[1]], H.array[L + 5] = X[na[2]], H.array[L + 6] = W[na[0]], H.array[L + 7] = W[na[1]], H.array[L + 8] = W[na[2]], L += 9
                                            }
                                        } else if (4 === H.size)
                                            if (void 0 === H.boundTo || "vertices" === H.boundTo) {
                                                D = 0;
                                                for (I = aa.length; D < I; D++) M = jb[aa[D]], P = H.value[M.a], X = H.value[M.b], W = H.value[M.c], H.array[L] = P.x, H.array[L + 1] = P.y, H.array[L + 2] = P.z, H.array[L + 3] = P.w, H.array[L + 4] = X.x, H.array[L + 5] = X.y, H.array[L + 6] = X.z, H.array[L + 7] = X.w, H.array[L + 8] = W.x, H.array[L + 9] = W.y, H.array[L + 10] = W.z, H.array[L + 11] = W.w, L += 12
                                            } else if ("faces" === H.boundTo) {
                                            D = 0;
                                            for (I = aa.length; D < I; D++) W = X = P = Ma = H.value[aa[D]], H.array[L] = P.x, H.array[L + 1] = P.y, H.array[L + 2] = P.z, H.array[L + 3] = P.w, H.array[L + 4] = X.x, H.array[L + 5] = X.y, H.array[L + 6] = X.z, H.array[L + 7] = X.w, H.array[L + 8] = W.x, H.array[L + 9] = W.y, H.array[L + 10] = W.z, H.array[L + 11] = W.w, L += 12
                                        } else if ("faceVertices" === H.boundTo) {
                                            D = 0;
                                            for (I = aa.length; D < I; D++) Ma = H.value[aa[D]], P = Ma[0], X = Ma[1], W = Ma[2], H.array[L] = P.x, H.array[L + 1] = P.y, H.array[L + 2] = P.z, H.array[L + 3] = P.w, H.array[L + 4] = X.x, H.array[L + 5] = X.y, H.array[L + 6] = X.z, H.array[L + 7] = X.w, H.array[L + 8] = W.x, H.array[L + 9] = W.y, H.array[L + 10] = W.z, H.array[L + 11] = W.w, L += 12
                                        }
                                        j.bindBuffer(j.ARRAY_BUFFER, H.buffer);
                                        j.bufferData(j.ARRAY_BUFFER, H.array, C)
                                    }
                            }
                            F && (delete x.__inittedArrays, delete x.__colorArray, delete x.__normalArray, delete x.__tangentArray, delete x.__uvArray, delete x.__uv2Array, delete x.__faceArray, delete x.__vertexArray, delete x.__lineArray, delete x.__skinIndexArray, delete x.__skinWeightArray)
                        }
                    }
                l.verticesNeedUpdate = !1;
                l.morphTargetsNeedUpdate = !1;
                l.elementsNeedUpdate = !1;
                l.uvsNeedUpdate = !1;
                l.normalsNeedUpdate = !1;
                l.colorsNeedUpdate = !1;
                l.tangentsNeedUpdate = !1;
                l.buffersNeedUpdate = !1;
                t.attributes && s(t)
            } else if (i instanceof THREE.Line) {
                t = d(i, l);
                p = t.attributes && n(t);
                if (l.verticesNeedUpdate || l.colorsNeedUpdate || l.lineDistancesNeedUpdate || p) {
                    var Xa = l,
                        Sb = j.DYNAMIC_DRAW,
                        Jb = void 0,
                        Kb = void 0,
                        Lb = void 0,
                        Tb = void 0,
                        ma = void 0,
                        Ub = void 0,
                        Hb = Xa.vertices,
                        Ib = Xa.colors,
                        kc = Xa.lineDistances,
                        Zb = Hb.length,
                        $b = Ib.length,
                        ac = kc.length,
                        Vb = Xa.__vertexArray,
                        Wb = Xa.__colorArray,
                        lc = Xa.__lineDistanceArray,
                        bc = Xa.colorsNeedUpdate,
                        cc = Xa.lineDistancesNeedUpdate,
                        gc = Xa.__webglCustomAttributesList,
                        Xb = void 0,
                        mc = void 0,
                        za = void 0,
                        Ab = void 0,
                        Ja = void 0,
                        ja = void 0;
                    if (Xa.verticesNeedUpdate) {
                        for (Jb = 0; Jb < Zb; Jb++) Tb = Hb[Jb], ma = 3 * Jb, Vb[ma] = Tb.x, Vb[ma + 1] = Tb.y, Vb[ma + 2] = Tb.z;
                        j.bindBuffer(j.ARRAY_BUFFER, Xa.__webglVertexBuffer);
                        j.bufferData(j.ARRAY_BUFFER, Vb, Sb)
                    }
                    if (bc) {
                        for (Kb = 0; Kb < $b; Kb++) Ub = Ib[Kb], ma = 3 * Kb, Wb[ma] = Ub.r, Wb[ma + 1] = Ub.g, Wb[ma + 2] = Ub.b;
                        j.bindBuffer(j.ARRAY_BUFFER, Xa.__webglColorBuffer);
                        j.bufferData(j.ARRAY_BUFFER, Wb, Sb)
                    }
                    if (cc) {
                        for (Lb = 0; Lb < ac; Lb++) lc[Lb] = kc[Lb];
                        j.bindBuffer(j.ARRAY_BUFFER, Xa.__webglLineDistanceBuffer);
                        j.bufferData(j.ARRAY_BUFFER, lc, Sb)
                    }
                    if (gc) {
                        Xb = 0;
                        for (mc = gc.length; Xb < mc; Xb++)
                            if (ja = gc[Xb], ja.needsUpdate && (void 0 === ja.boundTo || "vertices" === ja.boundTo)) {
                                ma = 0;
                                Ab = ja.value.length;
                                if (1 === ja.size)
                                    for (za = 0; za < Ab; za++) ja.array[za] = ja.value[za];
                                else if (2 === ja.size)
                                    for (za = 0; za < Ab; za++) Ja = ja.value[za], ja.array[ma] = Ja.x, ja.array[ma + 1] = Ja.y, ma += 2;
                                else if (3 === ja.size)
                                    if ("c" === ja.type)
                                        for (za = 0; za < Ab; za++) Ja = ja.value[za], ja.array[ma] = Ja.r, ja.array[ma + 1] = Ja.g, ja.array[ma + 2] = Ja.b, ma += 3;
                                    else
                                        for (za = 0; za < Ab; za++) Ja = ja.value[za], ja.array[ma] = Ja.x, ja.array[ma + 1] = Ja.y, ja.array[ma + 2] = Ja.z, ma += 3;
                                else if (4 === ja.size)
                                    for (za = 0; za < Ab; za++) Ja = ja.value[za], ja.array[ma] = Ja.x, ja.array[ma + 1] = Ja.y, ja.array[ma + 2] = Ja.z, ja.array[ma + 3] = Ja.w, ma += 4;
                                j.bindBuffer(j.ARRAY_BUFFER, ja.buffer);
                                j.bufferData(j.ARRAY_BUFFER, ja.array, Sb)
                            }
                    }
                }
                l.verticesNeedUpdate = !1;
                l.colorsNeedUpdate = !1;
                l.lineDistancesNeedUpdate = !1;
                t.attributes && s(t)
            } else if (i instanceof THREE.ParticleSystem) {
                t = d(i, l);
                p = t.attributes && n(t);
                if (l.verticesNeedUpdate || l.colorsNeedUpdate || i.sortParticles || p) {
                    var kb = l,
                        hc = j.DYNAMIC_DRAW,
                        Mb = i,
                        Ka = void 0,
                        lb = void 0,
                        mb = void 0,
                        T = void 0,
                        nb = void 0,
                        ub = void 0,
                        Yb = kb.vertices,
                        ic = Yb.length,
                        jc = kb.colors,
                        nc = jc.length,
                        xb = kb.__vertexArray,
                        yb = kb.__colorArray,
                        rb = kb.__sortArray,
                        oc = kb.verticesNeedUpdate,
                        pc = kb.colorsNeedUpdate,
                        sb = kb.__webglCustomAttributesList,
                        Za = void 0,
                        Bb = void 0,
                        Z = void 0,
                        $a = void 0,
                        ha = void 0,
                        S = void 0;
                    if (Mb.sortParticles) {
                        fb.copy(ra);
                        fb.multiply(Mb.matrixWorld);
                        for (Ka = 0; Ka < ic; Ka++) mb = Yb[Ka], sa.copy(mb), sa.applyProjection(fb), rb[Ka] = [sa.z, Ka];
                        rb.sort(k);
                        for (Ka = 0; Ka < ic; Ka++) mb = Yb[rb[Ka][1]], T = 3 * Ka, xb[T] = mb.x, xb[T + 1] = mb.y, xb[T + 2] = mb.z;
                        for (lb = 0; lb < nc; lb++) T = 3 * lb, ub = jc[rb[lb][1]], yb[T] = ub.r, yb[T + 1] = ub.g, yb[T + 2] = ub.b;
                        if (sb) {
                            Za = 0;
                            for (Bb = sb.length; Za < Bb; Za++)
                                if (S = sb[Za], void 0 === S.boundTo || "vertices" === S.boundTo)
                                    if (T = 0, $a = S.value.length, 1 === S.size)
                                        for (Z = 0; Z < $a; Z++) nb = rb[Z][1], S.array[Z] = S.value[nb];
                                    else if (2 === S.size)
                                for (Z = 0; Z < $a; Z++) nb = rb[Z][1], ha = S.value[nb], S.array[T] = ha.x, S.array[T + 1] = ha.y, T += 2;
                            else if (3 === S.size)
                                if ("c" === S.type)
                                    for (Z = 0; Z < $a; Z++) nb = rb[Z][1], ha = S.value[nb], S.array[T] = ha.r, S.array[T + 1] = ha.g, S.array[T + 2] = ha.b, T += 3;
                                else
                                    for (Z = 0; Z < $a; Z++) nb = rb[Z][1], ha = S.value[nb], S.array[T] = ha.x, S.array[T + 1] = ha.y, S.array[T + 2] = ha.z, T += 3;
                            else if (4 === S.size)
                                for (Z = 0; Z < $a; Z++) nb = rb[Z][1], ha = S.value[nb], S.array[T] = ha.x, S.array[T + 1] = ha.y, S.array[T + 2] = ha.z, S.array[T + 3] = ha.w, T += 4
                        }
                    } else {
                        if (oc)
                            for (Ka = 0; Ka < ic; Ka++) mb = Yb[Ka], T = 3 * Ka, xb[T] = mb.x, xb[T + 1] = mb.y, xb[T + 2] = mb.z;
                        if (pc)
                            for (lb = 0; lb < nc; lb++) ub = jc[lb], T = 3 * lb, yb[T] = ub.r, yb[T + 1] = ub.g, yb[T + 2] = ub.b;
                        if (sb) {
                            Za = 0;
                            for (Bb = sb.length; Za < Bb; Za++)
                                if (S = sb[Za], S.needsUpdate && (void 0 === S.boundTo || "vertices" === S.boundTo))
                                    if ($a = S.value.length, T = 0, 1 === S.size)
                                        for (Z = 0; Z < $a; Z++) S.array[Z] = S.value[Z];
                                    else if (2 === S.size)
                                for (Z = 0; Z < $a; Z++) ha = S.value[Z], S.array[T] = ha.x, S.array[T + 1] = ha.y, T += 2;
                            else if (3 === S.size)
                                if ("c" === S.type)
                                    for (Z = 0; Z < $a; Z++) ha = S.value[Z], S.array[T] = ha.r, S.array[T + 1] = ha.g, S.array[T + 2] = ha.b, T += 3;
                                else
                                    for (Z = 0; Z < $a; Z++) ha = S.value[Z], S.array[T] = ha.x, S.array[T + 1] = ha.y, S.array[T + 2] = ha.z, T += 3;
                            else if (4 === S.size)
                                for (Z = 0; Z < $a; Z++) ha = S.value[Z], S.array[T] = ha.x, S.array[T + 1] = ha.y, S.array[T + 2] = ha.z, S.array[T + 3] = ha.w, T += 4
                        }
                    } if (oc || Mb.sortParticles) j.bindBuffer(j.ARRAY_BUFFER, kb.__webglVertexBuffer), j.bufferData(j.ARRAY_BUFFER, xb, hc);
                    if (pc || Mb.sortParticles) j.bindBuffer(j.ARRAY_BUFFER, kb.__webglColorBuffer), j.bufferData(j.ARRAY_BUFFER, yb, hc);
                    if (sb) {
                        Za = 0;
                        for (Bb = sb.length; Za < Bb; Za++)
                            if (S = sb[Za], S.needsUpdate || Mb.sortParticles) j.bindBuffer(j.ARRAY_BUFFER, S.buffer), j.bufferData(j.ARRAY_BUFFER, S.array, hc)
                    }
                }
                l.verticesNeedUpdate = !1;
                l.colorsNeedUpdate = !1;
                t.attributes && s(t)
            }
        }
    };
    this.initMaterial = function (a, b, c, d) {
        var e, f, h, g;
        a.addEventListener("dispose", Gb);
        var i, k, l, m, p;
        a instanceof THREE.MeshDepthMaterial ? p = "depth" : a instanceof THREE.MeshNormalMaterial ? p = "normal" : a instanceof THREE.MeshBasicMaterial ? p = "basic" : a instanceof THREE.MeshLambertMaterial ? p = "lambert" : a instanceof THREE.MeshPhongMaterial ? p = "phong" : a instanceof THREE.LineBasicMaterial ? p = "basic" : a instanceof THREE.LineDashedMaterial ? p = "dashed" : a instanceof THREE.ParticleBasicMaterial && (p = "particle_basic");
        if (p) {
            var n = THREE.ShaderLib[p];
            a.uniforms = THREE.UniformsUtils.clone(n.uniforms);
            a.vertexShader = n.vertexShader;
            a.fragmentShader = n.fragmentShader
        }
        var q = e = 0,
            s = 0,
            t = n = 0;
        for (f = b.length; t < f; t++) h = b[t], h.onlyShadow || (h instanceof THREE.DirectionalLight && e++, h instanceof THREE.PointLight && q++, h instanceof THREE.SpotLight && s++, h instanceof THREE.HemisphereLight && n++);
        f = q;
        h = s;
        g = n;
        s = n = 0;
        for (q = b.length; s < q; s++) t = b[s], t.castShadow && (t instanceof THREE.SpotLight && n++, t instanceof THREE.DirectionalLight && !t.shadowCascade && n++);
        m = n;
        zb && d && d.useVertexTexture ? l = 1024 : (b = j.getParameter(j.MAX_VERTEX_UNIFORM_VECTORS), b = Math.floor((b - 20) / 4), void 0 !== d && d instanceof THREE.SkinnedMesh && (b = Math.min(d.bones.length, b), b < d.bones.length && console.warn("WebGLRenderer: too many bones - " + d.bones.length + ", this GPU supports just " + b + " (try OpenGL instead of ANGLE)")), l = b);
        a: {
            var s = a.fragmentShader,
                q = a.vertexShader,
                n = a.uniforms,
                b = a.attributes,
                t = a.defines,
                c = {
                    map: !!a.map,
                    envMap: !!a.envMap,
                    lightMap: !!a.lightMap,
                    bumpMap: !!a.bumpMap,
                    normalMap: !!a.normalMap,
                    specularMap: !!a.specularMap,
                    vertexColors: a.vertexColors,
                    fog: c,
                    useFog: a.fog,
                    fogExp: c instanceof THREE.FogExp2,
                    sizeAttenuation: a.sizeAttenuation,
                    skinning: a.skinning,
                    maxBones: l,
                    useVertexTexture: zb && d && d.useVertexTexture,
                    morphTargets: a.morphTargets,
                    morphNormals: a.morphNormals,
                    maxMorphTargets: this.maxMorphTargets,
                    maxMorphNormals: this.maxMorphNormals,
                    maxDirLights: e,
                    maxPointLights: f,
                    maxSpotLights: h,
                    maxHemiLights: g,
                    maxShadows: m,
                    shadowMapEnabled: this.shadowMapEnabled && d.receiveShadow,
                    shadowMapType: this.shadowMapType,
                    shadowMapDebug: this.shadowMapDebug,
                    shadowMapCascade: this.shadowMapCascade,
                    alphaTest: a.alphaTest,
                    metal: a.metal,
                    perPixel: a.perPixel,
                    wrapAround: a.wrapAround,
                    doubleSided: a.side === THREE.DoubleSide,
                    flipSided: a.side === THREE.BackSide
                },
                d = a.index0AttributeName,
                r, u, w;
            e = [];
            p ? e.push(p) : (e.push(s), e.push(q));
            for (u in t) e.push(u), e.push(t[u]);
            for (r in c) e.push(r), e.push(c[r]);
            p = e.join();
            r = 0;
            for (u = da.length; r < u; r++)
                if (e = da[r], e.code === p) {
                    e.usedTimes++;
                    k = e.program;
                    break a
                }
            r = "SHADOWMAP_TYPE_BASIC";
            c.shadowMapType === THREE.PCFShadowMap ? r = "SHADOWMAP_TYPE_PCF" : c.shadowMapType === THREE.PCFSoftShadowMap && (r = "SHADOWMAP_TYPE_PCF_SOFT");
            u = [];
            for (w in t) e = t[w], !1 !== e && (e = "#define " + w + " " + e, u.push(e));
            e = u.join("\n");
            w = j.createProgram();
            u = ["precision " + Q + " float;", "precision " + Q + " int;", e, Cb ? "#define VERTEX_TEXTURES" : "", K.gammaInput ? "#define GAMMA_INPUT" : "", K.gammaOutput ? "#define GAMMA_OUTPUT" : "", K.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "", "#define MAX_DIR_LIGHTS " + c.maxDirLights, "#define MAX_POINT_LIGHTS " + c.maxPointLights, "#define MAX_SPOT_LIGHTS " + c.maxSpotLights, "#define MAX_HEMI_LIGHTS " + c.maxHemiLights, "#define MAX_SHADOWS " + c.maxShadows, "#define MAX_BONES " + c.maxBones, c.map ? "#define USE_MAP" : "", c.envMap ? "#define USE_ENVMAP" : "", c.lightMap ? "#define USE_LIGHTMAP" : "", c.bumpMap ? "#define USE_BUMPMAP" : "", c.normalMap ? "#define USE_NORMALMAP" : "", c.specularMap ? "#define USE_SPECULARMAP" : "", c.vertexColors ? "#define USE_COLOR" : "", c.skinning ? "#define USE_SKINNING" : "", c.useVertexTexture ? "#define BONE_TEXTURE" : "", c.morphTargets ? "#define USE_MORPHTARGETS" : "", c.morphNormals ? "#define USE_MORPHNORMALS" : "", c.perPixel ? "#define PHONG_PER_PIXEL" : "", c.wrapAround ? "#define WRAP_AROUND" : "", c.doubleSided ? "#define DOUBLE_SIDED" : "", c.flipSided ? "#define FLIP_SIDED" : "", c.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", c.shadowMapEnabled ? "#define " + r : "", c.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", c.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", c.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\nattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\nattribute vec3 morphTarget0;\nattribute vec3 morphTarget1;\nattribute vec3 morphTarget2;\nattribute vec3 morphTarget3;\n#ifdef USE_MORPHNORMALS\nattribute vec3 morphNormal0;\nattribute vec3 morphNormal1;\nattribute vec3 morphNormal2;\nattribute vec3 morphNormal3;\n#else\nattribute vec3 morphTarget4;\nattribute vec3 morphTarget5;\nattribute vec3 morphTarget6;\nattribute vec3 morphTarget7;\n#endif\n#endif\n#ifdef USE_SKINNING\nattribute vec4 skinIndex;\nattribute vec4 skinWeight;\n#endif\n"].join("\n");
            r = ["precision " + Q + " float;", "precision " + Q + " int;", c.bumpMap || c.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", e, "#define MAX_DIR_LIGHTS " + c.maxDirLights, "#define MAX_POINT_LIGHTS " + c.maxPointLights, "#define MAX_SPOT_LIGHTS " + c.maxSpotLights, "#define MAX_HEMI_LIGHTS " + c.maxHemiLights, "#define MAX_SHADOWS " + c.maxShadows, c.alphaTest ? "#define ALPHATEST " + c.alphaTest : "", K.gammaInput ? "#define GAMMA_INPUT" : "", K.gammaOutput ? "#define GAMMA_OUTPUT" : "", K.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "", c.useFog && c.fog ? "#define USE_FOG" : "", c.useFog && c.fogExp ? "#define FOG_EXP2" : "", c.map ? "#define USE_MAP" : "", c.envMap ? "#define USE_ENVMAP" : "", c.lightMap ? "#define USE_LIGHTMAP" : "", c.bumpMap ? "#define USE_BUMPMAP" : "", c.normalMap ? "#define USE_NORMALMAP" : "", c.specularMap ? "#define USE_SPECULARMAP" : "", c.vertexColors ? "#define USE_COLOR" : "", c.metal ? "#define METAL" : "", c.perPixel ? "#define PHONG_PER_PIXEL" : "", c.wrapAround ? "#define WRAP_AROUND" : "", c.doubleSided ? "#define DOUBLE_SIDED" : "", c.flipSided ? "#define FLIP_SIDED" : "", c.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", c.shadowMapEnabled ? "#define " + r : "", c.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", c.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n");
            u = B("vertex", u + q);
            r = B("fragment", r + s);
            j.attachShader(w, u);
            j.attachShader(w, r);
            d && j.bindAttribLocation(w, 0, d);
            j.linkProgram(w);
            j.getProgramParameter(w, j.LINK_STATUS) || (console.error("Could not initialise shader\nVALIDATE_STATUS: " + j.getProgramParameter(w, j.VALIDATE_STATUS) + ", gl error [" + j.getError() + "]"), console.error("Program Info Log: " + j.getProgramInfoLog(w)));
            j.deleteShader(r);
            j.deleteShader(u);
            w.uniforms = {};
            w.attributes = {};
            var v;
            r = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences".split(" ");
            c.useVertexTexture ? (r.push("boneTexture"), r.push("boneTextureWidth"), r.push("boneTextureHeight")) : r.push("boneGlobalMatrices");
            for (v in n) r.push(v);
            v = r;
            r = 0;
            for (u = v.length; r < u; r++) n = v[r], w.uniforms[n] = j.getUniformLocation(w, n);
            r = "position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" ");
            for (v = 0; v < c.maxMorphTargets; v++) r.push("morphTarget" + v);
            for (v = 0; v < c.maxMorphNormals; v++) r.push("morphNormal" + v);
            for (k in b) r.push(k);
            k = r;
            v = 0;
            for (b = k.length; v < b; v++) r = k[v], w.attributes[r] = j.getAttribLocation(w, r);
            w.id = Aa++;
            da.push({
                program: w,
                code: p,
                usedTimes: 1
            });
            K.info.memory.programs = da.length;
            k = w
        }
        a.program = k;
        v = a.program.attributes;
        if (a.morphTargets) {
            a.numSupportedMorphTargets = 0;
            b = "morphTarget";
            for (k = 0; k < this.maxMorphTargets; k++) w = b + k, 0 <= v[w] && a.numSupportedMorphTargets++
        }
        if (a.morphNormals) {
            a.numSupportedMorphNormals = 0;
            b = "morphNormal";
            for (k = 0; k < this.maxMorphNormals; k++) w = b + k, 0 <= v[w] && a.numSupportedMorphNormals++
        }
        a.uniformsList = [];
        for (i in a.uniforms) a.uniformsList.push([a.uniforms[i], i])
    };
    this.setFaceCulling = function (a, b) {
        a === THREE.CullFaceNone ? j.disable(j.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? j.frontFace(j.CW) : j.frontFace(j.CCW), a === THREE.CullFaceBack ? j.cullFace(j.BACK) : a === THREE.CullFaceFront ? j.cullFace(j.FRONT) : j.cullFace(j.FRONT_AND_BACK), j.enable(j.CULL_FACE))
    };
    this.setMaterialFaces = function (a) {
        var b = a.side === THREE.DoubleSide,
            a = a.side === THREE.BackSide;
        Y !== b && (b ? j.disable(j.CULL_FACE) : j.enable(j.CULL_FACE), Y = b);
        U !== a && (a ? j.frontFace(j.CW) : j.frontFace(j.CCW), U = a)
    };
    this.setDepthTest = function (a) {
        Ga !== a && (a ? j.enable(j.DEPTH_TEST) : j.disable(j.DEPTH_TEST), Ga = a)
    };
    this.setDepthWrite = function (a) {
        fa !== a && (j.depthMask(a), fa = a)
    };
    this.setBlending = function (a, b, c, d) {
        a !== ka && (a === THREE.NoBlending ? j.disable(j.BLEND) : a === THREE.AdditiveBlending ? (j.enable(j.BLEND), j.blendEquation(j.FUNC_ADD), j.blendFunc(j.SRC_ALPHA, j.ONE)) : a === THREE.SubtractiveBlending ? (j.enable(j.BLEND), j.blendEquation(j.FUNC_ADD), j.blendFunc(j.ZERO, j.ONE_MINUS_SRC_COLOR)) : a === THREE.MultiplyBlending ? (j.enable(j.BLEND), j.blendEquation(j.FUNC_ADD), j.blendFunc(j.ZERO, j.SRC_COLOR)) : a === THREE.CustomBlending ? j.enable(j.BLEND) : (j.enable(j.BLEND), j.blendEquationSeparate(j.FUNC_ADD, j.FUNC_ADD), j.blendFuncSeparate(j.SRC_ALPHA, j.ONE_MINUS_SRC_ALPHA, j.ONE, j.ONE_MINUS_SRC_ALPHA)), ka = a);
        if (a === THREE.CustomBlending) {
            if (b !== ta && (j.blendEquation(x(b)), ta = b), c !== ia || d !== La) j.blendFunc(x(c), x(d)), ia = c, La = d
        } else La = ia = ta = null
    };
    this.setTexture = function (a, b) {
        if (a.needsUpdate) {
            a.__webglInit || (a.__webglInit = !0, a.addEventListener("dispose", Eb), a.__webglTexture = j.createTexture(), K.info.memory.textures++);
            j.activeTexture(j.TEXTURE0 + b);
            j.bindTexture(j.TEXTURE_2D, a.__webglTexture);
            j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, a.flipY);
            j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha);
            j.pixelStorei(j.UNPACK_ALIGNMENT, a.unpackAlignment);
            var c = a.image,
                d = 0 === (c.width & c.width - 1) && 0 === (c.height & c.height - 1),
                e = x(a.format),
                f = x(a.type);
            D(j.TEXTURE_2D, a, d);
            var h = a.mipmaps;
            if (a instanceof THREE.DataTexture)
                if (0 < h.length && d) {
                    for (var g = 0, i = h.length; g < i; g++) c = h[g], j.texImage2D(j.TEXTURE_2D, g, e, c.width, c.height, 0, e, f, c.data);
                    a.generateMipmaps = !1
                } else j.texImage2D(j.TEXTURE_2D, 0, e, c.width, c.height, 0, e, f, c.data);
            else if (a instanceof THREE.CompressedTexture) {
                g = 0;
                for (i = h.length; g < i; g++) c = h[g], a.format !== THREE.RGBAFormat ? j.compressedTexImage2D(j.TEXTURE_2D, g, e, c.width, c.height, 0, c.data) : j.texImage2D(j.TEXTURE_2D, g, e, c.width, c.height, 0, e, f, c.data)
            } else if (0 < h.length && d) {
                g = 0;
                for (i = h.length; g < i; g++) c = h[g], j.texImage2D(j.TEXTURE_2D, g, e, e, f, c);
                a.generateMipmaps = !1
            } else j.texImage2D(j.TEXTURE_2D, 0, e, e, f, a.image);
            a.generateMipmaps && d && j.generateMipmap(j.TEXTURE_2D);
            a.needsUpdate = !1;
            if (a.onUpdate) a.onUpdate()
        } else j.activeTexture(j.TEXTURE0 + b), j.bindTexture(j.TEXTURE_2D, a.__webglTexture)
    };
    this.setRenderTarget = function (a) {
        var b = a instanceof THREE.WebGLRenderTargetCube;
        if (a && !a.__webglFramebuffer) {
            void 0 === a.depthBuffer && (a.depthBuffer = !0);
            void 0 === a.stencilBuffer && (a.stencilBuffer = !0);
            a.addEventListener("dispose", Fb);
            a.__webglTexture = j.createTexture();
            K.info.memory.textures++;
            var c = 0 === (a.width & a.width - 1) && 0 === (a.height & a.height - 1),
                d = x(a.format),
                e = x(a.type);
            if (b) {
                a.__webglFramebuffer = [];
                a.__webglRenderbuffer = [];
                j.bindTexture(j.TEXTURE_CUBE_MAP, a.__webglTexture);
                D(j.TEXTURE_CUBE_MAP, a, c);
                for (var f = 0; 6 > f; f++) {
                    a.__webglFramebuffer[f] = j.createFramebuffer();
                    a.__webglRenderbuffer[f] = j.createRenderbuffer();
                    j.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, d, a.width, a.height, 0, d, e, null);
                    var h = a,
                        g = j.TEXTURE_CUBE_MAP_POSITIVE_X + f;
                    j.bindFramebuffer(j.FRAMEBUFFER, a.__webglFramebuffer[f]);
                    j.framebufferTexture2D(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0, g, h.__webglTexture, 0);
                    I(a.__webglRenderbuffer[f], a)
                }
                c && j.generateMipmap(j.TEXTURE_CUBE_MAP)
            } else a.__webglFramebuffer = j.createFramebuffer(), a.__webglRenderbuffer = a.shareDepthFrom ? a.shareDepthFrom.__webglRenderbuffer : j.createRenderbuffer(), j.bindTexture(j.TEXTURE_2D, a.__webglTexture), D(j.TEXTURE_2D, a, c), j.texImage2D(j.TEXTURE_2D, 0, d, a.width, a.height, 0, d, e, null), d = j.TEXTURE_2D, j.bindFramebuffer(j.FRAMEBUFFER, a.__webglFramebuffer), j.framebufferTexture2D(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0, d, a.__webglTexture, 0), a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? j.framebufferRenderbuffer(j.FRAMEBUFFER, j.DEPTH_ATTACHMENT, j.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && j.framebufferRenderbuffer(j.FRAMEBUFFER, j.DEPTH_STENCIL_ATTACHMENT, j.RENDERBUFFER, a.__webglRenderbuffer) : I(a.__webglRenderbuffer, a), c && j.generateMipmap(j.TEXTURE_2D);
            b ? j.bindTexture(j.TEXTURE_CUBE_MAP, null) : j.bindTexture(j.TEXTURE_2D, null);
            j.bindRenderbuffer(j.RENDERBUFFER, null);
            j.bindFramebuffer(j.FRAMEBUFFER, null)
        }
        a ? (b = b ? a.__webglFramebuffer[a.activeCubeFace] : a.__webglFramebuffer, c = a.width, a = a.height, e = d = 0) : (b = null, c = ob, a = pb, d = cb, e = db);
        b !== ba && (j.bindFramebuffer(j.FRAMEBUFFER, b), j.viewport(d, e, c, a), ba = b);
        qb = c;
        eb = a
    };
    this.shadowMapPlugin = new THREE.ShadowMapPlugin;
    this.addPrePlugin(this.shadowMapPlugin);
    this.addPostPlugin(new THREE.SpritePlugin);
    this.addPostPlugin(new THREE.LensFlarePlugin)
};
THREE.WebGLRenderTarget = function (a, b, c) {
    this.width = a;
    this.height = b;
    c = c || {};
    this.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping;
    this.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter;
    this.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter;
    this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1;
    this.offset = new THREE.Vector2(0, 0);
    this.repeat = new THREE.Vector2(1, 1);
    this.format = void 0 !== c.format ? c.format : THREE.RGBAFormat;
    this.type = void 0 !== c.type ? c.type : THREE.UnsignedByteType;
    this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
    this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
    this.generateMipmaps = !0;
    this.shareDepthFrom = null
};
THREE.WebGLRenderTarget.prototype = {
    constructor: THREE.WebGLRenderTarget,
    clone: function () {
        var a = new THREE.WebGLRenderTarget(this.width, this.height);
        a.wrapS = this.wrapS;
        a.wrapT = this.wrapT;
        a.magFilter = this.magFilter;
        a.minFilter = this.minFilter;
        a.anisotropy = this.anisotropy;
        a.offset.copy(this.offset);
        a.repeat.copy(this.repeat);
        a.format = this.format;
        a.type = this.type;
        a.depthBuffer = this.depthBuffer;
        a.stencilBuffer = this.stencilBuffer;
        a.generateMipmaps = this.generateMipmaps;
        a.shareDepthFrom = this.shareDepthFrom;
        return a
    },
    dispose: function () {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
THREE.WebGLRenderTargetCube = function (a, b, c) {
    THREE.WebGLRenderTarget.call(this, a, b, c);
    this.activeCubeFace = 0
};
THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
THREE.RenderableVertex = function () {
    this.positionWorld = new THREE.Vector3;
    this.positionScreen = new THREE.Vector4;
    this.visible = !0
};
THREE.RenderableVertex.prototype.copy = function (a) {
    this.positionWorld.copy(a.positionWorld);
    this.positionScreen.copy(a.positionScreen)
};
THREE.RenderableFace3 = function () {
    this.id = 0;
    this.v1 = new THREE.RenderableVertex;
    this.v2 = new THREE.RenderableVertex;
    this.v3 = new THREE.RenderableVertex;
    this.centroidModel = new THREE.Vector3;
    this.normalModel = new THREE.Vector3;
    this.normalModelView = new THREE.Vector3;
    this.vertexNormalsLength = 0;
    this.vertexNormalsModel = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
    this.vertexNormalsModelView = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
    this.material = this.color = null;
    this.uvs = [
        []
    ];
    this.z = 0
};
THREE.RenderableObject = function () {
    this.id = 0;
    this.object = null;
    this.z = 0
};
THREE.RenderableParticle = function () {
    this.id = 0;
    this.object = null;
    this.z = this.y = this.x = 0;
    this.rotation = null;
    this.scale = new THREE.Vector2;
    this.material = null
};
THREE.RenderableLine = function () {
    this.id = 0;
    this.v1 = new THREE.RenderableVertex;
    this.v2 = new THREE.RenderableVertex;
    this.vertexColors = [new THREE.Color, new THREE.Color];
    this.material = null;
    this.z = 0
};
THREE.GeometryUtils = {
    merge: function (a, b, c) {
        var d, e, f = a.vertices.length,
            h = b instanceof THREE.Mesh ? b.geometry : b,
            g = a.vertices,
            i = h.vertices,
            k = a.faces,
            m = h.faces,
            a = a.faceVertexUvs[0],
            h = h.faceVertexUvs[0];
        void 0 === c && (c = 0);
        b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, e = (new THREE.Matrix3).getNormalMatrix(d));
        for (var b = 0, l = i.length; b < l; b++) {
            var p = i[b].clone();
            d && p.applyMatrix4(d);
            g.push(p)
        }
        b = 0;
        for (l = m.length; b < l; b++) {
            var p = m[b],
                r, t, n = p.vertexNormals,
                s = p.vertexColors;
            r = new THREE.Face3(p.a + f, p.b + f, p.c + f);
            r.normal.copy(p.normal);
            e && r.normal.applyMatrix3(e).normalize();
            g = 0;
            for (i = n.length; g < i; g++) t = n[g].clone(), e && t.applyMatrix3(e).normalize(), r.vertexNormals.push(t);
            r.color.copy(p.color);
            g = 0;
            for (i = s.length; g < i; g++) t = s[g], r.vertexColors.push(t.clone());
            r.materialIndex = p.materialIndex + c;
            r.centroid.copy(p.centroid);
            d && r.centroid.applyMatrix4(d);
            k.push(r)
        }
        b = 0;
        for (l = h.length; b < l; b++) {
            c = h[b];
            d = [];
            g = 0;
            for (i = c.length; g < i; g++) d.push(new THREE.Vector2(c[g].x, c[g].y));
            a.push(d)
        }
    },
    randomPointInTriangle: function () {
        var a = new THREE.Vector3;
        return function (b, c, d) {
            var e = new THREE.Vector3,
                f = THREE.Math.random16(),
                h = THREE.Math.random16();
            1 < f + h && (f = 1 - f, h = 1 - h);
            var g = 1 - f - h;
            e.copy(b);
            e.multiplyScalar(f);
            a.copy(c);
            a.multiplyScalar(h);
            e.add(a);
            a.copy(d);
            a.multiplyScalar(g);
            e.add(a);
            return e
        }
    }(),
    randomPointInFace: function (a, b) {
        return THREE.GeometryUtils.randomPointInTriangle(b.vertices[a.a], b.vertices[a.b], b.vertices[a.c])
    },
    randomPointsInGeometry: function (a, b) {
        function c(a) {
            function b(c, d) {
                if (d < c) return c;
                var e = c + Math.floor((d - c) / 2);
                return k[e] > a ? b(c, e - 1) : k[e] < a ? b(e + 1, d) : e
            }
            return b(0, k.length - 1)
        }
        var d, e, f = a.faces,
            h = a.vertices,
            g = f.length,
            i = 0,
            k = [],
            m, l, p;
        for (e = 0; e < g; e++) d = f[e], m = h[d.a], l = h[d.b], p = h[d.c], d._area = THREE.GeometryUtils.triangleArea(m, l, p), i += d._area, k[e] = i;
        d = [];
        for (e = 0; e < b; e++) h = THREE.Math.random16() * i, h = c(h), d[e] = THREE.GeometryUtils.randomPointInFace(f[h], a, !0);
        return d
    },
    triangleArea: function () {
        var a = new THREE.Vector3,
            b = new THREE.Vector3;
        return function (c, d, e) {
            a.subVectors(d, c);
            b.subVectors(e, c);
            a.cross(b);
            return .5 * a.length()
        }
    }(),
    center: function (a) {
        a.computeBoundingBox();
        var b = a.boundingBox,
            c = new THREE.Vector3;
        c.addVectors(b.min, b.max);
        c.multiplyScalar(-.5);
        a.applyMatrix((new THREE.Matrix4).makeTranslation(c.x, c.y, c.z));
        a.computeBoundingBox();
        return c
    },
    triangulateQuads: function (a) {
        var b, c, d, e, f = [],
            h = [];
        b = 0;
        for (c = a.faceVertexUvs.length; b < c; b++) h[b] = [];
        b = 0;
        for (c = a.faces.length; b < c; b++) {
            f.push(a.faces[b]);
            d = 0;
            for (e = a.faceVertexUvs.length; d < e; d++) h[d].push(a.faceVertexUvs[d][b])
        }
        a.faces = f;
        a.faceVertexUvs = h;
        a.computeCentroids();
        a.computeFaceNormals();
        a.computeVertexNormals();
        a.hasTangents && a.computeTangents()
    }
};
THREE.ImageUtils = {
    crossOrigin: "anonymous",
    loadTexture: function (a, b, c) {
        var d = new THREE.ImageLoader;
        d.crossOrigin = this.crossOrigin;
        var e = new THREE.Texture(void 0, b),
            b = d.load(a, function () {
                e.needsUpdate = !0;
                c && c(e)
            });
        e.image = b;
        e.sourceFile = a;
        return e
    },
    loadCompressedTexture: function (a, b, c, d) {
        var e = new THREE.CompressedTexture;
        e.mapping = b;
        var f = new XMLHttpRequest;
        f.onload = function () {
            var a = THREE.ImageUtils.parseDDS(f.response, !0);
            e.format = a.format;
            e.mipmaps = a.mipmaps;
            e.image.width = a.width;
            e.image.height = a.height;
            e.generateMipmaps = !1;
            e.needsUpdate = !0;
            c && c(e)
        };
        f.onerror = d;
        f.open("GET", a, !0);
        f.responseType = "arraybuffer";
        f.send(null);
        return e
    },
    loadTextureCube: function (a, b, c, d) {
        var e = [];
        e.loadCount = 0;
        var f = new THREE.Texture;
        f.image = e;
        void 0 !== b && (f.mapping = b);
        f.flipY = !1;
        for (var b = 0, h = a.length; b < h; ++b) {
            var g = new Image;
            e[b] = g;
            g.onload = function () {
                e.loadCount += 1;
                6 === e.loadCount && (f.needsUpdate = !0, c && c(f))
            };
            g.onerror = d;
            g.crossOrigin = this.crossOrigin;
            g.src = a[b]
        }
        return f
    },
    loadCompressedTextureCube: function (a, b, c, d) {
        var e = [];
        e.loadCount = 0;
        var f = new THREE.CompressedTexture;
        f.image = e;
        void 0 !== b && (f.mapping = b);
        f.flipY = !1;
        f.generateMipmaps = !1;
        b = function (a, b) {
            return function () {
                var d = THREE.ImageUtils.parseDDS(a.response, !0);
                b.format = d.format;
                b.mipmaps = d.mipmaps;
                b.width = d.width;
                b.height = d.height;
                e.loadCount += 1;
                6 === e.loadCount && (f.format = d.format, f.needsUpdate = !0, c && c(f))
            }
        };
        if (a instanceof Array)
            for (var h = 0, g = a.length; h < g; ++h) {
                var i = {};
                e[h] = i;
                var k = new XMLHttpRequest;
                k.onload = b(k, i);
                k.onerror = d;
                i = a[h];
                k.open("GET", i, !0);
                k.responseType = "arraybuffer";
                k.send(null)
            } else k = new XMLHttpRequest, k.onload = function () {
                var a = THREE.ImageUtils.parseDDS(k.response, !0);
                if (a.isCubemap) {
                    for (var b = a.mipmaps.length / a.mipmapCount, d = 0; d < b; d++) {
                        e[d] = {
                            mipmaps: []
                        };
                        for (var h = 0; h < a.mipmapCount; h++) e[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + h]), e[d].format = a.format, e[d].width = a.width, e[d].height = a.height
                    }
                    f.format = a.format;
                    f.needsUpdate = !0;
                    c && c(f)
                }
            }, k.onerror = d, k.open("GET", a, !0), k.responseType = "arraybuffer", k.send(null);
        return f
    },
    loadDDSTexture: function (a, b, c, d) {
        var e = [];
        e.loadCount = 0;
        var f = new THREE.CompressedTexture;
        f.image = e;
        void 0 !== b && (f.mapping = b);
        f.flipY = !1;
        f.generateMipmaps = !1;
        var h = new XMLHttpRequest;
        h.onload = function () {
            var a = THREE.ImageUtils.parseDDS(h.response, !0);
            if (a.isCubemap)
                for (var b = a.mipmaps.length / a.mipmapCount, d = 0; d < b; d++) {
                    e[d] = {
                        mipmaps: []
                    };
                    for (var m = 0; m < a.mipmapCount; m++) e[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + m]), e[d].format = a.format, e[d].width = a.width, e[d].height = a.height
                } else f.image.width = a.width, f.image.height = a.height, f.mipmaps = a.mipmaps;
            f.format = a.format;
            f.needsUpdate = !0;
            c && c(f)
        };
        h.onerror = d;
        h.open("GET", a, !0);
        h.responseType = "arraybuffer";
        h.send(null);
        return f
    },
    parseDDS: function (a, b) {
        function c(a) {
            return a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24)
        }
        var d = {
                mipmaps: [],
                width: 0,
                height: 0,
                format: null,
                mipmapCount: 1
            },
            e = c("DXT1"),
            f = c("DXT3"),
            h = c("DXT5"),
            g = new Int32Array(a, 0, 31);
        if (542327876 !== g[0]) return console.error("ImageUtils.parseDDS(): Invalid magic number in DDS header"), d;
        if (!g[20] & 4) return console.error("ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code"), d;
        var i = g[21],
            k = !1;
        switch (i) {
        case e:
            e = 8;
            d.format = THREE.RGB_S3TC_DXT1_Format;
            break;
        case f:
            e = 16;
            d.format = THREE.RGBA_S3TC_DXT3_Format;
            break;
        case h:
            e = 16;
            d.format = THREE.RGBA_S3TC_DXT5_Format;
            break;
        default:
            if (32 == g[22] && g[23] & 16711680 && g[24] & 65280 && g[25] & 255 && g[26] & 4278190080) k = !0, e = 64, d.format = THREE.RGBAFormat;
            else return console.error("ImageUtils.parseDDS(): Unsupported FourCC code: ", String.fromCharCode(i & 255, i >> 8 & 255, i >> 16 & 255, i >> 24 & 255)), d
        }
        d.mipmapCount = 1;
        g[2] & 131072 && !1 !== b && (d.mipmapCount = Math.max(1, g[7]));
        d.isCubemap = g[28] & 512 ? !0 : !1;
        d.width = g[4];
        d.height = g[3];
        for (var g = g[1] + 4, f = d.width, h = d.height, i = d.isCubemap ? 6 : 1, m = 0; m < i; m++) {
            for (var l = 0; l < d.mipmapCount; l++) {
                if (k) {
                    var p;
                    p = f;
                    for (var r = h, t = 4 * p * r, n = new Uint8Array(a, g, t), t = new Uint8Array(t), s = 0, q = 0, u = 0; u < r; u++)
                        for (var w = 0; w < p; w++) {
                            var E = n[q];
                            q++;
                            var C = n[q];
                            q++;
                            var F = n[q];
                            q++;
                            var y = n[q];
                            q++;
                            t[s] = F;
                            s++;
                            t[s] = C;
                            s++;
                            t[s] = E;
                            s++;
                            t[s] = y;
                            s++
                        }
                    p = t;
                    r = p.length
                } else r = Math.max(4, f) / 4 * Math.max(4, h) / 4 * e, p = new Uint8Array(a, g, r);
                d.mipmaps.push({
                    data: p,
                    width: f,
                    height: h
                });
                g += r;
                f = Math.max(.5 * f, 1);
                h = Math.max(.5 * h, 1)
            }
            f = d.width;
            h = d.height
        }
        return d
    },
    getNormalMap: function (a, b) {
        var c = function (a) {
                var b = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
                return [a[0] / b, a[1] / b, a[2] / b]
            },
            b = b | 1,
            d = a.width,
            e = a.height,
            f = document.createElement("canvas");
        f.width = d;
        f.height = e;
        var h = f.getContext("2d");
        h.drawImage(a, 0, 0);
        for (var g = h.getImageData(0, 0, d, e).data, i = h.createImageData(d, e), k = i.data, m = 0; m < d; m++)
            for (var l = 0; l < e; l++) {
                var p = 0 > l - 1 ? 0 : l - 1,
                    r = l + 1 > e - 1 ? e - 1 : l + 1,
                    t = 0 > m - 1 ? 0 : m - 1,
                    n = m + 1 > d - 1 ? d - 1 : m + 1,
                    s = [],
                    q = [0, 0, g[4 * (l * d + m)] / 255 * b];
                s.push([-1, 0, g[4 * (l * d + t)] / 255 * b]);
                s.push([-1, -1, g[4 * (p * d + t)] / 255 * b]);
                s.push([0, -1, g[4 * (p * d + m)] / 255 * b]);
                s.push([1, -1, g[4 * (p * d + n)] / 255 * b]);
                s.push([1, 0, g[4 * (l * d + n)] / 255 * b]);
                s.push([1, 1, g[4 * (r * d + n)] / 255 * b]);
                s.push([0, 1, g[4 * (r * d + m)] / 255 * b]);
                s.push([-1, 1, g[4 * (r * d + t)] / 255 * b]);
                p = [];
                t = s.length;
                for (r = 0; r < t; r++) {
                    var n = s[r],
                        u = s[(r + 1) % t],
                        n = [n[0] - q[0], n[1] - q[1], n[2] - q[2]],
                        u = [u[0] - q[0], u[1] - q[1], u[2] - q[2]];
                    p.push(c([n[1] * u[2] - n[2] * u[1], n[2] * u[0] - n[0] * u[2], n[0] * u[1] - n[1] * u[0]]))
                }
                s = [0, 0, 0];
                for (r = 0; r < p.length; r++) s[0] += p[r][0], s[1] += p[r][1], s[2] += p[r][2];
                s[0] /= p.length;
                s[1] /= p.length;
                s[2] /= p.length;
                q = 4 * (l * d + m);
                k[q] = 255 * ((s[0] + 1) / 2) | 0;
                k[q + 1] = 255 * ((s[1] + 1) / 2) | 0;
                k[q + 2] = 255 * s[2] | 0;
                k[q + 3] = 255
            }
        h.putImageData(i, 0, 0);
        return f
    },
    generateDataTexture: function (a, b, c) {
        for (var d = a * b, e = new Uint8Array(3 * d), f = Math.floor(255 * c.r), h = Math.floor(255 * c.g), c = Math.floor(255 * c.b), g = 0; g < d; g++) e[3 * g] = f, e[3 * g + 1] = h, e[3 * g + 2] = c;
        a = new THREE.DataTexture(e, a, b, THREE.RGBFormat);
        a.needsUpdate = !0;
        return a
    }
};
THREE.SceneUtils = {
    createMultiMaterialObject: function (a, b) {
        for (var c = new THREE.Object3D, d = 0, e = b.length; d < e; d++) c.add(new THREE.Mesh(a, b[d]));
        return c
    },
    detach: function (a, b, c) {
        a.applyMatrix(b.matrixWorld);
        b.remove(a);
        c.add(a)
    },
    attach: function (a, b, c) {
        var d = new THREE.Matrix4;
        d.getInverse(c.matrixWorld);
        a.applyMatrix(d);
        b.remove(a);
        c.add(a)
    }
};
THREE.FontUtils = {
    faces: {},
    face: "helvetiker",
    weight: "normal",
    style: "normal",
    size: 150,
    divisions: 10,
    getFace: function () {
        return this.faces[this.face][this.weight][this.style]
    },
    loadFace: function (a) {
        var b = a.familyName.toLowerCase();
        this.faces[b] = this.faces[b] || {};
        this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {};
        this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
        return this.faces[b][a.cssFontWeight][a.cssFontStyle] = a
    },
    drawText: function (a) {
        for (var b = this.getFace(), c = this.size / b.resolution, d = 0, e = String(a).split(""), f = e.length, h = [], a = 0; a < f; a++) {
            var g = new THREE.Path,
                g = this.extractGlyphPoints(e[a], b, c, d, g),
                d = d + g.offset;
            h.push(g.path)
        }
        return {
            paths: h,
            offset: d / 2
        }
    },
    extractGlyphPoints: function (a, b, c, d, e) {
        var f = [],
            h, g, i, k, m, l, p, r, t, n, s, q = b.glyphs[a] || b.glyphs["?"];
        if (q) {
            if (q.o) {
                b = q._cachedOutline || (q._cachedOutline = q.o.split(" "));
                k = b.length;
                for (a = 0; a < k;) switch (i = b[a++], i) {
                case "m":
                    i = b[a++] * c + d;
                    m = b[a++] * c;
                    e.moveTo(i, m);
                    break;
                case "l":
                    i = b[a++] * c + d;
                    m = b[a++] * c;
                    e.lineTo(i, m);
                    break;
                case "q":
                    i = b[a++] * c + d;
                    m = b[a++] * c;
                    r = b[a++] * c + d;
                    t = b[a++] * c;
                    e.quadraticCurveTo(r, t, i, m);
                    if (h = f[f.length - 1]) {
                        l = h.x;
                        p = h.y;
                        h = 1;
                        for (g = this.divisions; h <= g; h++) {
                            var u = h / g;
                            THREE.Shape.Utils.b2(u, l, r, i);
                            THREE.Shape.Utils.b2(u, p, t, m)
                        }
                    }
                    break;
                case "b":
                    if (i = b[a++] * c + d, m = b[a++] * c, r = b[a++] * c + d, t = b[a++] * -c, n = b[a++] * c + d, s = b[a++] * -c, e.bezierCurveTo(i, m, r, t, n, s), h = f[f.length - 1]) {
                        l = h.x;
                        p = h.y;
                        h = 1;
                        for (g = this.divisions; h <= g; h++) u = h / g, THREE.Shape.Utils.b3(u, l, r, n, i), THREE.Shape.Utils.b3(u, p, t, s, m)
                    }
                }
            }
            return {
                offset: q.ha * c,
                path: e
            }
        }
    }
};
THREE.FontUtils.generateShapes = function (a, b) {
    var b = b || {},
        c = void 0 !== b.curveSegments ? b.curveSegments : 4,
        d = void 0 !== b.font ? b.font : "helvetiker",
        e = void 0 !== b.weight ? b.weight : "normal",
        f = void 0 !== b.style ? b.style : "normal";
    THREE.FontUtils.size = void 0 !== b.size ? b.size : 100;
    THREE.FontUtils.divisions = c;
    THREE.FontUtils.face = d;
    THREE.FontUtils.weight = e;
    THREE.FontUtils.style = f;
    c = THREE.FontUtils.drawText(a).paths;
    d = [];
    e = 0;
    for (f = c.length; e < f; e++) Array.prototype.push.apply(d, c[e].toShapes());
    return d
};
(function (a) {
    var b = function (a) {
        for (var b = a.length, e = 0, f = b - 1, h = 0; h < b; f = h++) e += a[f].x * a[h].y - a[h].x * a[f].y;
        return .5 * e
    };
    a.Triangulate = function (a, d) {
        var e = a.length;
        if (3 > e) return null;
        var f = [],
            h = [],
            g = [],
            i, k, m;
        if (0 < b(a))
            for (k = 0; k < e; k++) h[k] = k;
        else
            for (k = 0; k < e; k++) h[k] = e - 1 - k;
        var l = 2 * e;
        for (k = e - 1; 2 < e;) {
            if (0 >= l--) {
                console.log("Warning, unable to triangulate polygon!");
                break
            }
            i = k;
            e <= i && (i = 0);
            k = i + 1;
            e <= k && (k = 0);
            m = k + 1;
            e <= m && (m = 0);
            var p;
            a: {
                var r = p = void 0,
                    t = void 0,
                    n = void 0,
                    s = void 0,
                    q = void 0,
                    u = void 0,
                    w = void 0,
                    E = void 0,
                    r = a[h[i]].x,
                    t = a[h[i]].y,
                    n = a[h[k]].x,
                    s = a[h[k]].y,
                    q = a[h[m]].x,
                    u = a[h[m]].y;
                if (1e-10 > (n - r) * (u - t) - (s - t) * (q - r)) p = !1;
                else {
                    var C = void 0,
                        F = void 0,
                        y = void 0,
                        A = void 0,
                        z = void 0,
                        O = void 0,
                        B = void 0,
                        D = void 0,
                        I = void 0,
                        v = void 0,
                        I = D = B = E = w = void 0,
                        C = q - n,
                        F = u - s,
                        y = r - q,
                        A = t - u,
                        z = n - r,
                        O = s - t;
                    for (p = 0; p < e; p++)
                        if (!(p === i || p === k || p === m))
                            if (w = a[h[p]].x, E = a[h[p]].y, B = w - r, D = E - t, I = w - n, v = E - s, w -= q, E -= u, I = C * v - F * I, B = z * D - O * B, D = y * E - A * w, -1e-10 <= I && -1e-10 <= D && -1e-10 <= B) {
                                p = !1;
                                break a
                            }
                    p = !0
                }
            }
            if (p) {
                f.push([a[h[i]], a[h[k]], a[h[m]]]);
                g.push([h[i], h[k], h[m]]);
                i = k;
                for (m = k + 1; m < e; i++, m++) h[i] = h[m];
                e--;
                l = 2 * e
            }
        }
        return d ? g : f
    };
    a.Triangulate.area = b;
    return a
})(THREE.FontUtils);
self._typeface_js = {
    faces: THREE.FontUtils.faces,
    loadFace: THREE.FontUtils.loadFace
};
THREE.typeface_js = self._typeface_js;
THREE.Curve = function () {};
THREE.Curve.prototype.getPoint = function () {
    console.log("Warning, getPoint() not implemented!");
    return null
};
THREE.Curve.prototype.getPointAt = function (a) {
    a = this.getUtoTmapping(a);
    return this.getPoint(a)
};
THREE.Curve.prototype.getPoints = function (a) {
    a || (a = 5);
    var b, c = [];
    for (b = 0; b <= a; b++) c.push(this.getPoint(b / a));
    return c
};
THREE.Curve.prototype.getSpacedPoints = function (a) {
    a || (a = 5);
    var b, c = [];
    for (b = 0; b <= a; b++) c.push(this.getPointAt(b / a));
    return c
};
THREE.Curve.prototype.getLength = function () {
    var a = this.getLengths();
    return a[a.length - 1]
};
THREE.Curve.prototype.getLengths = function (a) {
    a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
    if (this.cacheArcLengths && this.cacheArcLengths.length == a + 1 && !this.needsUpdate) return this.cacheArcLengths;
    this.needsUpdate = !1;
    var b = [],
        c, d = this.getPoint(0),
        e, f = 0;
    b.push(0);
    for (e = 1; e <= a; e++) c = this.getPoint(e / a), f += c.distanceTo(d), b.push(f), d = c;
    return this.cacheArcLengths = b
};
THREE.Curve.prototype.updateArcLengths = function () {
    this.needsUpdate = !0;
    this.getLengths()
};
THREE.Curve.prototype.getUtoTmapping = function (a, b) {
    var c = this.getLengths(),
        d = 0,
        e = c.length,
        f;
    f = b ? b : a * c[e - 1];
    for (var h = 0, g = e - 1, i; h <= g;)
        if (d = Math.floor(h + (g - h) / 2), i = c[d] - f, 0 > i) h = d + 1;
        else if (0 < i) g = d - 1;
    else {
        g = d;
        break
    }
    d = g;
    if (c[d] == f) return d / (e - 1);
    h = c[d];
    return c = (d + (f - h) / (c[d + 1] - h)) / (e - 1)
};
THREE.Curve.prototype.getTangent = function (a) {
    var b = a - 1e-4,
        a = a + 1e-4;
    0 > b && (b = 0);
    1 < a && (a = 1);
    b = this.getPoint(b);
    return this.getPoint(a).clone().sub(b).normalize()
};
THREE.Curve.prototype.getTangentAt = function (a) {
    a = this.getUtoTmapping(a);
    return this.getTangent(a)
};
THREE.Curve.Utils = {
    tangentQuadraticBezier: function (a, b, c, d) {
        return 2 * (1 - a) * (c - b) + 2 * a * (d - c)
    },
    tangentCubicBezier: function (a, b, c, d, e) {
        return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e
    },
    tangentSpline: function (a) {
        return 6 * a * a - 6 * a + (3 * a * a - 4 * a + 1) + (-6 * a * a + 6 * a) + (3 * a * a - 2 * a)
    },
    interpolate: function (a, b, c, d, e) {
        var a = .5 * (c - a),
            d = .5 * (d - b),
            f = e * e;
        return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b
    }
};
THREE.Curve.create = function (a, b) {
    a.prototype = Object.create(THREE.Curve.prototype);
    a.prototype.getPoint = b;
    return a
};
THREE.CurvePath = function () {
    this.curves = [];
    this.bends = [];
    this.autoClose = !1
};
THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
THREE.CurvePath.prototype.add = function (a) {
    this.curves.push(a)
};
THREE.CurvePath.prototype.checkConnection = function () {};
THREE.CurvePath.prototype.closePath = function () {
    var a = this.curves[0].getPoint(0),
        b = this.curves[this.curves.length - 1].getPoint(1);
    a.equals(b) || this.curves.push(new THREE.LineCurve(b, a))
};
THREE.CurvePath.prototype.getPoint = function (a) {
    for (var b = a * this.getLength(), c = this.getCurveLengths(), a = 0; a < c.length;) {
        if (c[a] >= b) return b = c[a] - b, a = this.curves[a], b = 1 - b / a.getLength(), a.getPointAt(b);
        a++
    }
    return null
};
THREE.CurvePath.prototype.getLength = function () {
    var a = this.getCurveLengths();
    return a[a.length - 1]
};
THREE.CurvePath.prototype.getCurveLengths = function () {
    if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
    var a = [],
        b = 0,
        c, d = this.curves.length;
    for (c = 0; c < d; c++) b += this.curves[c].getLength(), a.push(b);
    return this.cacheLengths = a
};
THREE.CurvePath.prototype.getBoundingBox = function () {
    var a = this.getPoints(),
        b, c, d, e, f, h;
    b = c = Number.NEGATIVE_INFINITY;
    e = f = Number.POSITIVE_INFINITY;
    var g, i, k, m, l = a[0] instanceof THREE.Vector3;
    m = l ? new THREE.Vector3 : new THREE.Vector2;
    i = 0;
    for (k = a.length; i < k; i++) g = a[i], g.x > b ? b = g.x : g.x < e && (e = g.x), g.y > c ? c = g.y : g.y < f && (f = g.y), l && (g.z > d ? d = g.z : g.z < h && (h = g.z)), m.add(g);
    a = {
        minX: e,
        minY: f,
        maxX: b,
        maxY: c,
        centroid: m.divideScalar(k)
    };
    l && (a.maxZ = d, a.minZ = h);
    return a
};
THREE.CurvePath.prototype.createPointsGeometry = function (a) {
    a = this.getPoints(a, !0);
    return this.createGeometry(a)
};
THREE.CurvePath.prototype.createSpacedPointsGeometry = function (a) {
    a = this.getSpacedPoints(a, !0);
    return this.createGeometry(a)
};
THREE.CurvePath.prototype.createGeometry = function (a) {
    for (var b = new THREE.Geometry, c = 0; c < a.length; c++) b.vertices.push(new THREE.Vector3(a[c].x, a[c].y, a[c].z || 0));
    return b
};
THREE.CurvePath.prototype.addWrapPath = function (a) {
    this.bends.push(a)
};
THREE.CurvePath.prototype.getTransformedPoints = function (a, b) {
    var c = this.getPoints(a),
        d, e;
    b || (b = this.bends);
    d = 0;
    for (e = b.length; d < e; d++) c = this.getWrapPoints(c, b[d]);
    return c
};
THREE.CurvePath.prototype.getTransformedSpacedPoints = function (a, b) {
    var c = this.getSpacedPoints(a),
        d, e;
    b || (b = this.bends);
    d = 0;
    for (e = b.length; d < e; d++) c = this.getWrapPoints(c, b[d]);
    return c
};
THREE.CurvePath.prototype.getWrapPoints = function (a, b) {
    var c = this.getBoundingBox(),
        d, e, f, h, g, i;
    d = 0;
    for (e = a.length; d < e; d++) f = a[d], h = f.x, g = f.y, i = h / c.maxX, i = b.getUtoTmapping(i, h), h = b.getPoint(i), g = b.getNormalVector(i).multiplyScalar(g), f.x = h.x + g.x, f.y = h.y + g.y;
    return a
};
THREE.Gyroscope = function () {
    THREE.Object3D.call(this)
};
THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.updateMatrixWorld = function (a) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || a) this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld), this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject), this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
    for (var b = 0, c = this.children.length; b < c; b++) this.children[b].updateMatrixWorld(a)
};
THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3;
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3;
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion;
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion;
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3;
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3;
THREE.Path = function (a) {
    THREE.CurvePath.call(this);
    this.actions = [];
    a && this.fromPoints(a)
};
THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
THREE.PathActions = {
    MOVE_TO: "moveTo",
    LINE_TO: "lineTo",
    QUADRATIC_CURVE_TO: "quadraticCurveTo",
    BEZIER_CURVE_TO: "bezierCurveTo",
    CSPLINE_THRU: "splineThru",
    ARC: "arc",
    ELLIPSE: "ellipse"
};
THREE.Path.prototype.fromPoints = function (a) {
    this.moveTo(a[0].x, a[0].y);
    for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y)
};
THREE.Path.prototype.moveTo = function (a, b) {
    var c = Array.prototype.slice.call(arguments);
    this.actions.push({
        action: THREE.PathActions.MOVE_TO,
        args: c
    })
};
THREE.Path.prototype.lineTo = function (a, b) {
    var c = Array.prototype.slice.call(arguments),
        d = this.actions[this.actions.length - 1].args,
        d = new THREE.LineCurve(new THREE.Vector2(d[d.length - 2], d[d.length - 1]), new THREE.Vector2(a, b));
    this.curves.push(d);
    this.actions.push({
        action: THREE.PathActions.LINE_TO,
        args: c
    })
};
THREE.Path.prototype.quadraticCurveTo = function (a, b, c, d) {
    var e = Array.prototype.slice.call(arguments),
        f = this.actions[this.actions.length - 1].args,
        f = new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length - 2], f[f.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d));
    this.curves.push(f);
    this.actions.push({
        action: THREE.PathActions.QUADRATIC_CURVE_TO,
        args: e
    })
};
THREE.Path.prototype.bezierCurveTo = function (a, b, c, d, e, f) {
    var h = Array.prototype.slice.call(arguments),
        g = this.actions[this.actions.length - 1].args,
        g = new THREE.CubicBezierCurve(new THREE.Vector2(g[g.length - 2], g[g.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d), new THREE.Vector2(e, f));
    this.curves.push(g);
    this.actions.push({
        action: THREE.PathActions.BEZIER_CURVE_TO,
        args: h
    })
};
THREE.Path.prototype.splineThru = function (a) {
    var b = Array.prototype.slice.call(arguments),
        c = this.actions[this.actions.length - 1].args,
        c = [new THREE.Vector2(c[c.length - 2], c[c.length - 1])];
    Array.prototype.push.apply(c, a);
    c = new THREE.SplineCurve(c);
    this.curves.push(c);
    this.actions.push({
        action: THREE.PathActions.CSPLINE_THRU,
        args: b
    })
};
THREE.Path.prototype.arc = function (a, b, c, d, e, f) {
    var h = this.actions[this.actions.length - 1].args;
    this.absarc(a + h[h.length - 2], b + h[h.length - 1], c, d, e, f)
};
THREE.Path.prototype.absarc = function (a, b, c, d, e, f) {
    this.absellipse(a, b, c, c, d, e, f)
};
THREE.Path.prototype.ellipse = function (a, b, c, d, e, f, h) {
    var g = this.actions[this.actions.length - 1].args;
    this.absellipse(a + g[g.length - 2], b + g[g.length - 1], c, d, e, f, h)
};
THREE.Path.prototype.absellipse = function (a, b, c, d, e, f, h) {
    var g = Array.prototype.slice.call(arguments),
        i = new THREE.EllipseCurve(a, b, c, d, e, f, h);
    this.curves.push(i);
    i = i.getPoint(1);
    g.push(i.x);
    g.push(i.y);
    this.actions.push({
        action: THREE.PathActions.ELLIPSE,
        args: g
    })
};
THREE.Path.prototype.getSpacedPoints = function (a) {
    a || (a = 40);
    for (var b = [], c = 0; c < a; c++) b.push(this.getPoint(c / a));
    return b
};
THREE.Path.prototype.getPoints = function (a, b) {
    if (this.useSpacedPoints) return console.log("tata"), this.getSpacedPoints(a, b);
    var a = a || 12,
        c = [],
        d, e, f, h, g, i, k, m, l, p, r, t, n;
    d = 0;
    for (e = this.actions.length; d < e; d++) switch (f = this.actions[d], h = f.action, f = f.args, h) {
    case THREE.PathActions.MOVE_TO:
        c.push(new THREE.Vector2(f[0], f[1]));
        break;
    case THREE.PathActions.LINE_TO:
        c.push(new THREE.Vector2(f[0], f[1]));
        break;
    case THREE.PathActions.QUADRATIC_CURVE_TO:
        g = f[2];
        i = f[3];
        l = f[0];
        p = f[1];
        0 < c.length ? (h = c[c.length - 1], r = h.x, t = h.y) : (h = this.actions[d - 1].args, r = h[h.length - 2], t = h[h.length - 1]);
        for (f = 1; f <= a; f++) n = f / a, h = THREE.Shape.Utils.b2(n, r, l, g), n = THREE.Shape.Utils.b2(n, t, p, i), c.push(new THREE.Vector2(h, n));
        break;
    case THREE.PathActions.BEZIER_CURVE_TO:
        g = f[4];
        i = f[5];
        l = f[0];
        p = f[1];
        k = f[2];
        m = f[3];
        0 < c.length ? (h = c[c.length - 1], r = h.x, t = h.y) : (h = this.actions[d - 1].args, r = h[h.length - 2], t = h[h.length - 1]);
        for (f = 1; f <= a; f++) n = f / a, h = THREE.Shape.Utils.b3(n, r, l, k, g), n = THREE.Shape.Utils.b3(n, t, p, m, i), c.push(new THREE.Vector2(h, n));
        break;
    case THREE.PathActions.CSPLINE_THRU:
        h = this.actions[d - 1].args;
        n = [new THREE.Vector2(h[h.length - 2], h[h.length - 1])];
        h = a * f[0].length;
        n = n.concat(f[0]);
        n = new THREE.SplineCurve(n);
        for (f = 1; f <= h; f++) c.push(n.getPointAt(f / h));
        break;
    case THREE.PathActions.ARC:
        g = f[0];
        i = f[1];
        p = f[2];
        k = f[3];
        h = f[4];
        l = !!f[5];
        r = h - k;
        t = 2 * a;
        for (f = 1; f <= t; f++) n = f / t, l || (n = 1 - n), n = k + n * r, h = g + p * Math.cos(n), n = i + p * Math.sin(n), c.push(new THREE.Vector2(h, n));
        break;
    case THREE.PathActions.ELLIPSE:
        g = f[0];
        i = f[1];
        p = f[2];
        m = f[3];
        k = f[4];
        h = f[5];
        l = !!f[6];
        r = h - k;
        t = 2 * a;
        for (f = 1; f <= t; f++) n = f / t, l || (n = 1 - n), n = k + n * r, h = g + p * Math.cos(n), n = i + m * Math.sin(n), c.push(new THREE.Vector2(h, n))
    }
    d = c[c.length - 1];
    1e-10 > Math.abs(d.x - c[0].x) && 1e-10 > Math.abs(d.y - c[0].y) && c.splice(c.length - 1, 1);
    b && c.push(c[0]);
    return c
};
THREE.Path.prototype.toShapes = function (a) {
    var b, c, d, e, f = [],
        h = new THREE.Path;
    b = 0;
    for (c = this.actions.length; b < c; b++) d = this.actions[b], e = d.args, d = d.action, d == THREE.PathActions.MOVE_TO && 0 != h.actions.length && (f.push(h), h = new THREE.Path), h[d].apply(h, e);
    0 != h.actions.length && f.push(h);
    if (0 == f.length) return [];
    var g;
    e = [];
    if (1 == f.length) return d = f[0], g = new THREE.Shape, g.actions = d.actions, g.curves = d.curves, e.push(g), e;
    b = !THREE.Shape.Utils.isClockWise(f[0].getPoints());
    if (a ? !b : b) {
        g = new THREE.Shape;
        b = 0;
        for (c = f.length; b < c; b++) d = f[b], h = THREE.Shape.Utils.isClockWise(d.getPoints()), (h = a ? !h : h) ? (g.actions = d.actions, g.curves = d.curves, e.push(g), g = new THREE.Shape) : g.holes.push(d)
    } else {
        g = void 0;
        b = 0;
        for (c = f.length; b < c; b++) d = f[b], h = THREE.Shape.Utils.isClockWise(d.getPoints()), (h = a ? !h : h) ? (g && e.push(g), g = new THREE.Shape, g.actions = d.actions, g.curves = d.curves) : g.holes.push(d);
        e.push(g)
    }
    return e
};
THREE.Shape = function () {
    THREE.Path.apply(this, arguments);
    this.holes = []
};
THREE.Shape.prototype = Object.create(THREE.Path.prototype);
THREE.Shape.prototype.extrude = function (a) {
    return new THREE.ExtrudeGeometry(this, a)
};
THREE.Shape.prototype.makeGeometry = function (a) {
    return new THREE.ShapeGeometry(this, a)
};
THREE.Shape.prototype.getPointsHoles = function (a) {
    var b, c = this.holes.length,
        d = [];
    for (b = 0; b < c; b++) d[b] = this.holes[b].getTransformedPoints(a, this.bends);
    return d
};
THREE.Shape.prototype.getSpacedPointsHoles = function (a) {
    var b, c = this.holes.length,
        d = [];
    for (b = 0; b < c; b++) d[b] = this.holes[b].getTransformedSpacedPoints(a, this.bends);
    return d
};
THREE.Shape.prototype.extractAllPoints = function (a) {
    return {
        shape: this.getTransformedPoints(a),
        holes: this.getPointsHoles(a)
    }
};
THREE.Shape.prototype.extractPoints = function (a) {
    return this.useSpacedPoints ? this.extractAllSpacedPoints(a) : this.extractAllPoints(a)
};
THREE.Shape.prototype.extractAllSpacedPoints = function (a) {
    return {
        shape: this.getTransformedSpacedPoints(a),
        holes: this.getSpacedPointsHoles(a)
    }
};
THREE.Shape.Utils = {
    removeHoles: function (a, b) {
        var c = a.concat(),
            d = c.concat(),
            e, f, h, g, i, k, m, l, p, r, t = [];
        for (i = 0; i < b.length; i++) {
            k = b[i];
            Array.prototype.push.apply(d, k);
            f = Number.POSITIVE_INFINITY;
            for (e = 0; e < k.length; e++) {
                p = k[e];
                r = [];
                for (l = 0; l < c.length; l++) m = c[l], m = p.distanceToSquared(m), r.push(m), m < f && (f = m, h = e, g = l)
            }
            e = 0 <= g - 1 ? g - 1 : c.length - 1;
            f = 0 <= h - 1 ? h - 1 : k.length - 1;
            var n = [k[h], c[g], c[e]];
            l = THREE.FontUtils.Triangulate.area(n);
            var s = [k[h], k[f], c[g]];
            p = THREE.FontUtils.Triangulate.area(s);
            r = g;
            m = h;
            g += 1;
            h += -1;
            0 > g && (g += c.length);
            g %= c.length;
            0 > h && (h += k.length);
            h %= k.length;
            e = 0 <= g - 1 ? g - 1 : c.length - 1;
            f = 0 <= h - 1 ? h - 1 : k.length - 1;
            n = [k[h], c[g], c[e]];
            n = THREE.FontUtils.Triangulate.area(n);
            s = [k[h], k[f], c[g]];
            s = THREE.FontUtils.Triangulate.area(s);
            l + p > n + s && (g = r, h = m, 0 > g && (g += c.length), g %= c.length, 0 > h && (h += k.length), h %= k.length, e = 0 <= g - 1 ? g - 1 : c.length - 1, f = 0 <= h - 1 ? h - 1 : k.length - 1);
            l = c.slice(0, g);
            p = c.slice(g);
            r = k.slice(h);
            m = k.slice(0, h);
            f = [k[h], k[f], c[g]];
            t.push([k[h], c[g], c[e]]);
            t.push(f);
            c = l.concat(r).concat(m).concat(p)
        }
        return {
            shape: c,
            isolatedPts: t,
            allpoints: d
        }
    },
    triangulateShape: function (a, b) {
        var c = THREE.Shape.Utils.removeHoles(a, b),
            d = c.allpoints,
            e = c.isolatedPts,
            c = THREE.FontUtils.Triangulate(c.shape, !1),
            f, h, g, i, k = {};
        f = 0;
        for (h = d.length; f < h; f++) i = d[f].x + ":" + d[f].y, void 0 !== k[i] && console.log("Duplicate point", i), k[i] = f;
        f = 0;
        for (h = c.length; f < h; f++) {
            g = c[f];
            for (d = 0; 3 > d; d++) i = g[d].x + ":" + g[d].y, i = k[i], void 0 !== i && (g[d] = i)
        }
        f = 0;
        for (h = e.length; f < h; f++) {
            g = e[f];
            for (d = 0; 3 > d; d++) i = g[d].x + ":" + g[d].y, i = k[i], void 0 !== i && (g[d] = i)
        }
        return c.concat(e)
    },
    isClockWise: function (a) {
        return 0 > THREE.FontUtils.Triangulate.area(a)
    },
    b2p0: function (a, b) {
        var c = 1 - a;
        return c * c * b
    },
    b2p1: function (a, b) {
        return 2 * (1 - a) * a * b
    },
    b2p2: function (a, b) {
        return a * a * b
    },
    b2: function (a, b, c, d) {
        return this.b2p0(a, b) + this.b2p1(a, c) + this.b2p2(a, d)
    },
    b3p0: function (a, b) {
        var c = 1 - a;
        return c * c * c * b
    },
    b3p1: function (a, b) {
        var c = 1 - a;
        return 3 * c * c * a * b
    },
    b3p2: function (a, b) {
        return 3 * (1 - a) * a * a * b
    },
    b3p3: function (a, b) {
        return a * a * a * b
    },
    b3: function (a, b, c, d, e) {
        return this.b3p0(a, b) + this.b3p1(a, c) + this.b3p2(a, d) + this.b3p3(a, e)
    }
};
THREE.LineCurve = function (a, b) {
    this.v1 = a;
    this.v2 = b
};
THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.LineCurve.prototype.getPoint = function (a) {
    var b = this.v2.clone().sub(this.v1);
    b.multiplyScalar(a).add(this.v1);
    return b
};
THREE.LineCurve.prototype.getPointAt = function (a) {
    return this.getPoint(a)
};
THREE.LineCurve.prototype.getTangent = function () {
    return this.v2.clone().sub(this.v1).normalize()
};
THREE.QuadraticBezierCurve = function (a, b, c) {
    this.v0 = a;
    this.v1 = b;
    this.v2 = c
};
THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.QuadraticBezierCurve.prototype.getPoint = function (a) {
    var b;
    b = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
    a = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
    return new THREE.Vector2(b, a)
};
THREE.QuadraticBezierCurve.prototype.getTangent = function (a) {
    var b;
    b = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.x, this.v1.x, this.v2.x);
    a = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.y, this.v1.y, this.v2.y);
    b = new THREE.Vector2(b, a);
    b.normalize();
    return b
};
THREE.CubicBezierCurve = function (a, b, c, d) {
    this.v0 = a;
    this.v1 = b;
    this.v2 = c;
    this.v3 = d
};
THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.CubicBezierCurve.prototype.getPoint = function (a) {
    var b;
    b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
    a = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
    return new THREE.Vector2(b, a)
};
THREE.CubicBezierCurve.prototype.getTangent = function (a) {
    var b;
    b = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
    a = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
    b = new THREE.Vector2(b, a);
    b.normalize();
    return b
};
THREE.SplineCurve = function (a) {
    this.points = void 0 == a ? [] : a
};
THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.SplineCurve.prototype.getPoint = function (a) {
    var b = new THREE.Vector2,
        c = [],
        d = this.points,
        e;
    e = (d.length - 1) * a;
    a = Math.floor(e);
    e -= a;
    c[0] = 0 == a ? a : a - 1;
    c[1] = a;
    c[2] = a > d.length - 2 ? d.length - 1 : a + 1;
    c[3] = a > d.length - 3 ? d.length - 1 : a + 2;
    b.x = THREE.Curve.Utils.interpolate(d[c[0]].x, d[c[1]].x, d[c[2]].x, d[c[3]].x, e);
    b.y = THREE.Curve.Utils.interpolate(d[c[0]].y, d[c[1]].y, d[c[2]].y, d[c[3]].y, e);
    return b
};
THREE.EllipseCurve = function (a, b, c, d, e, f, h) {
    this.aX = a;
    this.aY = b;
    this.xRadius = c;
    this.yRadius = d;
    this.aStartAngle = e;
    this.aEndAngle = f;
    this.aClockwise = h
};
THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.EllipseCurve.prototype.getPoint = function (a) {
    var b;
    b = this.aEndAngle - this.aStartAngle;
    0 > b && (b += 2 * Math.PI);
    b > 2 * Math.PI && (b -= 2 * Math.PI);
    b = !0 === this.aClockwise ? this.aEndAngle + (1 - a) * (2 * Math.PI - b) : this.aStartAngle + a * b;
    a = this.aX + this.xRadius * Math.cos(b);
    b = this.aY + this.yRadius * Math.sin(b);
    return new THREE.Vector2(a, b)
};
THREE.ArcCurve = function (a, b, c, d, e, f) {
    THREE.EllipseCurve.call(this, a, b, c, c, d, e, f)
};
THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
THREE.LineCurve3 = THREE.Curve.create(function (a, b) {
    this.v1 = a;
    this.v2 = b
}, function (a) {
    var b = new THREE.Vector3;
    b.subVectors(this.v2, this.v1);
    b.multiplyScalar(a);
    b.add(this.v1);
    return b
});
THREE.QuadraticBezierCurve3 = THREE.Curve.create(function (a, b, c) {
    this.v0 = a;
    this.v1 = b;
    this.v2 = c
}, function (a) {
    var b, c;
    b = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
    c = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
    a = THREE.Shape.Utils.b2(a, this.v0.z, this.v1.z, this.v2.z);
    return new THREE.Vector3(b, c, a)
});
THREE.CubicBezierCurve3 = THREE.Curve.create(function (a, b, c, d) {
    this.v0 = a;
    this.v1 = b;
    this.v2 = c;
    this.v3 = d
}, function (a) {
    var b, c;
    b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
    c = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
    a = THREE.Shape.Utils.b3(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z);
    return new THREE.Vector3(b, c, a)
});
THREE.SplineCurve3 = THREE.Curve.create(function (a) {
    this.points = void 0 == a ? [] : a
}, function (a) {
    var b = new THREE.Vector3,
        c = [],
        d = this.points,
        e, a = (d.length - 1) * a;
    e = Math.floor(a);
    a -= e;
    c[0] = 0 == e ? e : e - 1;
    c[1] = e;
    c[2] = e > d.length - 2 ? d.length - 1 : e + 1;
    c[3] = e > d.length - 3 ? d.length - 1 : e + 2;
    e = d[c[0]];
    var f = d[c[1]],
        h = d[c[2]],
        c = d[c[3]];
    b.x = THREE.Curve.Utils.interpolate(e.x, f.x, h.x, c.x, a);
    b.y = THREE.Curve.Utils.interpolate(e.y, f.y, h.y, c.y, a);
    b.z = THREE.Curve.Utils.interpolate(e.z, f.z, h.z, c.z, a);
    return b
});
THREE.ClosedSplineCurve3 = THREE.Curve.create(function (a) {
    this.points = void 0 == a ? [] : a
}, function (a) {
    var b = new THREE.Vector3,
        c = [],
        d = this.points,
        e;
    e = (d.length - 0) * a;
    a = Math.floor(e);
    e -= a;
    a += 0 < a ? 0 : (Math.floor(Math.abs(a) / d.length) + 1) * d.length;
    c[0] = (a - 1) % d.length;
    c[1] = a % d.length;
    c[2] = (a + 1) % d.length;
    c[3] = (a + 2) % d.length;
    b.x = THREE.Curve.Utils.interpolate(d[c[0]].x, d[c[1]].x, d[c[2]].x, d[c[3]].x, e);
    b.y = THREE.Curve.Utils.interpolate(d[c[0]].y, d[c[1]].y, d[c[2]].y, d[c[3]].y, e);
    b.z = THREE.Curve.Utils.interpolate(d[c[0]].z, d[c[1]].z, d[c[2]].z, d[c[3]].z, e);
    return b
});
THREE.AnimationHandler = function () {
    var a = [],
        b = {},
        c = {
            update: function (b) {
                for (var c = 0; c < a.length; c++) a[c].update(b)
            },
            addToUpdate: function (b) {
                -1 === a.indexOf(b) && a.push(b)
            },
            removeFromUpdate: function (b) {
                b = a.indexOf(b); - 1 !== b && a.splice(b, 1)
            },
            add: function (a) {
                void 0 !== b[a.name] && console.log("THREE.AnimationHandler.add: Warning! " + a.name + " already exists in library. Overwriting.");
                b[a.name] = a;
                if (!0 !== a.initialized) {
                    for (var c = 0; c < a.hierarchy.length; c++) {
                        for (var d = 0; d < a.hierarchy[c].keys.length; d++)
                            if (0 > a.hierarchy[c].keys[d].time && (a.hierarchy[c].keys[d].time = 0), void 0 !== a.hierarchy[c].keys[d].rot && !(a.hierarchy[c].keys[d].rot instanceof THREE.Quaternion)) {
                                var g = a.hierarchy[c].keys[d].rot;
                                a.hierarchy[c].keys[d].rot = new THREE.Quaternion(g[0], g[1], g[2], g[3])
                            }
                        if (a.hierarchy[c].keys.length && void 0 !== a.hierarchy[c].keys[0].morphTargets) {
                            g = {};
                            for (d = 0; d < a.hierarchy[c].keys.length; d++)
                                for (var i = 0; i < a.hierarchy[c].keys[d].morphTargets.length; i++) {
                                    var k = a.hierarchy[c].keys[d].morphTargets[i];
                                    g[k] = -1
                                }
                            a.hierarchy[c].usedMorphTargets = g;
                            for (d = 0; d < a.hierarchy[c].keys.length; d++) {
                                var m = {};
                                for (k in g) {
                                    for (i = 0; i < a.hierarchy[c].keys[d].morphTargets.length; i++)
                                        if (a.hierarchy[c].keys[d].morphTargets[i] === k) {
                                            m[k] = a.hierarchy[c].keys[d].morphTargetsInfluences[i];
                                            break
                                        }
                                    i === a.hierarchy[c].keys[d].morphTargets.length && (m[k] = 0)
                                }
                                a.hierarchy[c].keys[d].morphTargetsInfluences = m
                            }
                        }
                        for (d = 1; d < a.hierarchy[c].keys.length; d++) a.hierarchy[c].keys[d].time === a.hierarchy[c].keys[d - 1].time && (a.hierarchy[c].keys.splice(d, 1), d--);
                        for (d = 0; d < a.hierarchy[c].keys.length; d++) a.hierarchy[c].keys[d].index = d
                    }
                    d = parseInt(a.length * a.fps, 10);
                    a.JIT = {};
                    a.JIT.hierarchy = [];
                    for (c = 0; c < a.hierarchy.length; c++) a.JIT.hierarchy.push(Array(d));
                    a.initialized = !0
                }
            },
            get: function (a) {
                if ("string" === typeof a) {
                    if (b[a]) return b[a];
                    console.log("THREE.AnimationHandler.get: Couldn't find animation " + a);
                    return null
                }
            },
            parse: function (a) {
                var b = [];
                if (a instanceof THREE.SkinnedMesh)
                    for (var c = 0; c < a.bones.length; c++) b.push(a.bones[c]);
                else d(a, b);
                return b
            }
        },
        d = function (a, b) {
            b.push(a);
            for (var c = 0; c < a.children.length; c++) d(a.children[c], b)
        };
    c.LINEAR = 0;
    c.CATMULLROM = 1;
    c.CATMULLROM_FORWARD = 2;
    return c
}();
THREE.Animation = function (a, b, c) {
    this.root = a;
    this.data = THREE.AnimationHandler.get(b);
    this.hierarchy = THREE.AnimationHandler.parse(a);
    this.currentTime = 0;
    this.timeScale = 1;
    this.isPlaying = !1;
    this.loop = this.isPaused = !0;
    this.interpolationType = void 0 !== c ? c : THREE.AnimationHandler.LINEAR;
    this.points = [];
    this.target = new THREE.Vector3
};
THREE.Animation.prototype.play = function (a, b) {
    if (!1 === this.isPlaying) {
        this.isPlaying = !0;
        this.loop = void 0 !== a ? a : !0;
        this.currentTime = void 0 !== b ? b : 0;
        var c, d = this.hierarchy.length,
            e;
        for (c = 0; c < d; c++) {
            e = this.hierarchy[c];
            e.matrixAutoUpdate = !0;
            void 0 === e.animationCache && (e.animationCache = {}, e.animationCache.prevKey = {
                pos: 0,
                rot: 0,
                scl: 0
            }, e.animationCache.nextKey = {
                pos: 0,
                rot: 0,
                scl: 0
            }, e.animationCache.originalMatrix = e instanceof THREE.Bone ? e.skinMatrix : e.matrix);
            var f = e.animationCache.prevKey;
            e = e.animationCache.nextKey;
            f.pos = this.data.hierarchy[c].keys[0];
            f.rot = this.data.hierarchy[c].keys[0];
            f.scl = this.data.hierarchy[c].keys[0];
            e.pos = this.getNextKeyWith("pos", c, 1);
            e.rot = this.getNextKeyWith("rot", c, 1);
            e.scl = this.getNextKeyWith("scl", c, 1)
        }
        this.update(0)
    }
    this.isPaused = !1;
    THREE.AnimationHandler.addToUpdate(this)
};
THREE.Animation.prototype.pause = function () {
    !0 === this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
    this.isPaused = !this.isPaused
};
THREE.Animation.prototype.stop = function () {
    this.isPaused = this.isPlaying = !1;
    THREE.AnimationHandler.removeFromUpdate(this)
};
THREE.Animation.prototype.update = function (a) {
    if (!1 !== this.isPlaying) {
        var b = ["pos", "rot", "scl"],
            c, d, e, f, h, g, i, k, m;
        m = this.currentTime += a * this.timeScale;
        k = this.currentTime %= this.data.length;
        parseInt(Math.min(k * this.data.fps, this.data.length * this.data.fps), 10);
        for (var l = 0, p = this.hierarchy.length; l < p; l++) {
            a = this.hierarchy[l];
            i = a.animationCache;
            for (var r = 0; 3 > r; r++) {
                c = b[r];
                h = i.prevKey[c];
                g = i.nextKey[c];
                if (g.time <= m) {
                    if (k < m)
                        if (this.loop) {
                            h = this.data.hierarchy[l].keys[0];
                            for (g = this.getNextKeyWith(c, l, 1); g.time < k;) h = g, g = this.getNextKeyWith(c, l, g.index + 1)
                        } else {
                            this.stop();
                            return
                        } else {
                        do h = g, g = this.getNextKeyWith(c, l, g.index + 1); while (g.time < k)
                    }
                    i.prevKey[c] = h;
                    i.nextKey[c] = g
                }
                a.matrixAutoUpdate = !0;
                a.matrixWorldNeedsUpdate = !0;
                d = (k - h.time) / (g.time - h.time);
                e = h[c];
                f = g[c];
                if (0 > d || 1 < d) console.log("THREE.Animation.update: Warning! Scale out of bounds:" + d + " on bone " + l), d = 0 > d ? 0 : 1;
                if ("pos" === c)
                    if (c = a.position, this.interpolationType === THREE.AnimationHandler.LINEAR) c.x = e[0] + (f[0] - e[0]) * d, c.y = e[1] + (f[1] - e[1]) * d, c.z = e[2] + (f[2] - e[2]) * d;
                    else {
                        if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) this.points[0] = this.getPrevKeyWith("pos", l, h.index - 1).pos, this.points[1] = e, this.points[2] = f, this.points[3] = this.getNextKeyWith("pos", l, g.index + 1).pos, d = .33 * d + .33, e = this.interpolateCatmullRom(this.points, d), c.x = e[0], c.y = e[1], c.z = e[2], this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (d = this.interpolateCatmullRom(this.points, 1.01 * d), this.target.set(d[0], d[1], d[2]), this.target.sub(c), this.target.y = 0, this.target.normalize(), d = Math.atan2(this.target.x, this.target.z), a.rotation.set(0, d, 0))
                    } else "rot" === c ? THREE.Quaternion.slerp(e, f, a.quaternion, d) : "scl" === c && (c = a.scale, c.x = e[0] + (f[0] - e[0]) * d, c.y = e[1] + (f[1] - e[1]) * d, c.z = e[2] + (f[2] - e[2]) * d)
            }
        }
    }
};
THREE.Animation.prototype.interpolateCatmullRom = function (a, b) {
    var c = [],
        d = [],
        e, f, h, g, i, k;
    e = (a.length - 1) * b;
    f = Math.floor(e);
    e -= f;
    c[0] = 0 === f ? f : f - 1;
    c[1] = f;
    c[2] = f > a.length - 2 ? f : f + 1;
    c[3] = f > a.length - 3 ? f : f + 2;
    f = a[c[0]];
    g = a[c[1]];
    i = a[c[2]];
    k = a[c[3]];
    c = e * e;
    h = e * c;
    d[0] = this.interpolate(f[0], g[0], i[0], k[0], e, c, h);
    d[1] = this.interpolate(f[1], g[1], i[1], k[1], e, c, h);
    d[2] = this.interpolate(f[2], g[2], i[2], k[2], e, c, h);
    return d
};
THREE.Animation.prototype.interpolate = function (a, b, c, d, e, f, h) {
    a = .5 * (c - a);
    d = .5 * (d - b);
    return (2 * (b - c) + a + d) * h + (-3 * (b - c) - 2 * a - d) * f + a * e + b
};
THREE.Animation.prototype.getNextKeyWith = function (a, b, c) {
    for (var d = this.data.hierarchy[b].keys, c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c < d.length - 1 ? c : d.length - 1 : c % d.length; c < d.length; c++)
        if (void 0 !== d[c][a]) return d[c];
    return this.data.hierarchy[b].keys[0]
};
THREE.Animation.prototype.getPrevKeyWith = function (a, b, c) {
    for (var d = this.data.hierarchy[b].keys, c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < c ? c : 0 : 0 <= c ? c : c + d.length; 0 <= c; c--)
        if (void 0 !== d[c][a]) return d[c];
    return this.data.hierarchy[b].keys[d.length - 1]
};
THREE.KeyFrameAnimation = function (a, b, c) {
    this.root = a;
    this.data = THREE.AnimationHandler.get(b);
    this.hierarchy = THREE.AnimationHandler.parse(a);
    this.currentTime = 0;
    this.timeScale = .001;
    this.isPlaying = !1;
    this.loop = this.isPaused = !0;
    this.JITCompile = void 0 !== c ? c : !0;
    a = 0;
    for (b = this.hierarchy.length; a < b; a++) {
        var c = this.data.hierarchy[a].sids,
            d = this.hierarchy[a];
        if (this.data.hierarchy[a].keys.length && c) {
            for (var e = 0; e < c.length; e++) {
                var f = c[e],
                    h = this.getNextKeyWith(f, a, 0);
                h && h.apply(f)
            }
            d.matrixAutoUpdate = !1;
            this.data.hierarchy[a].node.updateMatrix();
            d.matrixWorldNeedsUpdate = !0
        }
    }
};
THREE.KeyFrameAnimation.prototype.play = function (a, b) {
    if (!this.isPlaying) {
        this.isPlaying = !0;
        this.loop = void 0 !== a ? a : !0;
        this.currentTime = void 0 !== b ? b : 0;
        this.startTimeMs = b;
        this.startTime = 1e7;
        this.endTime = -this.startTime;
        var c, d = this.hierarchy.length,
            e, f;
        for (c = 0; c < d; c++) e = this.hierarchy[c], f = this.data.hierarchy[c], void 0 === f.animationCache && (f.animationCache = {}, f.animationCache.prevKey = null, f.animationCache.nextKey = null, f.animationCache.originalMatrix = e instanceof THREE.Bone ? e.skinMatrix : e.matrix), e = this.data.hierarchy[c].keys, e.length && (f.animationCache.prevKey = e[0], f.animationCache.nextKey = e[1], this.startTime = Math.min(e[0].time, this.startTime), this.endTime = Math.max(e[e.length - 1].time, this.endTime));
        this.update(0)
    }
    this.isPaused = !1;
    THREE.AnimationHandler.addToUpdate(this)
};
THREE.KeyFrameAnimation.prototype.pause = function () {
    this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
    this.isPaused = !this.isPaused
};
THREE.KeyFrameAnimation.prototype.stop = function () {
    this.isPaused = this.isPlaying = !1;
    THREE.AnimationHandler.removeFromUpdate(this);
    for (var a = 0; a < this.data.hierarchy.length; a++) {
        var b = this.hierarchy[a],
            c = this.data.hierarchy[a];
        if (void 0 !== c.animationCache) {
            var d = c.animationCache.originalMatrix;
            b instanceof THREE.Bone ? (d.copy(b.skinMatrix), b.skinMatrix = d) : (d.copy(b.matrix), b.matrix = d);
            delete c.animationCache
        }
    }
};
THREE.KeyFrameAnimation.prototype.update = function (a) {
    if (this.isPlaying) {
        var b, c, d, e, f = this.data.JIT.hierarchy,
            h, g, i;
        g = this.currentTime += a * this.timeScale;
        h = this.currentTime %= this.data.length;
        h < this.startTimeMs && (h = this.currentTime = this.startTimeMs + h);
        e = parseInt(Math.min(h * this.data.fps, this.data.length * this.data.fps), 10);
        if ((i = h < g) && !this.loop) {
            for (var a = 0, k = this.hierarchy.length; a < k; a++) {
                var m = this.data.hierarchy[a].keys,
                    f = this.data.hierarchy[a].sids;
                d = m.length - 1;
                e = this.hierarchy[a];
                if (m.length) {
                    for (m = 0; m < f.length; m++) h = f[m], (g = this.getPrevKeyWith(h, a, d)) && g.apply(h);
                    this.data.hierarchy[a].node.updateMatrix();
                    e.matrixWorldNeedsUpdate = !0
                }
            }
            this.stop()
        } else if (!(h < this.startTime)) {
            a = 0;
            for (k = this.hierarchy.length; a < k; a++) {
                d = this.hierarchy[a];
                b = this.data.hierarchy[a];
                var m = b.keys,
                    l = b.animationCache;
                if (this.JITCompile && void 0 !== f[a][e]) d instanceof THREE.Bone ? (d.skinMatrix = f[a][e], d.matrixWorldNeedsUpdate = !1) : (d.matrix = f[a][e], d.matrixWorldNeedsUpdate = !0);
                else if (m.length) {
                    this.JITCompile && l && (d instanceof THREE.Bone ? d.skinMatrix = l.originalMatrix : d.matrix = l.originalMatrix);
                    b = l.prevKey;
                    c = l.nextKey;
                    if (b && c) {
                        if (c.time <= g) {
                            if (i && this.loop) {
                                b = m[0];
                                for (c = m[1]; c.time < h;) b = c, c = m[b.index + 1]
                            } else if (!i)
                                for (var p = m.length - 1; c.time < h && c.index !== p;) b = c, c = m[b.index + 1];
                            l.prevKey = b;
                            l.nextKey = c
                        }
                        c.time >= h ? b.interpolate(c, h) : b.interpolate(c, c.time)
                    }
                    this.data.hierarchy[a].node.updateMatrix();
                    d.matrixWorldNeedsUpdate = !0
                }
            }
            if (this.JITCompile && void 0 === f[0][e]) {
                this.hierarchy[0].updateMatrixWorld(!0);
                for (a = 0; a < this.hierarchy.length; a++) f[a][e] = this.hierarchy[a] instanceof THREE.Bone ? this.hierarchy[a].skinMatrix.clone() : this.hierarchy[a].matrix.clone()
            }
        }
    }
};
THREE.KeyFrameAnimation.prototype.getNextKeyWith = function (a, b, c) {
    b = this.data.hierarchy[b].keys;
    for (c %= b.length; c < b.length; c++)
        if (b[c].hasTarget(a)) return b[c];
    return b[0]
};
THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (a, b, c) {
    b = this.data.hierarchy[b].keys;
    for (c = 0 <= c ? c : c + b.length; 0 <= c; c--)
        if (b[c].hasTarget(a)) return b[c];
    return b[b.length - 1]
};
THREE.CubeCamera = function (a, b, c) {
    THREE.Object3D.call(this);
    var d = new THREE.PerspectiveCamera(90, 1, a, b);
    d.up.set(0, -1, 0);
    d.lookAt(new THREE.Vector3(1, 0, 0));
    this.add(d);
    var e = new THREE.PerspectiveCamera(90, 1, a, b);
    e.up.set(0, -1, 0);
    e.lookAt(new THREE.Vector3(-1, 0, 0));
    this.add(e);
    var f = new THREE.PerspectiveCamera(90, 1, a, b);
    f.up.set(0, 0, 1);
    f.lookAt(new THREE.Vector3(0, 1, 0));
    this.add(f);
    var h = new THREE.PerspectiveCamera(90, 1, a, b);
    h.up.set(0, 0, -1);
    h.lookAt(new THREE.Vector3(0, -1, 0));
    this.add(h);
    var g = new THREE.PerspectiveCamera(90, 1, a, b);
    g.up.set(0, -1, 0);
    g.lookAt(new THREE.Vector3(0, 0, 1));
    this.add(g);
    var i = new THREE.PerspectiveCamera(90, 1, a, b);
    i.up.set(0, -1, 0);
    i.lookAt(new THREE.Vector3(0, 0, -1));
    this.add(i);
    this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
    });
    this.updateCubeMap = function (a, b) {
        var c = this.renderTarget,
            p = c.generateMipmaps;
        c.generateMipmaps = !1;
        c.activeCubeFace = 0;
        a.render(b, d, c);
        c.activeCubeFace = 1;
        a.render(b, e, c);
        c.activeCubeFace = 2;
        a.render(b, f, c);
        c.activeCubeFace = 3;
        a.render(b, h, c);
        c.activeCubeFace = 4;
        a.render(b, g, c);
        c.generateMipmaps = p;
        c.activeCubeFace = 5;
        a.render(b, i, c)
    }
};
THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
THREE.CombinedCamera = function (a, b, c, d, e, f, h) {
    THREE.Camera.call(this);
    this.fov = c;
    this.left = -a / 2;
    this.right = a / 2;
    this.top = b / 2;
    this.bottom = -b / 2;
    this.cameraO = new THREE.OrthographicCamera(a / -2, a / 2, b / 2, b / -2, f, h);
    this.cameraP = new THREE.PerspectiveCamera(c, a / b, d, e);
    this.zoom = 1;
    this.toPerspective()
};
THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.CombinedCamera.prototype.toPerspective = function () {
    this.near = this.cameraP.near;
    this.far = this.cameraP.far;
    this.cameraP.fov = this.fov / this.zoom;
    this.cameraP.updateProjectionMatrix();
    this.projectionMatrix = this.cameraP.projectionMatrix;
    this.inPerspectiveMode = !0;
    this.inOrthographicMode = !1
};
THREE.CombinedCamera.prototype.toOrthographic = function () {
    var a = this.cameraP.aspect,
        b = (this.cameraP.near + this.cameraP.far) / 2,
        b = Math.tan(this.fov / 2) * b,
        a = 2 * b * a / 2,
        b = b / this.zoom,
        a = a / this.zoom;
    this.cameraO.left = -a;
    this.cameraO.right = a;
    this.cameraO.top = b;
    this.cameraO.bottom = -b;
    this.cameraO.updateProjectionMatrix();
    this.near = this.cameraO.near;
    this.far = this.cameraO.far;
    this.projectionMatrix = this.cameraO.projectionMatrix;
    this.inPerspectiveMode = !1;
    this.inOrthographicMode = !0
};
THREE.CombinedCamera.prototype.setSize = function (a, b) {
    this.cameraP.aspect = a / b;
    this.left = -a / 2;
    this.right = a / 2;
    this.top = b / 2;
    this.bottom = -b / 2
};
THREE.CombinedCamera.prototype.setFov = function (a) {
    this.fov = a;
    this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic()
};
THREE.CombinedCamera.prototype.updateProjectionMatrix = function () {
    this.inPerspectiveMode ? this.toPerspective() : (this.toPerspective(), this.toOrthographic())
};
THREE.CombinedCamera.prototype.setLens = function (a, b) {
    void 0 === b && (b = 24);
    var c = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
    this.setFov(c);
    return c
};
THREE.CombinedCamera.prototype.setZoom = function (a) {
    this.zoom = a;
    this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic()
};
THREE.CombinedCamera.prototype.toFrontView = function () {
    this.rotation.x = 0;
    this.rotation.y = 0;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
};
THREE.CombinedCamera.prototype.toBackView = function () {
    this.rotation.x = 0;
    this.rotation.y = Math.PI;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
};
THREE.CombinedCamera.prototype.toLeftView = function () {
    this.rotation.x = 0;
    this.rotation.y = -Math.PI / 2;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
};
THREE.CombinedCamera.prototype.toRightView = function () {
    this.rotation.x = 0;
    this.rotation.y = Math.PI / 2;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
};
THREE.CombinedCamera.prototype.toTopView = function () {
    this.rotation.x = -Math.PI / 2;
    this.rotation.y = 0;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
};
THREE.CombinedCamera.prototype.toBottomView = function () {
    this.rotation.x = Math.PI / 2;
    this.rotation.y = 0;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
};
THREE.CircleGeometry = function (a, b, c, d) {
    THREE.Geometry.call(this);
    this.radius = a = a || 50;
    this.segments = b = void 0 !== b ? Math.max(3, b) : 8;
    this.thetaStart = c = void 0 !== c ? c : 0;
    this.thetaLength = d = void 0 !== d ? d : 2 * Math.PI;
    var e, f = [];
    e = new THREE.Vector3;
    var h = new THREE.Vector2(.5, .5);
    this.vertices.push(e);
    f.push(h);
    for (e = 0; e <= b; e++) {
        var g = new THREE.Vector3,
            i = c + e / b * d;
        g.x = a * Math.cos(i);
        g.y = a * Math.sin(i);
        this.vertices.push(g);
        f.push(new THREE.Vector2((g.x / a + 1) / 2, (g.y / a + 1) / 2))
    }
    c = new THREE.Vector3(0, 0, 1);
    for (e = 1; e <= b; e++) this.faces.push(new THREE.Face3(e, e + 1, 0, [c, c, c])), this.faceVertexUvs[0].push([f[e], f[e + 1], h]);
    this.computeCentroids();
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
};
THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CubeGeometry = function (a, b, c, d, e, f) {
    function h(a, b, c, d, e, f, h, n) {
        var s, q = g.widthSegments,
            u = g.heightSegments,
            w = e / 2,
            E = f / 2,
            C = g.vertices.length;
        if ("x" === a && "y" === b || "y" === a && "x" === b) s = "z";
        else if ("x" === a && "z" === b || "z" === a && "x" === b) s = "y", u = g.depthSegments;
        else if ("z" === a && "y" === b || "y" === a && "z" === b) s = "x", q = g.depthSegments;
        var F = q + 1,
            y = u + 1,
            A = e / q,
            z = f / u,
            O = new THREE.Vector3;
        O[s] = 0 < h ? 1 : -1;
        for (e = 0; e < y; e++)
            for (f = 0; f < F; f++) {
                var B = new THREE.Vector3;
                B[a] = (f * A - w) * c;
                B[b] = (e * z - E) * d;
                B[s] = h;
                g.vertices.push(B)
            }
        for (e = 0; e < u; e++)
            for (f = 0; f < q; f++) E = f + F * e, a = f + F * (e + 1), b = f + 1 + F * (e + 1), c = f + 1 + F * e, d = new THREE.Vector2(f / q, 1 - e / u), h = new THREE.Vector2(f / q, 1 - (e + 1) / u), s = new THREE.Vector2((f + 1) / q, 1 - (e + 1) / u), w = new THREE.Vector2((f + 1) / q, 1 - e / u), E = new THREE.Face3(E + C, a + C, c + C), E.normal.copy(O), E.vertexNormals.push(O.clone(), O.clone(), O.clone()), E.materialIndex = n, g.faces.push(E), g.faceVertexUvs[0].push([d, h, w]), E = new THREE.Face3(a + C, b + C, c + C), E.normal.copy(O), E.vertexNormals.push(O.clone(), O.clone(), O.clone()), E.materialIndex = n, g.faces.push(E), g.faceVertexUvs[0].push([h.clone(), s, w.clone()])
    }
    THREE.Geometry.call(this);
    var g = this;
    this.width = a;
    this.height = b;
    this.depth = c;
    this.widthSegments = d || 1;
    this.heightSegments = e || 1;
    this.depthSegments = f || 1;
    a = this.width / 2;
    b = this.height / 2;
    c = this.depth / 2;
    h("z", "y", -1, -1, this.depth, this.height, a, 0);
    h("z", "y", 1, -1, this.depth, this.height, -a, 1);
    h("x", "z", 1, 1, this.width, this.depth, b, 2);
    h("x", "z", 1, -1, this.width, this.depth, -b, 3);
    h("x", "y", 1, -1, this.width, this.height, c, 4);
    h("x", "y", -1, -1, this.width, this.height, -c, 5);
    this.computeCentroids();
    this.mergeVertices()
};
THREE.CubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CylinderGeometry = function (a, b, c, d, e, f) {
    THREE.Geometry.call(this);
    this.radiusTop = a = void 0 !== a ? a : 20;
    this.radiusBottom = b = void 0 !== b ? b : 20;
    this.height = c = void 0 !== c ? c : 100;
    this.radialSegments = d = d || 8;
    this.heightSegments = e = e || 1;
    this.openEnded = f = void 0 !== f ? f : !1;
    var h = c / 2,
        g, i, k = [],
        m = [];
    for (i = 0; i <= e; i++) {
        var l = [],
            p = [],
            r = i / e,
            t = r * (b - a) + a;
        for (g = 0; g <= d; g++) {
            var n = g / d,
                s = new THREE.Vector3;
            s.x = t * Math.sin(2 * n * Math.PI);
            s.y = -r * c + h;
            s.z = t * Math.cos(2 * n * Math.PI);
            this.vertices.push(s);
            l.push(this.vertices.length - 1);
            p.push(new THREE.Vector2(n, 1 - r))
        }
        k.push(l);
        m.push(p)
    }
    c = (b - a) / c;
    for (g = 0; g < d; g++) {
        0 !== a ? (l = this.vertices[k[0][g]].clone(), p = this.vertices[k[0][g + 1]].clone()) : (l = this.vertices[k[1][g]].clone(), p = this.vertices[k[1][g + 1]].clone());
        l.setY(Math.sqrt(l.x * l.x + l.z * l.z) * c).normalize();
        p.setY(Math.sqrt(p.x * p.x + p.z * p.z) * c).normalize();
        for (i = 0; i < e; i++) {
            var r = k[i][g],
                t = k[i + 1][g],
                n = k[i + 1][g + 1],
                s = k[i][g + 1],
                q = l.clone(),
                u = l.clone(),
                w = p.clone(),
                E = p.clone(),
                C = m[i][g].clone(),
                F = m[i + 1][g].clone(),
                y = m[i + 1][g + 1].clone(),
                A = m[i][g + 1].clone();
            this.faces.push(new THREE.Face3(r, t, s, [q, u, E]));
            this.faceVertexUvs[0].push([C, F, A]);
            this.faces.push(new THREE.Face3(t, n, s, [u, w, E]));
            this.faceVertexUvs[0].push([F, y, A])
        }
    }
    if (!1 === f && 0 < a) {
        this.vertices.push(new THREE.Vector3(0, h, 0));
        for (g = 0; g < d; g++) r = k[0][g], t = k[0][g + 1], n = this.vertices.length - 1, q = new THREE.Vector3(0, 1, 0), u = new THREE.Vector3(0, 1, 0), w = new THREE.Vector3(0, 1, 0), C = m[0][g].clone(), F = m[0][g + 1].clone(), y = new THREE.Vector2(F.u, 0), this.faces.push(new THREE.Face3(r, t, n, [q, u, w])), this.faceVertexUvs[0].push([C, F, y])
    }
    if (!1 === f && 0 < b) {
        this.vertices.push(new THREE.Vector3(0, -h, 0));
        for (g = 0; g < d; g++) r = k[i][g + 1], t = k[i][g], n = this.vertices.length - 1, q = new THREE.Vector3(0, -1, 0), u = new THREE.Vector3(0, -1, 0), w = new THREE.Vector3(0, -1, 0), C = m[i][g + 1].clone(), F = m[i][g].clone(), y = new THREE.Vector2(F.u, 1), this.faces.push(new THREE.Face3(r, t, n, [q, u, w])), this.faceVertexUvs[0].push([C, F, y])
    }
    this.computeCentroids();
    this.computeFaceNormals()
};
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry = function (a, b) {
    "undefined" !== typeof a && (THREE.Geometry.call(this), a = a instanceof Array ? a : [a], this.shapebb = a[a.length - 1].getBoundingBox(), this.addShapeList(a, b), this.computeCentroids(), this.computeFaceNormals())
};
THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry.prototype.addShapeList = function (a, b) {
    for (var c = a.length, d = 0; d < c; d++) this.addShape(a[d], b)
};
THREE.ExtrudeGeometry.prototype.addShape = function (a, b) {
    function c(a, b, c) {
        b || console.log("die");
        return b.clone().multiplyScalar(c).add(a)
    }

    function d(a, b, c) {
        var d = THREE.ExtrudeGeometry.__v1,
            e = THREE.ExtrudeGeometry.__v2,
            f = THREE.ExtrudeGeometry.__v3,
            g = THREE.ExtrudeGeometry.__v4,
            h = THREE.ExtrudeGeometry.__v5,
            i = THREE.ExtrudeGeometry.__v6;
        d.set(a.x - b.x, a.y - b.y);
        e.set(a.x - c.x, a.y - c.y);
        d = d.normalize();
        e = e.normalize();
        f.set(-d.y, d.x);
        g.set(e.y, -e.x);
        h.copy(a).add(f);
        i.copy(a).add(g);
        if (h.equals(i)) return g.clone();
        h.copy(b).add(f);
        i.copy(c).add(g);
        f = d.dot(g);
        g = i.sub(h).dot(g);
        0 === f && (console.log("Either infinite or no solutions!"), 0 === g ? console.log("Its finite solutions.") : console.log("Too bad, no solutions."));
        g /= f;
        return 0 > g ? (b = Math.atan2(b.y - a.y, b.x - a.x), a = Math.atan2(c.y - a.y, c.x - a.x), b > a && (a += 2 * Math.PI), c = (b + a) / 2, a = -Math.cos(c), c = -Math.sin(c), new THREE.Vector2(a, c)) : d.multiplyScalar(g).add(h).sub(a).clone()
    }

    function e(c, d) {
        var e, f;
        for (N = c.length; 0 <= --N;) {
            e = N;
            f = N - 1;
            0 > f && (f = c.length - 1);
            for (var g = 0, h = r + 2 * m, g = 0; g < h; g++) {
                var i = ca * g,
                    k = ca * (g + 1),
                    l = d + e + i,
                    i = d + f + i,
                    p = d + f + k,
                    k = d + e + k,
                    n = c,
                    q = g,
                    s = h,
                    t = e,
                    v = f,
                    l = l + D,
                    i = i + D,
                    p = p + D,
                    k = k + D;
                B.faces.push(new THREE.Face3(l, i, k, null, null, u));
                B.faces.push(new THREE.Face3(i, p, k, null, null, u));
                l = w.generateSideWallUV(B, a, n, b, l, i, p, k, q, s, t, v);
                B.faceVertexUvs[0].push([l[0], l[1], l[3]]);
                B.faceVertexUvs[0].push([l[1], l[2], l[3]])
            }
        }
    }

    function f(a, b, c) {
        B.vertices.push(new THREE.Vector3(a, b, c))
    }

    function h(c, d, e, f) {
        c += D;
        d += D;
        e += D;
        B.faces.push(new THREE.Face3(c, d, e, null, null, q));
        c = f ? w.generateBottomUV(B, a, b, c, d, e) : w.generateTopUV(B, a, b, c, d, e);
        B.faceVertexUvs[0].push(c)
    }
    var g = void 0 !== b.amount ? b.amount : 100,
        i = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
        k = void 0 !== b.bevelSize ? b.bevelSize : i - 2,
        m = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
        l = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0,
        p = void 0 !== b.curveSegments ? b.curveSegments : 12,
        r = void 0 !== b.steps ? b.steps : 1,
        t = b.extrudePath,
        n, s = !1,
        q = b.material,
        u = b.extrudeMaterial,
        w = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator,
        E, C, F, y;
    t && (n = t.getSpacedPoints(r), s = !0, l = !1, E = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(t, r, !1), C = new THREE.Vector3, F = new THREE.Vector3, y = new THREE.Vector3);
    l || (k = i = m = 0);
    var A, z, O, B = this,
        D = this.vertices.length,
        p = a.extractPoints(p),
        I = p.shape,
        p = p.holes;
    if (t = !THREE.Shape.Utils.isClockWise(I)) {
        I = I.reverse();
        z = 0;
        for (O = p.length; z < O; z++) A = p[z], THREE.Shape.Utils.isClockWise(A) && (p[z] = A.reverse());
        t = !1
    }
    var v = THREE.Shape.Utils.triangulateShape(I, p),
        t = I;
    z = 0;
    for (O = p.length; z < O; z++) A = p[z], I = I.concat(A);
    var x, G, Q, J, ca = I.length,
        oa = v.length,
        pa = [],
        N = 0,
        M = t.length;
    x = M - 1;
    for (G = N + 1; N < M; N++, x++, G++) x === M && (x = 0), G === M && (G = 0), pa[N] = d(t[N], t[x], t[G]);
    var R = [],
        K, da = pa.concat();
    z = 0;
    for (O = p.length; z < O; z++) {
        A = p[z];
        K = [];
        N = 0;
        M = A.length;
        x = M - 1;
        for (G = N + 1; N < M; N++, x++, G++) x === M && (x = 0), G === M && (G = 0), K[N] = d(A[N], A[x], A[G]);
        R.push(K);
        da = da.concat(K)
    }
    for (x = 0; x < m; x++) {
        A = x / m;
        Q = i * (1 - A);
        G = k * Math.sin(A * Math.PI / 2);
        N = 0;
        for (M = t.length; N < M; N++) J = c(t[N], pa[N], G), f(J.x, J.y, -Q);
        z = 0;
        for (O = p.length; z < O; z++) {
            A = p[z];
            K = R[z];
            N = 0;
            for (M = A.length; N < M; N++) J = c(A[N], K[N], G), f(J.x, J.y, -Q)
        }
    }
    G = k;
    for (N = 0; N < ca; N++) J = l ? c(I[N], da[N], G) : I[N], s ? (F.copy(E.normals[0]).multiplyScalar(J.x), C.copy(E.binormals[0]).multiplyScalar(J.y), y.copy(n[0]).add(F).add(C), f(y.x, y.y, y.z)) : f(J.x, J.y, 0);
    for (A = 1; A <= r; A++)
        for (N = 0; N < ca; N++) J = l ? c(I[N], da[N], G) : I[N], s ? (F.copy(E.normals[A]).multiplyScalar(J.x), C.copy(E.binormals[A]).multiplyScalar(J.y), y.copy(n[A]).add(F).add(C), f(y.x, y.y, y.z)) : f(J.x, J.y, g / r * A);
    for (x = m - 1; 0 <= x; x--) {
        A = x / m;
        Q = i * (1 - A);
        G = k * Math.sin(A * Math.PI / 2);
        N = 0;
        for (M = t.length; N < M; N++) J = c(t[N], pa[N], G), f(J.x, J.y, g + Q);
        z = 0;
        for (O = p.length; z < O; z++) {
            A = p[z];
            K = R[z];
            N = 0;
            for (M = A.length; N < M; N++) J = c(A[N], K[N], G), s ? f(J.x, J.y + n[r - 1].y, n[r - 1].x + Q) : f(J.x, J.y, g + Q)
        }
    }
    if (l) {
        i = 0 * ca;
        for (N = 0; N < oa; N++) g = v[N], h(g[2] + i, g[1] + i, g[0] + i, !0);
        i = ca * (r + 2 * m);
        for (N = 0; N < oa; N++) g = v[N], h(g[0] + i, g[1] + i, g[2] + i, !1)
    } else {
        for (N = 0; N < oa; N++) g = v[N], h(g[2], g[1], g[0], !0);
        for (N = 0; N < oa; N++) g = v[N], h(g[0] + ca * r, g[1] + ca * r, g[2] + ca * r, !1)
    }
    g = 0;
    e(t, g);
    g += t.length;
    z = 0;
    for (O = p.length; z < O; z++) A = p[z], e(A, g), g += A.length
};
THREE.ExtrudeGeometry.WorldUVGenerator = {
    generateTopUV: function (a, b, c, d, e, f) {
        b = a.vertices[e].x;
        e = a.vertices[e].y;
        c = a.vertices[f].x;
        f = a.vertices[f].y;
        return [new THREE.Vector2(a.vertices[d].x, a.vertices[d].y), new THREE.Vector2(b, e), new THREE.Vector2(c, f)]
    },
    generateBottomUV: function (a, b, c, d, e, f) {
        return this.generateTopUV(a, b, c, d, e, f)
    },
    generateSideWallUV: function (a, b, c, d, e, f, h, g) {
        var b = a.vertices[e].x,
            c = a.vertices[e].y,
            e = a.vertices[e].z,
            d = a.vertices[f].x,
            i = a.vertices[f].y,
            f = a.vertices[f].z,
            k = a.vertices[h].x,
            m = a.vertices[h].y,
            h = a.vertices[h].z,
            l = a.vertices[g].x,
            p = a.vertices[g].y,
            a = a.vertices[g].z;
        return .01 > Math.abs(c - i) ? [new THREE.Vector2(b, 1 - e), new THREE.Vector2(d, 1 - f), new THREE.Vector2(k, 1 - h), new THREE.Vector2(l, 1 - a)] : [new THREE.Vector2(c, 1 - e), new THREE.Vector2(i, 1 - f), new THREE.Vector2(m, 1 - h), new THREE.Vector2(p, 1 - a)]
    }
};
THREE.ExtrudeGeometry.__v1 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2;
THREE.ShapeGeometry = function (a, b) {
    THREE.Geometry.call(this);
    !1 === a instanceof Array && (a = [a]);
    this.shapebb = a[a.length - 1].getBoundingBox();
    this.addShapeList(a, b);
    this.computeCentroids();
    this.computeFaceNormals()
};
THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ShapeGeometry.prototype.addShapeList = function (a, b) {
    for (var c = 0, d = a.length; c < d; c++) this.addShape(a[c], b);
    return this
};
THREE.ShapeGeometry.prototype.addShape = function (a, b) {
    void 0 === b && (b = {});
    var c = b.material,
        d = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator,
        e, f, h, g = this.vertices.length;
    e = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
    var i = e.shape,
        k = e.holes;
    if (!THREE.Shape.Utils.isClockWise(i)) {
        i = i.reverse();
        e = 0;
        for (f = k.length; e < f; e++) h = k[e], THREE.Shape.Utils.isClockWise(h) && (k[e] = h.reverse())
    }
    var m = THREE.Shape.Utils.triangulateShape(i, k);
    e = 0;
    for (f = k.length; e < f; e++) h = k[e], i = i.concat(h);
    k = i.length;
    f = m.length;
    for (e = 0; e < k; e++) h = i[e], this.vertices.push(new THREE.Vector3(h.x, h.y, 0));
    for (e = 0; e < f; e++) k = m[e], i = k[0] + g, h = k[1] + g, k = k[2] + g, this.faces.push(new THREE.Face3(i, h, k, null, null, c)), this.faceVertexUvs[0].push(d.generateBottomUV(this, a, b, i, h, k))
};
THREE.LatheGeometry = function (a, b, c, d) {
    THREE.Geometry.call(this);
    for (var b = b || 12, c = c || 0, d = d || 2 * Math.PI, e = 1 / (a.length - 1), f = 1 / b, h = 0, g = b; h <= g; h++)
        for (var i = c + h * f * d, k = Math.cos(i), m = Math.sin(i), i = 0, l = a.length; i < l; i++) {
            var p = a[i],
                r = new THREE.Vector3;
            r.x = k * p.x - m * p.y;
            r.y = m * p.x + k * p.y;
            r.z = p.z;
            this.vertices.push(r)
        }
    c = a.length;
    h = 0;
    for (g = b; h < g; h++) {
        i = 0;
        for (l = a.length - 1; i < l; i++) {
            var b = m = i + c * h,
                d = m + c,
                k = m + 1 + c,
                m = m + 1,
                p = h * f,
                r = i * e,
                t = p + f,
                n = r + e;
            this.faces.push(new THREE.Face3(b, d, m));
            this.faceVertexUvs[0].push([new THREE.Vector2(p, r), new THREE.Vector2(t, r), new THREE.Vector2(p, n)]);
            this.faces.push(new THREE.Face3(d, k, m));
            this.faceVertexUvs[0].push([new THREE.Vector2(t, r), new THREE.Vector2(t, n), new THREE.Vector2(p, n)])
        }
    }
    this.mergeVertices();
    this.computeCentroids();
    this.computeFaceNormals();
    this.computeVertexNormals()
};
THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry = function (a, b, c, d) {
    THREE.Geometry.call(this);
    this.width = a;
    this.height = b;
    this.widthSegments = c || 1;
    this.heightSegments = d || 1;
    for (var e = a / 2, f = b / 2, c = this.widthSegments, d = this.heightSegments, h = c + 1, g = d + 1, i = this.width / c, k = this.height / d, m = new THREE.Vector3(0, 0, 1), a = 0; a < g; a++)
        for (b = 0; b < h; b++) this.vertices.push(new THREE.Vector3(b * i - e, -(a * k - f), 0));
    for (a = 0; a < d; a++)
        for (b = 0; b < c; b++) {
            var l = b + h * a,
                e = b + h * (a + 1),
                f = b + 1 + h * (a + 1),
                g = b + 1 + h * a,
                i = new THREE.Vector2(b / c, 1 - a / d),
                k = new THREE.Vector2(b / c, 1 - (a + 1) / d),
                p = new THREE.Vector2((b + 1) / c, 1 - (a + 1) / d),
                r = new THREE.Vector2((b + 1) / c, 1 - a / d),
                l = new THREE.Face3(l, e, g);
            l.normal.copy(m);
            l.vertexNormals.push(m.clone(), m.clone(), m.clone());
            this.faces.push(l);
            this.faceVertexUvs[0].push([i, k, r]);
            l = new THREE.Face3(e, f, g);
            l.normal.copy(m);
            l.vertexNormals.push(m.clone(), m.clone(), m.clone());
            this.faces.push(l);
            this.faceVertexUvs[0].push([k.clone(), p, r.clone()])
        }
    this.computeCentroids()
};
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.RingGeometry = function (a, b, c, d, e, f) {
    THREE.Geometry.call(this);
    for (var a = a || 0, b = b || 50, e = void 0 !== e ? e : 0, f = void 0 !== f ? f : 2 * Math.PI, c = void 0 !== c ? Math.max(3, c) : 8, d = void 0 !== d ? Math.max(3, d) : 8, h = [], g = a, i = (b - a) / d, a = 0; a <= d; a++) {
        for (b = 0; b <= c; b++) {
            var k = new THREE.Vector3,
                m = e + b / c * f;
            k.x = g * Math.cos(m);
            k.y = g * Math.sin(m);
            this.vertices.push(k);
            h.push(new THREE.Vector2((k.x / g + 1) / 2, -(k.y / g + 1) / 2 + 1))
        }
        g += i
    }
    e = new THREE.Vector3(0, 0, 1);
    for (a = 0; a < d; a++) {
        f = a * c;
        for (b = 0; b <= c; b++) {
            var m = b + f,
                i = m + a,
                k = m + c + a,
                l = m + c + 1 + a;
            this.faces.push(new THREE.Face3(i, k, l, [e, e, e]));
            this.faceVertexUvs[0].push([h[i], h[k], h[l]]);
            i = m + a;
            k = m + c + 1 + a;
            l = m + 1 + a;
            this.faces.push(new THREE.Face3(i, k, l, [e, e, e]));
            this.faceVertexUvs[0].push([h[i], h[k], h[l]])
        }
    }
    this.computeCentroids();
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3, g)
};
THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry = function (a, b, c, d, e, f, h) {
    THREE.Geometry.call(this);
    this.radius = a = a || 50;
    this.widthSegments = b = Math.max(3, Math.floor(b) || 8);
    this.heightSegments = c = Math.max(2, Math.floor(c) || 6);
    this.phiStart = d = void 0 !== d ? d : 0;
    this.phiLength = e = void 0 !== e ? e : 2 * Math.PI;
    this.thetaStart = f = void 0 !== f ? f : 0;
    this.thetaLength = h = void 0 !== h ? h : Math.PI;
    var g, i, k = [],
        m = [];
    for (i = 0; i <= c; i++) {
        var l = [],
            p = [];
        for (g = 0; g <= b; g++) {
            var r = g / b,
                t = i / c,
                n = new THREE.Vector3;
            n.x = -a * Math.cos(d + r * e) * Math.sin(f + t * h);
            n.y = a * Math.cos(f + t * h);
            n.z = a * Math.sin(d + r * e) * Math.sin(f + t * h);
            this.vertices.push(n);
            l.push(this.vertices.length - 1);
            p.push(new THREE.Vector2(r, 1 - t))
        }
        k.push(l);
        m.push(p)
    }
    for (i = 0; i < this.heightSegments; i++)
        for (g = 0; g < this.widthSegments; g++) {
            var b = k[i][g + 1],
                c = k[i][g],
                d = k[i + 1][g],
                e = k[i + 1][g + 1],
                f = this.vertices[b].clone().normalize(),
                h = this.vertices[c].clone().normalize(),
                l = this.vertices[d].clone().normalize(),
                p = this.vertices[e].clone().normalize(),
                r = m[i][g + 1].clone(),
                t = m[i][g].clone(),
                n = m[i + 1][g].clone(),
                s = m[i + 1][g + 1].clone();
            Math.abs(this.vertices[b].y) === this.radius ? (this.faces.push(new THREE.Face3(b, d, e, [f, l, p])), this.faceVertexUvs[0].push([r, n, s])) : Math.abs(this.vertices[d].y) === this.radius ? (this.faces.push(new THREE.Face3(b, c, d, [f, h, l])), this.faceVertexUvs[0].push([r, t, n])) : (this.faces.push(new THREE.Face3(b, c, e, [f, h, p])), this.faceVertexUvs[0].push([r, t, s]), this.faces.push(new THREE.Face3(c, d, e, [h, l, p])), this.faceVertexUvs[0].push([t.clone(), n, s.clone()]))
        }
    this.computeCentroids();
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
};
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TextGeometry = function (a, b) {
    var b = b || {},
        c = THREE.FontUtils.generateShapes(a, b);
    b.amount = void 0 !== b.height ? b.height : 50;
    void 0 === b.bevelThickness && (b.bevelThickness = 10);
    void 0 === b.bevelSize && (b.bevelSize = 8);
    void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
    THREE.ExtrudeGeometry.call(this, c, b)
};
THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
THREE.TorusGeometry = function (a, b, c, d, e) {
    THREE.Geometry.call(this);
    this.radius = a || 100;
    this.tube = b || 40;
    this.radialSegments = c || 8;
    this.tubularSegments = d || 6;
    this.arc = e || 2 * Math.PI;
    e = new THREE.Vector3;
    a = [];
    b = [];
    for (c = 0; c <= this.radialSegments; c++)
        for (d = 0; d <= this.tubularSegments; d++) {
            var f = d / this.tubularSegments * this.arc,
                h = 2 * c / this.radialSegments * Math.PI;
            e.x = this.radius * Math.cos(f);
            e.y = this.radius * Math.sin(f);
            var g = new THREE.Vector3;
            g.x = (this.radius + this.tube * Math.cos(h)) * Math.cos(f);
            g.y = (this.radius + this.tube * Math.cos(h)) * Math.sin(f);
            g.z = this.tube * Math.sin(h);
            this.vertices.push(g);
            a.push(new THREE.Vector2(d / this.tubularSegments, c / this.radialSegments));
            b.push(g.clone().sub(e).normalize())
        }
    for (c = 1; c <= this.radialSegments; c++)
        for (d = 1; d <= this.tubularSegments; d++) {
            var e = (this.tubularSegments + 1) * c + d - 1,
                f = (this.tubularSegments + 1) * (c - 1) + d - 1,
                h = (this.tubularSegments + 1) * (c - 1) + d,
                g = (this.tubularSegments + 1) * c + d,
                i = new THREE.Face3(e, f, g, [b[e], b[f], b[g]]);
            i.normal.add(b[e]);
            i.normal.add(b[f]);
            i.normal.add(b[g]);
            i.normal.normalize();
            this.faces.push(i);
            this.faceVertexUvs[0].push([a[e].clone(), a[f].clone(), a[g].clone()]);
            i = new THREE.Face3(f, h, g, [b[f], b[h], b[g]]);
            i.normal.add(b[f]);
            i.normal.add(b[h]);
            i.normal.add(b[g]);
            i.normal.normalize();
            this.faces.push(i);
            this.faceVertexUvs[0].push([a[f].clone(), a[h].clone(), a[g].clone()])
        }
    this.computeCentroids()
};
THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TorusKnotGeometry = function (a, b, c, d, e, f, h) {
    function g(a, b, c, d, e) {
        var f = Math.cos(a),
            g = Math.sin(a),
            a = b / c * a,
            b = Math.cos(a),
            f = .5 * d * (2 + b) * f,
            g = .5 * d * (2 + b) * g,
            d = .5 * e * d * Math.sin(a);
        return new THREE.Vector3(f, g, d)
    }
    THREE.Geometry.call(this);
    this.radius = a || 100;
    this.tube = b || 40;
    this.radialSegments = c || 64;
    this.tubularSegments = d || 8;
    this.p = e || 2;
    this.q = f || 3;
    this.heightScale = h || 1;
    this.grid = Array(this.radialSegments);
    c = new THREE.Vector3;
    d = new THREE.Vector3;
    e = new THREE.Vector3;
    for (a = 0; a < this.radialSegments; ++a) {
        this.grid[a] = Array(this.tubularSegments);
        b = 2 * (a / this.radialSegments) * this.p * Math.PI;
        f = g(b, this.q, this.p, this.radius, this.heightScale);
        b = g(b + .01, this.q, this.p, this.radius, this.heightScale);
        c.subVectors(b, f);
        d.addVectors(b, f);
        e.crossVectors(c, d);
        d.crossVectors(e, c);
        e.normalize();
        d.normalize();
        for (b = 0; b < this.tubularSegments; ++b) {
            var i = 2 * (b / this.tubularSegments) * Math.PI,
                h = -this.tube * Math.cos(i),
                i = this.tube * Math.sin(i),
                k = new THREE.Vector3;
            k.x = f.x + h * d.x + i * e.x;
            k.y = f.y + h * d.y + i * e.y;
            k.z = f.z + h * d.z + i * e.z;
            this.grid[a][b] = this.vertices.push(k) - 1
        }
    }
    for (a = 0; a < this.radialSegments; ++a)
        for (b = 0; b < this.tubularSegments; ++b) {
            var e = (a + 1) % this.radialSegments,
                f = (b + 1) % this.tubularSegments,
                c = this.grid[a][b],
                d = this.grid[e][b],
                e = this.grid[e][f],
                f = this.grid[a][f],
                h = new THREE.Vector2(a / this.radialSegments, b / this.tubularSegments),
                i = new THREE.Vector2((a + 1) / this.radialSegments, b / this.tubularSegments),
                k = new THREE.Vector2((a + 1) / this.radialSegments, (b + 1) / this.tubularSegments),
                m = new THREE.Vector2(a / this.radialSegments, (b + 1) / this.tubularSegments);
            this.faces.push(new THREE.Face3(c, d, f));
            this.faceVertexUvs[0].push([h, i, m]);
            this.faces.push(new THREE.Face3(d, e, f));
            this.faceVertexUvs[0].push([i.clone(), k, m.clone()])
        }
    this.computeCentroids();
    this.computeFaceNormals();
    this.computeVertexNormals()
};
THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry = function (a, b, c, d, e) {
    THREE.Geometry.call(this);
    this.path = a;
    this.segments = b || 64;
    this.radius = c || 1;
    this.radialSegments = d || 8;
    this.closed = e || !1;
    this.grid = [];
    var f, h, d = this.segments + 1,
        g, i, k, e = new THREE.Vector3,
        m, l, b = new THREE.TubeGeometry.FrenetFrames(this.path, this.segments, this.closed);
    m = b.normals;
    l = b.binormals;
    this.tangents = b.tangents;
    this.normals = m;
    this.binormals = l;
    for (b = 0; b < d; b++) {
        this.grid[b] = [];
        c = b / (d - 1);
        k = a.getPointAt(c);
        f = m[b];
        h = l[b];
        for (c = 0; c < this.radialSegments; c++) g = 2 * (c / this.radialSegments) * Math.PI, i = -this.radius * Math.cos(g), g = this.radius * Math.sin(g), e.copy(k), e.x += i * f.x + g * h.x, e.y += i * f.y + g * h.y, e.z += i * f.z + g * h.z, this.grid[b][c] = this.vertices.push(new THREE.Vector3(e.x, e.y, e.z)) - 1
    }
    for (b = 0; b < this.segments; b++)
        for (c = 0; c < this.radialSegments; c++) e = this.closed ? (b + 1) % this.segments : b + 1, m = (c + 1) % this.radialSegments, a = this.grid[b][c], d = this.grid[e][c], e = this.grid[e][m], m = this.grid[b][m], l = new THREE.Vector2(b / this.segments, c / this.radialSegments), f = new THREE.Vector2((b + 1) / this.segments, c / this.radialSegments), h = new THREE.Vector2((b + 1) / this.segments, (c + 1) / this.radialSegments), i = new THREE.Vector2(b / this.segments, (c + 1) / this.radialSegments), this.faces.push(new THREE.Face3(a, d, m)), this.faceVertexUvs[0].push([l, f, i]), this.faces.push(new THREE.Face3(d, e, m)), this.faceVertexUvs[0].push([f.clone(), h, i.clone()]);
    this.computeCentroids();
    this.computeFaceNormals();
    this.computeVertexNormals()
};
THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.FrenetFrames = function (a, b, c) {
    new THREE.Vector3;
    var d = new THREE.Vector3;
    new THREE.Vector3;
    var e = [],
        f = [],
        h = [],
        g = new THREE.Vector3,
        i = new THREE.Matrix4,
        b = b + 1,
        k, m, l;
    this.tangents = e;
    this.normals = f;
    this.binormals = h;
    for (k = 0; k < b; k++) m = k / (b - 1), e[k] = a.getTangentAt(m), e[k].normalize();
    f[0] = new THREE.Vector3;
    h[0] = new THREE.Vector3;
    a = Number.MAX_VALUE;
    k = Math.abs(e[0].x);
    m = Math.abs(e[0].y);
    l = Math.abs(e[0].z);
    k <= a && (a = k, d.set(1, 0, 0));
    m <= a && (a = m, d.set(0, 1, 0));
    l <= a && d.set(0, 0, 1);
    g.crossVectors(e[0], d).normalize();
    f[0].crossVectors(e[0], g);
    h[0].crossVectors(e[0], f[0]);
    for (k = 1; k < b; k++) f[k] = f[k - 1].clone(), h[k] = h[k - 1].clone(), g.crossVectors(e[k - 1], e[k]), 1e-4 < g.length() && (g.normalize(), d = Math.acos(THREE.Math.clamp(e[k - 1].dot(e[k]), -1, 1)), f[k].applyMatrix4(i.makeRotationAxis(g, d))), h[k].crossVectors(e[k], f[k]);
    if (c) {
        d = Math.acos(THREE.Math.clamp(f[0].dot(f[b - 1]), -1, 1));
        d /= b - 1;
        0 < e[0].dot(g.crossVectors(f[0], f[b - 1])) && (d = -d);
        for (k = 1; k < b; k++) f[k].applyMatrix4(i.makeRotationAxis(e[k], d * k)), h[k].crossVectors(e[k], f[k])
    }
};
THREE.PolyhedronGeometry = function (a, b, c, d) {
    function e(a) {
        var b = a.normalize().clone();
        b.index = g.vertices.push(b) - 1;
        var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + .5,
            a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5;
        b.uv = new THREE.Vector2(c, 1 - a);
        return b
    }

    function f(a, b, c) {
        var d = new THREE.Face3(a.index, b.index, c.index, [a.clone(), b.clone(), c.clone()]);
        d.centroid.add(a).add(b).add(c).divideScalar(3);
        g.faces.push(d);
        d = Math.atan2(d.centroid.z, -d.centroid.x);
        g.faceVertexUvs[0].push([h(a.uv, a, d), h(b.uv, b, d), h(c.uv, c, d)])
    }

    function h(a, b, c) {
        0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y));
        0 === b.x && 0 === b.z && (a = new THREE.Vector2(c / 2 / Math.PI + .5, a.y));
        return a.clone()
    }
    THREE.Geometry.call(this);
    for (var c = c || 1, d = d || 0, g = this, i = 0, k = a.length; i < k; i++) e(new THREE.Vector3(a[i][0], a[i][1], a[i][2]));
    for (var m = this.vertices, a = [], i = 0, k = b.length; i < k; i++) {
        var l = m[b[i][0]],
            p = m[b[i][1]],
            r = m[b[i][2]];
        a[i] = new THREE.Face3(l.index, p.index, r.index, [l.clone(), p.clone(), r.clone()])
    }
    i = 0;
    for (k = a.length; i < k; i++) {
        p = a[i];
        m = d;
        b = Math.pow(2, m);
        Math.pow(4, m);
        for (var m = e(g.vertices[p.a]), l = e(g.vertices[p.b]), t = e(g.vertices[p.c]), p = [], r = 0; r <= b; r++) {
            p[r] = [];
            for (var n = e(m.clone().lerp(t, r / b)), s = e(l.clone().lerp(t, r / b)), q = b - r, u = 0; u <= q; u++) p[r][u] = 0 == u && r == b ? n : e(n.clone().lerp(s, u / q))
        }
        for (r = 0; r < b; r++)
            for (u = 0; u < 2 * (b - r) - 1; u++) m = Math.floor(u / 2), 0 == u % 2 ? f(p[r][m + 1], p[r + 1][m], p[r][m]) : f(p[r][m + 1], p[r + 1][m + 1], p[r + 1][m])
    }
    i = 0;
    for (k = this.faceVertexUvs[0].length; i < k; i++) d = this.faceVertexUvs[0][i], a = d[0].x, b = d[1].x, m = d[2].x, l = Math.max(a, Math.max(b, m)), p = Math.min(a, Math.min(b, m)), .9 < l && .1 > p && (.2 > a && (d[0].x += 1), .2 > b && (d[1].x += 1), .2 > m && (d[2].x += 1));
    i = 0;
    for (k = this.vertices.length; i < k; i++) this.vertices[i].multiplyScalar(c);
    this.mergeVertices();
    this.computeCentroids();
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3, c)
};
THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.IcosahedronGeometry = function (a, b) {
    this.radius = a;
    this.detail = b;
    var c = (1 + Math.sqrt(5)) / 2;
    THREE.PolyhedronGeometry.call(this, [
        [-1, c, 0],
        [1, c, 0],
        [-1, -c, 0],
        [1, -c, 0],
        [0, -1, c],
        [0, 1, c],
        [0, -1, -c],
        [0, 1, -c],
        [c, 0, -1],
        [c, 0, 1],
        [-c, 0, -1],
        [-c, 0, 1]
    ], [
        [0, 11, 5],
        [0, 5, 1],
        [0, 1, 7],
        [0, 7, 10],
        [0, 10, 11],
        [1, 5, 9],
        [5, 11, 4],
        [11, 10, 2],
        [10, 7, 6],
        [7, 1, 8],
        [3, 9, 4],
        [3, 4, 2],
        [3, 2, 6],
        [3, 6, 8],
        [3, 8, 9],
        [4, 9, 5],
        [2, 4, 11],
        [6, 2, 10],
        [8, 6, 7],
        [9, 8, 1]
    ], a, b)
};
THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.OctahedronGeometry = function (a, b) {
    THREE.PolyhedronGeometry.call(this, [
        [1, 0, 0],
        [-1, 0, 0],
        [0, 1, 0],
        [0, -1, 0],
        [0, 0, 1],
        [0, 0, -1]
    ], [
        [0, 2, 4],
        [0, 4, 3],
        [0, 3, 5],
        [0, 5, 2],
        [1, 2, 5],
        [1, 5, 3],
        [1, 3, 4],
        [1, 4, 2]
    ], a, b)
};
THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TetrahedronGeometry = function (a, b) {
    THREE.PolyhedronGeometry.call(this, [
        [1, 1, 1],
        [-1, -1, 1],
        [-1, 1, -1],
        [1, -1, -1]
    ], [
        [2, 1, 0],
        [0, 3, 2],
        [1, 3, 0],
        [2, 3, 1]
    ], a, b)
};
THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ParametricGeometry = function (a, b, c) {
    THREE.Geometry.call(this);
    var d = this.vertices,
        e = this.faces,
        f = this.faceVertexUvs[0],
        h, g, i, k, m = b + 1;
    for (h = 0; h <= c; h++) {
        k = h / c;
        for (g = 0; g <= b; g++) i = g / b, i = a(i, k), d.push(i)
    }
    var l, p, r, t;
    for (h = 0; h < c; h++)
        for (g = 0; g < b; g++) a = h * m + g, d = h * m + g + 1, k = (h + 1) * m + g + 1, i = (h + 1) * m + g, l = new THREE.Vector2(g / b, h / c), p = new THREE.Vector2((g + 1) / b, h / c), r = new THREE.Vector2((g + 1) / b, (h + 1) / c), t = new THREE.Vector2(g / b, (h + 1) / c), e.push(new THREE.Face3(a, d, i)), f.push([l, p, t]), e.push(new THREE.Face3(d, k, i)), f.push([p.clone(), r, t.clone()]);
    this.computeCentroids();
    this.computeFaceNormals();
    this.computeVertexNormals()
};
THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.AxisHelper = function (a) {
    var a = a || 1,
        b = new THREE.Geometry;
    b.vertices.push(new THREE.Vector3, new THREE.Vector3(a, 0, 0), new THREE.Vector3, new THREE.Vector3(0, a, 0), new THREE.Vector3, new THREE.Vector3(0, 0, a));
    b.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775));
    a = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    });
    THREE.Line.call(this, b, a, THREE.LinePieces)
};
THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ArrowHelper = function (a, b, c, d) {
    THREE.Object3D.call(this);
    void 0 === d && (d = 16776960);
    void 0 === c && (c = 1);
    this.position = b;
    b = new THREE.Geometry;
    b.vertices.push(new THREE.Vector3(0, 0, 0));
    b.vertices.push(new THREE.Vector3(0, 1, 0));
    this.line = new THREE.Line(b, new THREE.LineBasicMaterial({
        color: d
    }));
    this.line.matrixAutoUpdate = !1;
    this.add(this.line);
    b = new THREE.CylinderGeometry(0, .05, .25, 5, 1);
    b.applyMatrix((new THREE.Matrix4).makeTranslation(0, .875, 0));
    this.cone = new THREE.Mesh(b, new THREE.MeshBasicMaterial({
        color: d
    }));
    this.cone.matrixAutoUpdate = !1;
    this.add(this.cone);
    this.setDirection(a);
    this.setLength(c)
};
THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.ArrowHelper.prototype.setDirection = function () {
    var a = new THREE.Vector3,
        b;
    return function (c) {.99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b))
    }
}();
THREE.ArrowHelper.prototype.setLength = function (a) {
    this.scale.set(a, a, a)
};
THREE.ArrowHelper.prototype.setColor = function (a) {
    this.line.material.color.setHex(a);
    this.cone.material.color.setHex(a)
};
THREE.BoxHelper = function (a) {
    var b = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(-1, 1, 1), new THREE.Vector3(-1, -1, 1), new THREE.Vector3(1, -1, 1), new THREE.Vector3(1, 1, -1), new THREE.Vector3(-1, 1, -1), new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, -1, -1)];
    this.vertices = b;
    var c = new THREE.Geometry;
    c.vertices.push(b[0], b[1], b[1], b[2], b[2], b[3], b[3], b[0], b[4], b[5], b[5], b[6], b[6], b[7], b[7], b[4], b[0], b[4], b[1], b[5], b[2], b[6], b[3], b[7]);
    THREE.Line.call(this, c, new THREE.LineBasicMaterial({
        color: 16776960
    }), THREE.LinePieces);
    void 0 !== a && this.update(a)
};
THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
THREE.BoxHelper.prototype.update = function (a) {
    var b = a.geometry;
    null === b.boundingBox && b.computeBoundingBox();
    var c = b.boundingBox.min,
        b = b.boundingBox.max,
        d = this.vertices;
    d[0].set(b.x, b.y, b.z);
    d[1].set(c.x, b.y, b.z);
    d[2].set(c.x, c.y, b.z);
    d[3].set(b.x, c.y, b.z);
    d[4].set(b.x, b.y, c.z);
    d[5].set(c.x, b.y, c.z);
    d[6].set(c.x, c.y, c.z);
    d[7].set(b.x, c.y, c.z);
    this.geometry.computeBoundingSphere();
    this.geometry.verticesNeedUpdate = !0;
    this.matrixAutoUpdate = !1;
    this.matrixWorld = a.matrixWorld
};
THREE.BoundingBoxHelper = function (a, b) {
    var c = b || 8947848;
    this.object = a;
    this.box = new THREE.Box3;
    THREE.Mesh.call(this, new THREE.CubeGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
        color: c,
        wireframe: !0
    }))
};
THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.BoundingBoxHelper.prototype.update = function () {
    this.box.setFromObject(this.object);
    this.box.size(this.scale);
    this.box.center(this.position)
};
THREE.CameraHelper = function (a) {
    function b(a, b, d) {
        c(a, d);
        c(b, d)
    }

    function c(a, b) {
        d.vertices.push(new THREE.Vector3);
        d.colors.push(new THREE.Color(b));
        void 0 === f[a] && (f[a] = []);
        f[a].push(d.vertices.length - 1)
    }
    var d = new THREE.Geometry,
        e = new THREE.LineBasicMaterial({
            color: 16777215,
            vertexColors: THREE.FaceColors
        }),
        f = {};
    b("n1", "n2", 16755200);
    b("n2", "n4", 16755200);
    b("n4", "n3", 16755200);
    b("n3", "n1", 16755200);
    b("f1", "f2", 16755200);
    b("f2", "f4", 16755200);
    b("f4", "f3", 16755200);
    b("f3", "f1", 16755200);
    b("n1", "f1", 16755200);
    b("n2", "f2", 16755200);
    b("n3", "f3", 16755200);
    b("n4", "f4", 16755200);
    b("p", "n1", 16711680);
    b("p", "n2", 16711680);
    b("p", "n3", 16711680);
    b("p", "n4", 16711680);
    b("u1", "u2", 43775);
    b("u2", "u3", 43775);
    b("u3", "u1", 43775);
    b("c", "t", 16777215);
    b("p", "c", 3355443);
    b("cn1", "cn2", 3355443);
    b("cn3", "cn4", 3355443);
    b("cf1", "cf2", 3355443);
    b("cf3", "cf4", 3355443);
    THREE.Line.call(this, d, e, THREE.LinePieces);
    this.camera = a;
    this.matrixWorld = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.pointMap = f;
    this.update()
};
THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.update = function () {
    var a = new THREE.Vector3,
        b = new THREE.Camera,
        c = new THREE.Projector;
    return function () {
        function d(d, h, g, i) {
            a.set(h, g, i);
            c.unprojectVector(a, b);
            d = e.pointMap[d];
            if (void 0 !== d) {
                h = 0;
                for (g = d.length; h < g; h++) e.geometry.vertices[d[h]].copy(a)
            }
        }
        var e = this;
        b.projectionMatrix.copy(this.camera.projectionMatrix);
        d("c", 0, 0, -1);
        d("t", 0, 0, 1);
        d("n1", -1, -1, -1);
        d("n2", 1, -1, -1);
        d("n3", -1, 1, -1);
        d("n4", 1, 1, -1);
        d("f1", -1, -1, 1);
        d("f2", 1, -1, 1);
        d("f3", -1, 1, 1);
        d("f4", 1, 1, 1);
        d("u1", .7, 1.1, -1);
        d("u2", -.7, 1.1, -1);
        d("u3", 0, 2, -1);
        d("cf1", -1, 0, 1);
        d("cf2", 1, 0, 1);
        d("cf3", 0, -1, 1);
        d("cf4", 0, 1, 1);
        d("cn1", -1, 0, -1);
        d("cn2", 1, 0, -1);
        d("cn3", 0, -1, -1);
        d("cn4", 0, 1, -1);
        this.geometry.verticesNeedUpdate = !0
    }
}();
THREE.DirectionalLightHelper = function (a, b) {
    THREE.Object3D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrixWorld = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    var c = new THREE.PlaneGeometry(b, b),
        d = new THREE.MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        });
    d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.lightPlane = new THREE.Mesh(c, d);
    this.add(this.lightPlane);
    c = new THREE.Geometry;
    c.vertices.push(new THREE.Vector3);
    c.vertices.push(new THREE.Vector3);
    c.computeLineDistances();
    d = new THREE.LineBasicMaterial({
        fog: !1
    });
    d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.targetLine = new THREE.Line(c, d);
    this.add(this.targetLine);
    this.update()
};
THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.DirectionalLightHelper.prototype.dispose = function () {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose()
};
THREE.DirectionalLightHelper.prototype.update = function () {
    var a = new THREE.Vector3;
    return function () {
        a.getPositionFromMatrix(this.light.matrixWorld).negate();
        this.lightPlane.lookAt(a);
        this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        this.targetLine.geometry.vertices[1].copy(a);
        this.targetLine.geometry.verticesNeedUpdate = !0;
        this.targetLine.material.color.copy(this.lightPlane.material.color)
    }
}();
THREE.FaceNormalsHelper = function (a, b, c, d) {
    this.object = a;
    this.size = b || 1;
    for (var a = c || 16776960, d = d || 1, b = new THREE.Geometry, c = 0, e = this.object.geometry.faces.length; c < e; c++) b.vertices.push(new THREE.Vector3), b.vertices.push(new THREE.Vector3);
    THREE.Line.call(this, b, new THREE.LineBasicMaterial({
        color: a,
        linewidth: d
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.normalMatrix = new THREE.Matrix3;
    this.update()
};
THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper.prototype.update = function () {
    var a = new THREE.Vector3;
    return function () {
        this.object.updateMatrixWorld(!0);
        this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
        for (var b = this.geometry.vertices, c = this.object.geometry.faces, d = this.object.matrixWorld, e = 0, f = c.length; e < f; e++) {
            var h = c[e];
            a.copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
            var g = 2 * e;
            b[g].copy(h.centroid).applyMatrix4(d);
            b[g + 1].addVectors(b[g], a)
        }
        this.geometry.verticesNeedUpdate = !0;
        return this
    }
}();
THREE.GridHelper = function (a, b) {
    var c = new THREE.Geometry,
        d = new THREE.LineBasicMaterial({
            vertexColors: THREE.VertexColors
        });
    this.color1 = new THREE.Color(4473924);
    this.color2 = new THREE.Color(8947848);
    for (var e = -a; e <= a; e += b) {
        c.vertices.push(new THREE.Vector3(-a, 0, e), new THREE.Vector3(a, 0, e), new THREE.Vector3(e, 0, -a), new THREE.Vector3(e, 0, a));
        var f = 0 === e ? this.color1 : this.color2;
        c.colors.push(f, f, f, f)
    }
    THREE.Line.call(this, c, d, THREE.LinePieces)
};
THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
THREE.GridHelper.prototype.setColors = function (a, b) {
    this.color1.set(a);
    this.color2.set(b);
    this.geometry.colorsNeedUpdate = !0
};
THREE.HemisphereLightHelper = function (a, b) {
    THREE.Object3D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrixWorld = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.colors = [new THREE.Color, new THREE.Color];
    var c = new THREE.SphereGeometry(b, 4, 2);
    c.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
    for (var d = 0; 8 > d; d++) c.faces[d].color = this.colors[4 > d ? 0 : 1];
    d = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
        wireframe: !0
    });
    this.lightSphere = new THREE.Mesh(c, d);
    this.add(this.lightSphere);
    this.update()
};
THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.HemisphereLightHelper.prototype.dispose = function () {
    this.lightSphere.geometry.dispose();
    this.lightSphere.material.dispose()
};
THREE.HemisphereLightHelper.prototype.update = function () {
    var a = new THREE.Vector3;
    return function () {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
        this.lightSphere.lookAt(a.getPositionFromMatrix(this.light.matrixWorld).negate());
        this.lightSphere.geometry.colorsNeedUpdate = !0
    }
}();
THREE.PointLightHelper = function (a, b) {
    this.light = a;
    this.light.updateMatrixWorld();
    var c = new THREE.SphereGeometry(b, 4, 2),
        d = new THREE.MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        });
    d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    THREE.Mesh.call(this, c, d);
    this.matrixWorld = this.light.matrixWorld;
    this.matrixAutoUpdate = !1
};
THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.PointLightHelper.prototype.dispose = function () {
    this.geometry.dispose();
    this.material.dispose()
};
THREE.PointLightHelper.prototype.update = function () {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
};
THREE.SpotLightHelper = function (a) {
    THREE.Object3D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrixWorld = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    a = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
    a.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0));
    a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
    var b = new THREE.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    this.cone = new THREE.Mesh(a, b);
    this.add(this.cone);
    this.update()
};
THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.dispose = function () {
    this.cone.geometry.dispose();
    this.cone.material.dispose()
};
THREE.SpotLightHelper.prototype.update = function () {
    var a = new THREE.Vector3,
        b = new THREE.Vector3;
    return function () {
        var c = this.light.distance ? this.light.distance : 1e4,
            d = c * Math.tan(this.light.angle);
        this.cone.scale.set(d, d, c);
        a.getPositionFromMatrix(this.light.matrixWorld);
        b.getPositionFromMatrix(this.light.target.matrixWorld);
        this.cone.lookAt(b.sub(a));
        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
    }
}();
THREE.VertexNormalsHelper = function (a, b, c, d) {
    this.object = a;
    this.size = b || 1;
    for (var b = c || 16711680, d = d || 1, c = new THREE.Geometry, a = a.geometry.faces, e = 0, f = a.length; e < f; e++)
        for (var h = 0, g = a[e].vertexNormals.length; h < g; h++) c.vertices.push(new THREE.Vector3), c.vertices.push(new THREE.Vector3);
    THREE.Line.call(this, c, new THREE.LineBasicMaterial({
        color: b,
        linewidth: d
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.normalMatrix = new THREE.Matrix3;
    this.update()
};
THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexNormalsHelper.prototype.update = function () {
    var a = new THREE.Vector3;
    return function () {
        var b = ["a", "b", "c", "d"];
        this.object.updateMatrixWorld(!0);
        this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
        for (var c = this.geometry.vertices, d = this.object.geometry.vertices, e = this.object.geometry.faces, f = this.object.matrixWorld, h = 0, g = 0, i = e.length; g < i; g++)
            for (var k = e[g], m = 0, l = k.vertexNormals.length; m < l; m++) {
                var p = k.vertexNormals[m];
                c[h].copy(d[k[b[m]]]).applyMatrix4(f);
                a.copy(p).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
                a.add(c[h]);
                h += 1;
                c[h].copy(a);
                h += 1
            }
        this.geometry.verticesNeedUpdate = !0;
        return this
    }
}();
THREE.VertexTangentsHelper = function (a, b, c, d) {
    this.object = a;
    this.size = b || 1;
    for (var b = c || 255, d = d || 1, c = new THREE.Geometry, a = a.geometry.faces, e = 0, f = a.length; e < f; e++)
        for (var h = 0, g = a[e].vertexTangents.length; h < g; h++) c.vertices.push(new THREE.Vector3), c.vertices.push(new THREE.Vector3);
    THREE.Line.call(this, c, new THREE.LineBasicMaterial({
        color: b,
        linewidth: d
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.update()
};
THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexTangentsHelper.prototype.update = function () {
    var a = new THREE.Vector3;
    return function () {
        var b = ["a", "b", "c", "d"];
        this.object.updateMatrixWorld(!0);
        for (var c = this.geometry.vertices, d = this.object.geometry.vertices, e = this.object.geometry.faces, f = this.object.matrixWorld, h = 0, g = 0, i = e.length; g < i; g++)
            for (var k = e[g], m = 0, l = k.vertexTangents.length; m < l; m++) {
                var p = k.vertexTangents[m];
                c[h].copy(d[k[b[m]]]).applyMatrix4(f);
                a.copy(p).transformDirection(f).multiplyScalar(this.size);
                a.add(c[h]);
                h += 1;
                c[h].copy(a);
                h += 1
            }
        this.geometry.verticesNeedUpdate = !0;
        return this
    }
}();
THREE.WireframeHelper = function (a) {
    for (var b = [0, 0], c = {}, d = function (a, b) {
        return a - b
    }, e = ["a", "b", "c", "d"], f = new THREE.Geometry, h = a.geometry.vertices, g = a.geometry.faces, i = 0, k = g.length; i < k; i++)
        for (var m = g[i], l = 0; 3 > l; l++) {
            b[0] = m[e[l]];
            b[1] = m[e[(l + 1) % 3]];
            b.sort(d);
            var p = b.toString();
            void 0 === c[p] && (f.vertices.push(h[b[0]]), f.vertices.push(h[b[1]]), c[p] = !0)
        }
    THREE.Line.call(this, f, new THREE.LineBasicMaterial({
        color: 16777215
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.matrixWorld = a.matrixWorld
};
THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ImmediateRenderObject = function () {
    THREE.Object3D.call(this);
    this.render = function () {}
};
THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare = function (a, b, c, d, e) {
    THREE.Object3D.call(this);
    this.lensFlares = [];
    this.positionScreen = new THREE.Vector3;
    this.customUpdateCallback = void 0;
    void 0 !== a && this.add(a, b, c, d, e)
};
THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare.prototype.add = function (a, b, c, d, e, f) {
    void 0 === b && (b = -1);
    void 0 === c && (c = 0);
    void 0 === f && (f = 1);
    void 0 === e && (e = new THREE.Color(16777215));
    void 0 === d && (d = THREE.NormalBlending);
    c = Math.min(c, Math.max(0, c));
    this.lensFlares.push({
        texture: a,
        size: b,
        distance: c,
        x: 0,
        y: 0,
        z: 0,
        scale: 1,
        rotation: 1,
        opacity: f,
        color: e,
        blending: d
    })
};
THREE.LensFlare.prototype.updateLensFlares = function () {
    var a, b = this.lensFlares.length,
        c, d = 2 * -this.positionScreen.x,
        e = 2 * -this.positionScreen.y;
    for (a = 0; a < b; a++) c = this.lensFlares[a], c.x = this.positionScreen.x + d * c.distance, c.y = this.positionScreen.y + e * c.distance, c.wantedRotation = .25 * c.x * Math.PI, c.rotation += .25 * (c.wantedRotation - c.rotation)
};
THREE.MorphBlendMesh = function (a, b) {
    THREE.Mesh.call(this, a, b);
    this.animationsMap = {};
    this.animationsList = [];
    var c = this.geometry.morphTargets.length;
    this.createAnimation("__default", 0, c - 1, c / 1);
    this.setAnimationWeight("__default", 1)
};
THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphBlendMesh.prototype.createAnimation = function (a, b, c, d) {
    b = {
        startFrame: b,
        endFrame: c,
        length: c - b + 1,
        fps: d,
        duration: (c - b) / d,
        lastFrame: 0,
        currentFrame: 0,
        active: !1,
        time: 0,
        direction: 1,
        weight: 1,
        directionBackwards: !1,
        mirroredLoop: !1
    };
    this.animationsMap[a] = b;
    this.animationsList.push(b)
};
THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (a) {
    for (var b = /([a-z]+)(\d+)/, c, d = {}, e = this.geometry, f = 0, h = e.morphTargets.length; f < h; f++) {
        var g = e.morphTargets[f].name.match(b);
        if (g && 1 < g.length) {
            var i = g[1];
            d[i] || (d[i] = {
                start: Infinity,
                end: -Infinity
            });
            g = d[i];
            f < g.start && (g.start = f);
            f > g.end && (g.end = f);
            c || (c = i)
        }
    }
    for (i in d) g = d[i], this.createAnimation(i, g.start, g.end, a);
    this.firstAnimation = c
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (a) {
    if (a = this.animationsMap[a]) a.direction = 1, a.directionBackwards = !1
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (a) {
    if (a = this.animationsMap[a]) a.direction = -1, a.directionBackwards = !0
};
THREE.MorphBlendMesh.prototype.setAnimationFPS = function (a, b) {
    var c = this.animationsMap[a];
    c && (c.fps = b, c.duration = (c.end - c.start) / c.fps)
};
THREE.MorphBlendMesh.prototype.setAnimationDuration = function (a, b) {
    var c = this.animationsMap[a];
    c && (c.duration = b, c.fps = (c.end - c.start) / c.duration)
};
THREE.MorphBlendMesh.prototype.setAnimationWeight = function (a, b) {
    var c = this.animationsMap[a];
    c && (c.weight = b)
};
THREE.MorphBlendMesh.prototype.setAnimationTime = function (a, b) {
    var c = this.animationsMap[a];
    c && (c.time = b)
};
THREE.MorphBlendMesh.prototype.getAnimationTime = function (a) {
    var b = 0;
    if (a = this.animationsMap[a]) b = a.time;
    return b
};
THREE.MorphBlendMesh.prototype.getAnimationDuration = function (a) {
    var b = -1;
    if (a = this.animationsMap[a]) b = a.duration;
    return b
};
THREE.MorphBlendMesh.prototype.playAnimation = function (a) {
    var b = this.animationsMap[a];
    b ? (b.time = 0, b.active = !0) : console.warn("animation[" + a + "] undefined")
};
THREE.MorphBlendMesh.prototype.stopAnimation = function (a) {
    if (a = this.animationsMap[a]) a.active = !1
};
THREE.MorphBlendMesh.prototype.update = function (a) {
    for (var b = 0, c = this.animationsList.length; b < c; b++) {
        var d = this.animationsList[b];
        if (d.active) {
            var e = d.duration / d.length;
            d.time += d.direction * a;
            if (d.mirroredLoop) {
                if (d.time > d.duration || 0 > d.time) d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, d.directionBackwards = !1)
            } else d.time %= d.duration, 0 > d.time && (d.time += d.duration);
            var f = d.startFrame + THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1),
                h = d.weight;
            f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * h, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f);
            e = d.time % e / e;
            d.directionBackwards && (e = 1 - e);
            this.morphTargetInfluences[d.currentFrame] = e * h;
            this.morphTargetInfluences[d.lastFrame] = (1 - e) * h
        }
    }
};
THREE.LensFlarePlugin = function () {
    function a(a, c) {
        var d = b.createProgram(),
            e = b.createShader(b.FRAGMENT_SHADER),
            f = b.createShader(b.VERTEX_SHADER),
            g = "precision " + c + " float;\n";
        b.shaderSource(e, g + a.fragmentShader);
        b.shaderSource(f, g + a.vertexShader);
        b.compileShader(e);
        b.compileShader(f);
        b.attachShader(d, e);
        b.attachShader(d, f);
        b.linkProgram(d);
        return d
    }
    var b, c, d, e, f, h, g, i, k, m, l, p, r;
    this.init = function (t) {
        b = t.context;
        c = t;
        d = t.getPrecision();
        e = new Float32Array(16);
        f = new Uint16Array(6);
        t = 0;
        e[t++] = -1;
        e[t++] = -1;
        e[t++] = 0;
        e[t++] = 0;
        e[t++] = 1;
        e[t++] = -1;
        e[t++] = 1;
        e[t++] = 0;
        e[t++] = 1;
        e[t++] = 1;
        e[t++] = 1;
        e[t++] = 1;
        e[t++] = -1;
        e[t++] = 1;
        e[t++] = 0;
        e[t++] = 1;
        t = 0;
        f[t++] = 0;
        f[t++] = 1;
        f[t++] = 2;
        f[t++] = 0;
        f[t++] = 2;
        f[t++] = 3;
        h = b.createBuffer();
        g = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, h);
        b.bufferData(b.ARRAY_BUFFER, e, b.STATIC_DRAW);
        b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, g);
        b.bufferData(b.ELEMENT_ARRAY_BUFFER, f, b.STATIC_DRAW);
        i = b.createTexture();
        k = b.createTexture();
        b.bindTexture(b.TEXTURE_2D, i);
        b.texImage2D(b.TEXTURE_2D, 0, b.RGB, 16, 16, 0, b.RGB, b.UNSIGNED_BYTE, null);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);
        b.bindTexture(b.TEXTURE_2D, k);
        b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, 16, 16, 0, b.RGBA, b.UNSIGNED_BYTE, null);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);
        0 >= b.getParameter(b.MAX_VERTEX_TEXTURE_IMAGE_UNITS) ? (m = !1, l = a(THREE.ShaderFlares.lensFlare, d)) : (m = !0, l = a(THREE.ShaderFlares.lensFlareVertexTexture, d));
        p = {};
        r = {};
        p.vertex = b.getAttribLocation(l, "position");
        p.uv = b.getAttribLocation(l, "uv");
        r.renderType = b.getUniformLocation(l, "renderType");
        r.map = b.getUniformLocation(l, "map");
        r.occlusionMap = b.getUniformLocation(l, "occlusionMap");
        r.opacity = b.getUniformLocation(l, "opacity");
        r.color = b.getUniformLocation(l, "color");
        r.scale = b.getUniformLocation(l, "scale");
        r.rotation = b.getUniformLocation(l, "rotation");
        r.screenPosition = b.getUniformLocation(l, "screenPosition")
    };
    this.render = function (a, d, e, f) {
        var a = a.__webglFlares,
            u = a.length;
        if (u) {
            var w = new THREE.Vector3,
                E = f / e,
                C = .5 * e,
                F = .5 * f,
                y = 16 / f,
                A = new THREE.Vector2(y * E, y),
                z = new THREE.Vector3(1, 1, 0),
                O = new THREE.Vector2(1, 1),
                B = r,
                y = p;
            b.useProgram(l);
            b.enableVertexAttribArray(p.vertex);
            b.enableVertexAttribArray(p.uv);
            b.uniform1i(B.occlusionMap, 0);
            b.uniform1i(B.map, 1);
            b.bindBuffer(b.ARRAY_BUFFER, h);
            b.vertexAttribPointer(y.vertex, 2, b.FLOAT, !1, 16, 0);
            b.vertexAttribPointer(y.uv, 2, b.FLOAT, !1, 16, 8);
            b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, g);
            b.disable(b.CULL_FACE);
            b.depthMask(!1);
            var D, I, v, x, G;
            for (D = 0; D < u; D++)
                if (y = 16 / f, A.set(y * E, y), x = a[D], w.set(x.matrixWorld.elements[12], x.matrixWorld.elements[13], x.matrixWorld.elements[14]), w.applyMatrix4(d.matrixWorldInverse), w.applyProjection(d.projectionMatrix), z.copy(w), O.x = z.x * C + C, O.y = z.y * F + F, m || 0 < O.x && O.x < e && 0 < O.y && O.y < f) {
                    b.activeTexture(b.TEXTURE1);
                    b.bindTexture(b.TEXTURE_2D, i);
                    b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGB, O.x - 8, O.y - 8, 16, 16, 0);
                    b.uniform1i(B.renderType, 0);
                    b.uniform2f(B.scale, A.x, A.y);
                    b.uniform3f(B.screenPosition, z.x, z.y, z.z);
                    b.disable(b.BLEND);
                    b.enable(b.DEPTH_TEST);
                    b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0);
                    b.activeTexture(b.TEXTURE0);
                    b.bindTexture(b.TEXTURE_2D, k);
                    b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGBA, O.x - 8, O.y - 8, 16, 16, 0);
                    b.uniform1i(B.renderType, 1);
                    b.disable(b.DEPTH_TEST);
                    b.activeTexture(b.TEXTURE1);
                    b.bindTexture(b.TEXTURE_2D, i);
                    b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0);
                    x.positionScreen.copy(z);
                    x.customUpdateCallback ? x.customUpdateCallback(x) : x.updateLensFlares();
                    b.uniform1i(B.renderType, 2);
                    b.enable(b.BLEND);
                    I = 0;
                    for (v = x.lensFlares.length; I < v; I++) G = x.lensFlares[I], .001 < G.opacity && .001 < G.scale && (z.x = G.x, z.y = G.y, z.z = G.z, y = G.size * G.scale / f, A.x = y * E, A.y = y, b.uniform3f(B.screenPosition, z.x, z.y, z.z), b.uniform2f(B.scale, A.x, A.y), b.uniform1f(B.rotation, G.rotation), b.uniform1f(B.opacity, G.opacity), b.uniform3f(B.color, G.color.r, G.color.g, G.color.b), c.setBlending(G.blending, G.blendEquation, G.blendSrc, G.blendDst), c.setTexture(G.texture, 1), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0))
                }
            b.enable(b.CULL_FACE);
            b.enable(b.DEPTH_TEST);
            b.depthMask(!0)
        }
    }
};
THREE.ShadowMapPlugin = function () {
    var a, b, c, d, e, f, h = new THREE.Frustum,
        g = new THREE.Matrix4,
        i = new THREE.Vector3,
        k = new THREE.Vector3,
        m = new THREE.Vector3;
    this.init = function (g) {
        a = g.context;
        b = g;
        var g = THREE.ShaderLib.depthRGBA,
            h = THREE.UniformsUtils.clone(g.uniforms);
        c = new THREE.ShaderMaterial({
            fragmentShader: g.fragmentShader,
            vertexShader: g.vertexShader,
            uniforms: h
        });
        d = new THREE.ShaderMaterial({
            fragmentShader: g.fragmentShader,
            vertexShader: g.vertexShader,
            uniforms: h,
            morphTargets: !0
        });
        e = new THREE.ShaderMaterial({
            fragmentShader: g.fragmentShader,
            vertexShader: g.vertexShader,
            uniforms: h,
            skinning: !0
        });
        f = new THREE.ShaderMaterial({
            fragmentShader: g.fragmentShader,
            vertexShader: g.vertexShader,
            uniforms: h,
            morphTargets: !0,
            skinning: !0
        });
        c._shadowPass = !0;
        d._shadowPass = !0;
        e._shadowPass = !0;
        f._shadowPass = !0
    };
    this.render = function (a, c) {
        b.shadowMapEnabled && b.shadowMapAutoUpdate && this.update(a, c)
    };
    this.update = function (l, p) {
        var r, t, n, s, q, u, w, E, C, F = [];
        s = 0;
        a.clearColor(1, 1, 1, 1);
        a.disable(a.BLEND);
        a.enable(a.CULL_FACE);
        a.frontFace(a.CCW);
        b.shadowMapCullFace === THREE.CullFaceFront ? a.cullFace(a.FRONT) : a.cullFace(a.BACK);
        b.setDepthTest(!0);
        r = 0;
        for (t = l.__lights.length; r < t; r++)
            if (n = l.__lights[r], n.castShadow)
                if (n instanceof THREE.DirectionalLight && n.shadowCascade)
                    for (q = 0; q < n.shadowCascadeCount; q++) {
                        var y;
                        if (n.shadowCascadeArray[q]) y = n.shadowCascadeArray[q];
                        else {
                            C = n;
                            w = q;
                            y = new THREE.DirectionalLight;
                            y.isVirtual = !0;
                            y.onlyShadow = !0;
                            y.castShadow = !0;
                            y.shadowCameraNear = C.shadowCameraNear;
                            y.shadowCameraFar = C.shadowCameraFar;
                            y.shadowCameraLeft = C.shadowCameraLeft;
                            y.shadowCameraRight = C.shadowCameraRight;
                            y.shadowCameraBottom = C.shadowCameraBottom;
                            y.shadowCameraTop = C.shadowCameraTop;
                            y.shadowCameraVisible = C.shadowCameraVisible;
                            y.shadowDarkness = C.shadowDarkness;
                            y.shadowBias = C.shadowCascadeBias[w];
                            y.shadowMapWidth = C.shadowCascadeWidth[w];
                            y.shadowMapHeight = C.shadowCascadeHeight[w];
                            y.pointsWorld = [];
                            y.pointsFrustum = [];
                            E = y.pointsWorld;
                            u = y.pointsFrustum;
                            for (var A = 0; 8 > A; A++) E[A] = new THREE.Vector3, u[A] = new THREE.Vector3;
                            E = C.shadowCascadeNearZ[w];
                            C = C.shadowCascadeFarZ[w];
                            u[0].set(-1, -1, E);
                            u[1].set(1, -1, E);
                            u[2].set(-1, 1, E);
                            u[3].set(1, 1, E);
                            u[4].set(-1, -1, C);
                            u[5].set(1, -1, C);
                            u[6].set(-1, 1, C);
                            u[7].set(1, 1, C);
                            y.originalCamera = p;
                            u = new THREE.Gyroscope;
                            u.position = n.shadowCascadeOffset;
                            u.add(y);
                            u.add(y.target);
                            p.add(u);
                            n.shadowCascadeArray[q] = y;
                            console.log("Created virtualLight", y)
                        }
                        w = n;
                        E = q;
                        C = w.shadowCascadeArray[E];
                        C.position.copy(w.position);
                        C.target.position.copy(w.target.position);
                        C.lookAt(C.target);
                        C.shadowCameraVisible = w.shadowCameraVisible;
                        C.shadowDarkness = w.shadowDarkness;
                        C.shadowBias = w.shadowCascadeBias[E];
                        u = w.shadowCascadeNearZ[E];
                        w = w.shadowCascadeFarZ[E];
                        C = C.pointsFrustum;
                        C[0].z = u;
                        C[1].z = u;
                        C[2].z = u;
                        C[3].z = u;
                        C[4].z = w;
                        C[5].z = w;
                        C[6].z = w;
                        C[7].z = w;
                        F[s] = y;
                        s++
                    } else F[s] = n, s++;
        r = 0;
        for (t = F.length; r < t; r++) {
            n = F[r];
            n.shadowMap || (q = THREE.LinearFilter, b.shadowMapType === THREE.PCFSoftShadowMap && (q = THREE.NearestFilter), n.shadowMap = new THREE.WebGLRenderTarget(n.shadowMapWidth, n.shadowMapHeight, {
                minFilter: q,
                magFilter: q,
                format: THREE.RGBAFormat
            }), n.shadowMapSize = new THREE.Vector2(n.shadowMapWidth, n.shadowMapHeight), n.shadowMatrix = new THREE.Matrix4);
            if (!n.shadowCamera) {
                if (n instanceof THREE.SpotLight) n.shadowCamera = new THREE.PerspectiveCamera(n.shadowCameraFov, n.shadowMapWidth / n.shadowMapHeight, n.shadowCameraNear, n.shadowCameraFar);
                else if (n instanceof THREE.DirectionalLight) n.shadowCamera = new THREE.OrthographicCamera(n.shadowCameraLeft, n.shadowCameraRight, n.shadowCameraTop, n.shadowCameraBottom, n.shadowCameraNear, n.shadowCameraFar);
                else {
                    console.error("Unsupported light type for shadow");
                    continue
                }
                l.add(n.shadowCamera);
                !0 === l.autoUpdate && l.updateMatrixWorld()
            }
            n.shadowCameraVisible && !n.cameraHelper && (n.cameraHelper = new THREE.CameraHelper(n.shadowCamera), n.shadowCamera.add(n.cameraHelper));
            if (n.isVirtual && y.originalCamera == p) {
                q = p;
                s = n.shadowCamera;
                u = n.pointsFrustum;
                C = n.pointsWorld;
                i.set(Infinity, Infinity, Infinity);
                k.set(-Infinity, -Infinity, -Infinity);
                for (w = 0; 8 > w; w++) E = C[w], E.copy(u[w]), THREE.ShadowMapPlugin.__projector.unprojectVector(E, q), E.applyMatrix4(s.matrixWorldInverse), E.x < i.x && (i.x = E.x), E.x > k.x && (k.x = E.x), E.y < i.y && (i.y = E.y), E.y > k.y && (k.y = E.y), E.z < i.z && (i.z = E.z), E.z > k.z && (k.z = E.z);
                s.left = i.x;
                s.right = k.x;
                s.top = k.y;
                s.bottom = i.y;
                s.updateProjectionMatrix()
            }
            s = n.shadowMap;
            u = n.shadowMatrix;
            q = n.shadowCamera;
            q.position.getPositionFromMatrix(n.matrixWorld);
            m.getPositionFromMatrix(n.target.matrixWorld);
            q.lookAt(m);
            q.updateMatrixWorld();
            q.matrixWorldInverse.getInverse(q.matrixWorld);
            n.cameraHelper && (n.cameraHelper.visible = n.shadowCameraVisible);
            n.shadowCameraVisible && n.cameraHelper.update();
            u.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
            u.multiply(q.projectionMatrix);
            u.multiply(q.matrixWorldInverse);
            g.multiplyMatrices(q.projectionMatrix, q.matrixWorldInverse);
            h.setFromMatrix(g);
            b.setRenderTarget(s);
            b.clear();
            C = l.__webglObjects;
            n = 0;
            for (s = C.length; n < s; n++)
                if (w = C[n], u = w.object, w.render = !1, u.visible && u.castShadow && (!(u instanceof THREE.Mesh || u instanceof THREE.ParticleSystem) || !u.frustumCulled || h.intersectsObject(u))) u._modelViewMatrix.multiplyMatrices(q.matrixWorldInverse, u.matrixWorld), w.render = !0;
            n = 0;
            for (s = C.length; n < s; n++) w = C[n], w.render && (u = w.object, w = w.buffer, A = u.material instanceof THREE.MeshFaceMaterial ? u.material.materials[0] : u.material, E = 0 < u.geometry.morphTargets.length && A.morphTargets, A = u instanceof THREE.SkinnedMesh && A.skinning, E = u.customDepthMaterial ? u.customDepthMaterial : A ? E ? f : e : E ? d : c, w instanceof THREE.BufferGeometry ? b.renderBufferDirect(q, l.__lights, null, E, w, u) : b.renderBuffer(q, l.__lights, null, E, w, u));
            C = l.__webglObjectsImmediate;
            n = 0;
            for (s = C.length; n < s; n++) w = C[n], u = w.object, u.visible && u.castShadow && (u._modelViewMatrix.multiplyMatrices(q.matrixWorldInverse, u.matrixWorld), b.renderImmediateObject(q, l.__lights, null, c, u))
        }
        r = b.getClearColor();
        t = b.getClearAlpha();
        a.clearColor(r.r, r.g, r.b, t);
        a.enable(a.BLEND);
        b.shadowMapCullFace === THREE.CullFaceFront && a.cullFace(a.BACK)
    }
};
THREE.ShadowMapPlugin.__projector = new THREE.Projector;
THREE.SpritePlugin = function () {
    function a(a, b) {
        return a.z !== b.z ? b.z - a.z : b.id - a.id
    }
    var b, c, d, e, f, h, g, i, k, m;
    this.init = function (a) {
        b = a.context;
        c = a;
        d = a.getPrecision();
        e = new Float32Array(16);
        f = new Uint16Array(6);
        a = 0;
        e[a++] = -1;
        e[a++] = -1;
        e[a++] = 0;
        e[a++] = 0;
        e[a++] = 1;
        e[a++] = -1;
        e[a++] = 1;
        e[a++] = 0;
        e[a++] = 1;
        e[a++] = 1;
        e[a++] = 1;
        e[a++] = 1;
        e[a++] = -1;
        e[a++] = 1;
        e[a++] = 0;
        e[a++] = 1;
        a = 0;
        f[a++] = 0;
        f[a++] = 1;
        f[a++] = 2;
        f[a++] = 0;
        f[a++] = 2;
        f[a++] = 3;
        h = b.createBuffer();
        g = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, h);
        b.bufferData(b.ARRAY_BUFFER, e, b.STATIC_DRAW);
        b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, g);
        b.bufferData(b.ELEMENT_ARRAY_BUFFER, f, b.STATIC_DRAW);
        var a = THREE.ShaderSprite.sprite,
            p = b.createProgram(),
            r = b.createShader(b.FRAGMENT_SHADER),
            t = b.createShader(b.VERTEX_SHADER),
            n = "precision " + d + " float;\n";
        b.shaderSource(r, n + a.fragmentShader);
        b.shaderSource(t, n + a.vertexShader);
        b.compileShader(r);
        b.compileShader(t);
        b.attachShader(p, r);
        b.attachShader(p, t);
        b.linkProgram(p);
        i = p;
        k = {};
        m = {};
        k.position = b.getAttribLocation(i, "position");
        k.uv = b.getAttribLocation(i, "uv");
        m.uvOffset = b.getUniformLocation(i, "uvOffset");
        m.uvScale = b.getUniformLocation(i, "uvScale");
        m.rotation = b.getUniformLocation(i, "rotation");
        m.scale = b.getUniformLocation(i, "scale");
        m.alignment = b.getUniformLocation(i, "alignment");
        m.color = b.getUniformLocation(i, "color");
        m.map = b.getUniformLocation(i, "map");
        m.opacity = b.getUniformLocation(i, "opacity");
        m.useScreenCoordinates = b.getUniformLocation(i, "useScreenCoordinates");
        m.sizeAttenuation = b.getUniformLocation(i, "sizeAttenuation");
        m.screenPosition = b.getUniformLocation(i, "screenPosition");
        m.modelViewMatrix = b.getUniformLocation(i, "modelViewMatrix");
        m.projectionMatrix = b.getUniformLocation(i, "projectionMatrix");
        m.fogType = b.getUniformLocation(i, "fogType");
        m.fogDensity = b.getUniformLocation(i, "fogDensity");
        m.fogNear = b.getUniformLocation(i, "fogNear");
        m.fogFar = b.getUniformLocation(i, "fogFar");
        m.fogColor = b.getUniformLocation(i, "fogColor");
        m.alphaTest = b.getUniformLocation(i, "alphaTest")
    };
    this.render = function (d, e, f, t) {
        var n = d.__webglSprites,
            s = n.length;
        if (s) {
            var q = k,
                u = m,
                w = t / f,
                f = .5 * f,
                E = .5 * t;
            b.useProgram(i);
            b.enableVertexAttribArray(q.position);
            b.enableVertexAttribArray(q.uv);
            b.disable(b.CULL_FACE);
            b.enable(b.BLEND);
            b.bindBuffer(b.ARRAY_BUFFER, h);
            b.vertexAttribPointer(q.position, 2, b.FLOAT, !1, 16, 0);
            b.vertexAttribPointer(q.uv, 2, b.FLOAT, !1, 16, 8);
            b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, g);
            b.uniformMatrix4fv(u.projectionMatrix, !1, e.projectionMatrix.elements);
            b.activeTexture(b.TEXTURE0);
            b.uniform1i(u.map, 0);
            var C = q = 0,
                F = d.fog;
            F ? (b.uniform3f(u.fogColor, F.color.r, F.color.g, F.color.b), F instanceof THREE.Fog ? (b.uniform1f(u.fogNear, F.near), b.uniform1f(u.fogFar, F.far), b.uniform1i(u.fogType, 1), C = q = 1) : F instanceof THREE.FogExp2 && (b.uniform1f(u.fogDensity, F.density), b.uniform1i(u.fogType, 2), C = q = 2)) : (b.uniform1i(u.fogType, 0), C = q = 0);
            for (var y, A, z = [], F = 0; F < s; F++) y = n[F], A = y.material, y.visible && 0 !== A.opacity && (A.useScreenCoordinates ? y.z = -y.position.z : (y._modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, y.matrixWorld), y.z = -y._modelViewMatrix.elements[14]));
            n.sort(a);
            for (F = 0; F < s; F++) y = n[F], A = y.material, y.visible && 0 !== A.opacity && A.map && A.map.image && A.map.image.width && (b.uniform1f(u.alphaTest, A.alphaTest), !0 === A.useScreenCoordinates ? (b.uniform1i(u.useScreenCoordinates, 1), b.uniform3f(u.screenPosition, (y.position.x * c.devicePixelRatio - f) / f, (E - y.position.y * c.devicePixelRatio) / E, Math.max(0, Math.min(1, y.position.z))), z[0] = c.devicePixelRatio, z[1] = c.devicePixelRatio) : (b.uniform1i(u.useScreenCoordinates, 0), b.uniform1i(u.sizeAttenuation, A.sizeAttenuation ? 1 : 0), b.uniformMatrix4fv(u.modelViewMatrix, !1, y._modelViewMatrix.elements), z[0] = 1, z[1] = 1), e = d.fog && A.fog ? C : 0, q !== e && (b.uniform1i(u.fogType, e), q = e), e = 1 / (A.scaleByViewport ? t : 1), z[0] *= e * w * y.scale.x, z[1] *= e * y.scale.y, b.uniform2f(u.uvScale, A.uvScale.x, A.uvScale.y), b.uniform2f(u.uvOffset, A.uvOffset.x, A.uvOffset.y), b.uniform2f(u.alignment, A.alignment.x, A.alignment.y), b.uniform1f(u.opacity, A.opacity), b.uniform3f(u.color, A.color.r, A.color.g, A.color.b), b.uniform1f(u.rotation, y.rotation), b.uniform2fv(u.scale, z), c.setBlending(A.blending, A.blendEquation, A.blendSrc, A.blendDst), c.setDepthTest(A.depthTest), c.setDepthWrite(A.depthWrite), c.setTexture(A.map, 0), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0));
            b.enable(b.CULL_FACE)
        }
    }
};
THREE.DepthPassPlugin = function () {
    this.enabled = !1;
    this.renderTarget = null;
    var a, b, c, d, e, f, h = new THREE.Frustum,
        g = new THREE.Matrix4;
    this.init = function (g) {
        a = g.context;
        b = g;
        var g = THREE.ShaderLib.depthRGBA,
            h = THREE.UniformsUtils.clone(g.uniforms);
        c = new THREE.ShaderMaterial({
            fragmentShader: g.fragmentShader,
            vertexShader: g.vertexShader,
            uniforms: h
        });
        d = new THREE.ShaderMaterial({
            fragmentShader: g.fragmentShader,
            vertexShader: g.vertexShader,
            uniforms: h,
            morphTargets: !0
        });
        e = new THREE.ShaderMaterial({
            fragmentShader: g.fragmentShader,
            vertexShader: g.vertexShader,
            uniforms: h,
            skinning: !0
        });
        f = new THREE.ShaderMaterial({
            fragmentShader: g.fragmentShader,
            vertexShader: g.vertexShader,
            uniforms: h,
            morphTargets: !0,
            skinning: !0
        });
        c._shadowPass = !0;
        d._shadowPass = !0;
        e._shadowPass = !0;
        f._shadowPass = !0
    };
    this.render = function (a, b) {
        this.enabled && this.update(a, b)
    };
    this.update = function (i, k) {
        var m, l, p, r, t, n;
        a.clearColor(1, 1, 1, 1);
        a.disable(a.BLEND);
        b.setDepthTest(!0);
        !0 === i.autoUpdate && i.updateMatrixWorld();
        k.matrixWorldInverse.getInverse(k.matrixWorld);
        g.multiplyMatrices(k.projectionMatrix, k.matrixWorldInverse);
        h.setFromMatrix(g);
        b.setRenderTarget(this.renderTarget);
        b.clear();
        n = i.__webglObjects;
        m = 0;
        for (l = n.length; m < l; m++)
            if (p = n[m], t = p.object, p.render = !1, t.visible && (!(t instanceof THREE.Mesh || t instanceof THREE.ParticleSystem) || !t.frustumCulled || h.intersectsObject(t))) t._modelViewMatrix.multiplyMatrices(k.matrixWorldInverse, t.matrixWorld), p.render = !0;
        var s;
        m = 0;
        for (l = n.length; m < l; m++)
            if (p = n[m], p.render && (t = p.object, p = p.buffer, !(t instanceof THREE.ParticleSystem) || t.customDepthMaterial))(s = t.material instanceof THREE.MeshFaceMaterial ? t.material.materials[0] : t.material) && b.setMaterialFaces(t.material), r = 0 < t.geometry.morphTargets.length && s.morphTargets, s = t instanceof THREE.SkinnedMesh && s.skinning, r = t.customDepthMaterial ? t.customDepthMaterial : s ? r ? f : e : r ? d : c, p instanceof THREE.BufferGeometry ? b.renderBufferDirect(k, i.__lights, null, r, p, t) : b.renderBuffer(k, i.__lights, null, r, p, t);
        n = i.__webglObjectsImmediate;
        m = 0;
        for (l = n.length; m < l; m++) p = n[m], t = p.object, t.visible && (t._modelViewMatrix.multiplyMatrices(k.matrixWorldInverse, t.matrixWorld), b.renderImmediateObject(k, i.__lights, null, c, t));
        m = b.getClearColor();
        l = b.getClearAlpha();
        a.clearColor(m.r, m.g, m.b, l);
        a.enable(a.BLEND)
    }
};
THREE.ShaderFlares = {
    lensFlareVertexTexture: {
        vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
        fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
    },
    lensFlare: {
        vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
        fragmentShader: "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
    }
};
THREE.ShaderSprite = {
    sprite: {
        vertexShader: "uniform int useScreenCoordinates;\nuniform int sizeAttenuation;\nuniform vec3 screenPosition;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 alignment;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position + alignment;\nvec2 rotatedPosition;\nrotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;\nrotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;\nvec4 finalPosition;\nif( useScreenCoordinates != 0 ) {\nfinalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );\n} else {\nfinalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );\n}\ngl_Position = finalPosition;\n}",
        fragmentShader: "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"
    }
};
var WebGLHelper = {
    pluginInstallerURL: "http://iewebgl.com/releases/iewebgl.exe",
    manualLoadScreenMsg: 'Please install the <a style="color:#497daf;" href="PLUGIN_INSTALL_URL">IEWebGL plugin</a> and refresh the page.',
    notSupportWebGLMsg: "Sorry, your browser does not support WebGL.<br/>Please install the latest Firefox, Chrome or the IEWebGL plugin.",
    notSupportCanvasMsg: "Your browser does not support &lt;canvas&gt.",
    IsIE: function () {
        return navigator.userAgent.indexOf("MSIE") >= 0
    },
    GetGLContext: function (cnv, attributes) {
        var ctxNames = ["webgl", "experimental-webgl"];
        var glCtx = null;
        for (var i = 0; i < ctxNames.length && glCtx == null; ++i) {
            try {
                glCtx = cnv.getContext(ctxNames[i], attributes)
            } catch (e) {}
        }
        return glCtx
    },
    ShowMessage: function (el, text) {
        var content = '<div class="WebPlayerError">' + text + "</div>";
        try {
            el.innerHTML = content
        } catch (e) {
            el.altHtml = content
        }
    },
    CreateNativeCanvas: function (element, id, replace, okHandler, failHandler) {
        try {
            var container = document.createElement("div");
            var cnv = document.createElement("canvas");
            container.appendChild(cnv);
            if (replace) {
                element.parentNode.replaceChild(container, element)
            } else {
                element.appendChild(container)
            }
            WebGLHelper.ShowMessage(cnv, WebGLHelper.notSupportCanvasMsg);
            cnv.id = id;
            if (okHandler) {
                okHandler(cnv, id)
            }
            return cnv
        } catch (e) {
            if (failHandler) {
                failHandler(e, id)
            }
            return null
        }
    },
    CreatePluginCanvas: function (element, id, replace, okHandler, failHandler) {
        var container = document.createElement("div");
        var obj = document.createElement("object");
        if (replace) {
            element.parentNode.replaceChild(container, element)
        } else {
            element.appendChild(container)
        }
        WebGLHelper.ShowMessage(obj, WebGLHelper.manualLoadScreenMsg.replace("PLUGIN_INSTALL_URL", WebGLHelper.pluginInstallerURL));
        var loadTimeOverlay = container.childNodes[0];
        var showPlugin = function () {
            if (loadTimeOverlay && loadTimeOverlay.parentNode) {
                loadTimeOverlay.parentNode.removeChild(loadTimeOverlay)
            }
            obj.style.visibility = "visible"
        };
        var errorHandler = function (e) {
            showPlugin();
            obj.onreadystatechange = null;
            if (failHandler) {
                e.noPluginInstalled = true;
                failHandler(e, id)
            }
        };
        var successHandler = function () {
            showPlugin();
            if (okHandler) okHandler(obj, id)
        };
        container.appendChild(obj);
        obj.style.visibility = "hidden";
        obj.onreadystatechange = successHandler;
        obj.onerror = errorHandler;
        obj.id = id;
        obj.type = "application/x-webgl";
        return obj
    },
    CreateGLCanvas: function (el, id, replace, okHandler, failHandler) {
        if (WebGLHelper.IsIE()) {
            var usePlugin;
            try {
                usePlugin = WebGLRenderingContext.hasOwnProperty("iewebgl")
            } catch (e) {
                usePlugin = true
            }
            if (usePlugin) {
                return WebGLHelper.CreatePluginCanvas(el, id, replace, okHandler, failHandler)
            } else {
                return WebGLHelper.CreateNativeCanvas(el, id, replace, okHandler, failHandler)
            }
        } else {
            return WebGLHelper.CreateNativeCanvas(el, id, replace, okHandler, failHandler)
        }
    },
    CreateGLCanvasInline: function (id, okHandler, failHandler) {
        var placeHolder = document.getElementById("WebGLCanvasCreationScript");
        WebGLHelper.CreateGLCanvas(placeHolder, id, true, okHandler, failHandler)
    }
};
var lua_print = function () {
    try {
        console.log.apply(console, arguments)
    } catch (e) {}
    return []
};

function lua_load(chunk, chunkname) {
    if (!lua_parser) {
        throw new Error("Lua parser not available, perhaps you're not using the lua+parser.js version of the library?")
    }
    var fn;
    eval("fn = function " + (chunkname || "load") + "() {\n" + "return (function () {\n" + lua_parser.parse(chunk) + "\n" + "})()[0];\n" + "};");
    return fn
}

function lua_load_js(chunk, chunkname) {
    var fn;
    eval("fn = function " + (chunkname || "load") + "() {\n" + "return (function () {\n" + chunk + "\n" + "})()[0];\n" + "};");
    return fn
}

function slice(arr, start) {
    if (arr.slice) {
        return arr.slice(start)
    } else {
        return Array.prototype.slice.call(arr, start)
    }
}

function not_supported() {
    throw new Error("Not supported")
}

function ensure_arraymode(table) {
    if (!table.arraymode) {
        var newuints = [];
        for (var i in table.uints) {
            if (table.uints[i] != null) {
                newuints[i - 1] = table.uints[i]
            }
        }
        table.uints = newuints;
        table.arraymode = true
    }
}

function ensure_notarraymode(table) {
    if (table.arraymode) {
        var newuints = {};
        for (var i in table.uints) {
            if (table.uints[i] != null) {
                newuints[i - -1] = table.uints[i]
            }
        }
        table.uints = newuints;
        delete table.arraymode
    }
}

function check_string(s) {
    var type = typeof s;
    if (type == "string") {
        return s
    } else if (type == "number") {
        return s.toString()
    } else {
        throw new Error("Input not string")
    }
}

function ReturnValues(vars) {
    this.vars = vars || []
}

function lua_true(op) {
    return op != null && op !== false
}

function lua_not(op) {
    return op == null || op === false
}

function lua_and(op1, op2) {
    return op1 == null || op1 === false ? op1 : op2()
}

function lua_or(op1, op2) {
    return op1 != null && op1 !== false ? op1 : op2()
}

function lua_assertfloat(n) {
    var result = parseFloat(n);
    if (isNaN(result)) {
        throw new Error("Invalid number: " + n)
    }
    return result
}

function lua_newtable(autoIndexList) {
    var result = {
        str: {},
        uints: {},
        floats: {},
        bool: {},
        objs: []
    };
    for (var i = 1; i < arguments.length - 1; i += 2) {
        var value = arguments[i + 1];
        if (value == null) {
            continue
        }
        var key = arguments[i];
        switch (typeof key) {
        case "string":
            result.str[key] = value;
            break;
        case "number":
            if (key != key) {
                throw new Error("Table index is NaN")
            }
            if (key > 0 && (key | 0) == key) {
                result.uints[key] = value
            } else {
                result.floats[key] = value
            }
            break;
        case "boolean":
            result.bool[key] = value;
            break;
        case "object":
            if (key == null) {
                throw new Error("Table index is nil")
            }
            var bFound = value == null;
            for (var i in result.objs) {
                if (result.objs[i][0] === key) {
                    if (value == null) {
                        result.objs.splice(i, 1)
                    } else {
                        bFound = true;
                        result.objs[i][1] = value
                    }
                    break
                }
            }
            if (!bFound) {
                result.objs.push([key, value])
            }
            break;
        default:
            throw new Error("Unsupported type for table: " + typeof key)
        }
    }
    if (autoIndexList) {
        ensure_arraymode(result);
        if (result.uints.length == 0) {
            result.uints = autoIndexList
        } else {
            i = autoIndexList.length;
            while (i-- > 0) {
                result.uints[i] = autoIndexList[i]
            }
        }
    }
    return result
}

function lua_newtable2(str) {
    var str_copy = {};
    for (var i in str) {
        str_copy[i] = str[i]
    }
    return {
        str: str_copy,
        uints: {},
        floats: {},
        bool: {},
        objs: {}
    }
}

function lua_len(op) {
    if (typeof op == "string") {
        return op.length
    } else if (typeof op == "object" && op != null) {
        if (op.length == null) {
            var index = 0;
            if (op.arraymode) {
                while (op.uints[index++] != null) {}
                return op.length = index - 1
            } else {
                while (op.uints[++index] != null) {}
                return op.length = index - 1
            }
        } else {
            return op.length
        }
    } else {
        var h = op.metatable && op.metatable.str["__len"];
        if (h) {
            return lua_rawcall(h, [op])[0]
        } else {
            throw new Error("Length of <" + op + "> not supported")
        }
    }
}

function lua_rawcall(func, args) {
    try {
        return func.apply(null, args)
    } catch (e) {
        if (e.constructor == ReturnValues) {
            return e.vars
        }
        throw e
    }
}

function lua_tablegetcall(table, key, args) {
    var func = lua_tableget(table, key);
    if (typeof func == "function") {
        return lua_rawcall(func, args)
    } else {
        if (func == null) {
            throw new Error("attempt to call field '" + key + "' (a nil value)")
        }
        var h = func.metatable && func.metatable.str["__call"];
        if (h != null) {
            return lua_rawcall(h, [func].concat(args))
        } else {
            throw new Error("Could not call " + func + " as function")
        }
    }
}

function lua_call(func, args) {
    if (typeof func == "function") {
        return lua_rawcall(func, args)
    } else {
        if (func == null) {
            throw new Error("attempt to call function (a nil value)")
        }
        var h = func.metatable && func.metatable.str["__call"];
        if (h != null) {
            return lua_rawcall(h, [func].concat(args))
        } else {
            throw new Error("Could not call " + func + " as function")
        }
    }
}

function lua_mcall(obj, methodname, args) {
    var func = lua_tableget(obj, methodname);
    if (func == null) {
        throw new Error("attempt to call method '" + methodname + "' (a nil value)")
    }
    return lua_call(func, [obj].concat(args))
}

function lua_eq(op1, op2) {
    if (typeof op1 != typeof op2) {
        if (op1 == null && op2 == null) {
            return true
        }
        return false
    }
    if (op1 == op2) {
        return true
    }
    if (op1 == null || op2 == null) {
        return false
    }
    var h = op1.metatable && op1.metatable.str["__eq"];
    if (h && h == (op2.metatable && op2.metatable.str["__eq"])) {
        return lua_true(lua_rawcall(h, [op1, op2])[0])
    } else {
        return false
    }
}

function lua_lt(op1, op2) {
    if (typeof op1 == "number" && typeof op2 == "number") {
        return op1 < op2
    } else if (typeof op1 == "string" && typeof op2 == "string") {
        return op1 < op2
    } else {
        var h = op1.metatable && op1.metatable.str["__lt"];
        if (h && h == (op2.metatable && op2.metatable.str["__lt"])) {
            return lua_true(lua_rawcall(h, [op1, op2])[0])
        } else {
            throw new Error("Unable to compare " + op1 + " and " + op2)
        }
    }
}

function lua_lte(op1, op2) {
    if (typeof op1 == "number" && typeof op2 == "number") {
        return op1 <= op2
    } else if (typeof op1 == "string" && typeof op2 == "string") {
        return op1 <= op2
    } else {
        var h = op1.metatable && op1.metatable.str["__le"];
        if (h && h == (op2.metatable && op2.metatable.str["__le"])) {
            return lua_true(lua_rawcall(h, [op1, op2])[0])
        } else {
            var h = op1.metatable && op1.metatable.str["__lt"];
            if (h && h == (op2.metatable && op2.metatable.str["__lt"])) {
                return lua_not(lua_rawcall(h, [op2, op1])[0])
            } else {
                throw new Error("Unable to compare " + op1 + " and " + op2)
            }
        }
    }
}

function lua_unm(op) {
    var o = parseFloat(op);
    if (!isNaN(o)) {
        return -o
    } else {
        var h = op.metatable && op.metatable.str["__unm"];
        if (h) {
            return lua_rawcall(h, [op])[0]
        } else {
            throw new Error("Inverting <" + op + "> not supported")
        }
    }
}

function lua_add(op1, op2) {
    var o1 = parseFloat(op1),
        o2 = parseFloat(op2);
    if (isNaN(o1) || isNaN(o2)) {
        var h = op1.metatable && op1.metatable.str["__add"] || op2.metatable && op2.metatable.str["__add"];
        if (h) {
            return lua_rawcall(h, [op1, op2])[0]
        } else {
            throw new Error("Adding <" + op1 + "> and <" + op2 + "> not supported")
        }
    } else {
        return o1 + o2
    }
}

function lua_subtract(op1, op2) {
    var o1 = parseFloat(op1),
        o2 = parseFloat(op2);
    if (isNaN(o1) || isNaN(o2)) {
        var h = op1.metatable && op1.metatable.str["__sub"] || op2.metatable && op2.metatable.str["__sub"];
        if (h) {
            return lua_rawcall(h, [op1, op2])[0]
        } else {
            throw new Error("Subtracting <" + op1 + "> and <" + op2 + "> not supported")
        }
    } else {
        return o1 - o2
    }
}

function lua_divide(op1, op2) {
    var o1 = parseFloat(op1),
        o2 = parseFloat(op2);
    if (isNaN(o1) || isNaN(o2)) {
        var h = op1.metatable && op1.metatable.str["__div"] || op2.metatable && op2.metatable.str["__div"];
        if (h) {
            return lua_rawcall(h, [op1, op2])[0]
        } else {
            throw new Error("Dividing <" + op1 + "> and <" + op2 + "> not supported")
        }
    } else {
        return o1 / o2
    }
}

function lua_multiply(op1, op2) {
    var o1 = parseFloat(op1),
        o2 = parseFloat(op2);
    if (isNaN(o1) || isNaN(o2)) {
        var h = op1.metatable && op1.metatable.str["__mul"] || op2.metatable && op2.metatable.str["__mul"];
        if (h) {
            return lua_rawcall(h, [op1, op2])[0]
        } else {
            throw new Error("Multiplying <" + op1 + "> and <" + op2 + "> not supported")
        }
    } else {
        return o1 * o2
    }
}

function lua_power(op1, op2) {
    var o1 = parseFloat(op1),
        o2 = parseFloat(op2);
    if (isNaN(o1) || isNaN(o2)) {
        var h = op1.metatable && op1.metatable.str["__pow"] || op2.metatable && op2.metatable.str["__pow"];
        if (h) {
            return lua_rawcall(h, [op1, op2])[0]
        } else {
            throw new Error("<" + op1 + "> to the power of <" + op2 + "> not supported")
        }
    } else {
        return Math.pow(o1, o2)
    }
}

function lua_mod(op1, op2) {
    var o1 = parseFloat(op1),
        o2 = parseFloat(op2);
    if (isNaN(o1) || isNaN(o2)) {
        var h = op1.metatable && op1.metatable.str["__mod"] || op2.metatable && op2.metatable.str["__mod"];
        if (h) {
            return lua_rawcall(h, [op1, op2])[0]
        } else {
            throw new Error("Modulo <" + op1 + "> and <" + op2 + "> not supported")
        }
    } else {
        if (o1 >= 0) {
            if (o2 >= 0) {
                return o1 % o2
            } else {
                return (o2 + o1 % o2) % o2
            }
        } else {
            if (o2 >= 0) {
                return (o2 + o1 % o2) % o2
            } else {
                return o1 % o2
            }
        }
    }
}

function lua_rawget(table, key) {
    switch (typeof key) {
    case "string":
        return table.str[key];
    case "number":
        if (key != key) {
            throw new Error("Table index is NaN")
        }
        if (key > 0 && (key | 0) == key) {
            if (table.arraymode) {
                return table.uints[key - 1]
            } else {
                return table.uints[key]
            }
        } else {
            return table.floats[key]
        }
    case "boolean":
        return table.bool[key];
    case "object":
        if (key == null) {
            return null
        }
        for (var i in table.objs) {
            if (table.objs[i][0] == key) {
                return table.objs[i][1]
            }
        }
        break;
    default:
        throw new Error("Unsupported key for table: " + typeof key)
    }
}

function lua_rawset(table, key, value) {
    delete table.length;
    switch (typeof key) {
    case "string":
        if (value == null) {
            delete table.str[key]
        } else {
            table.str[key] = value
        }
        break;
    case "number":
        if (key != key) {
            throw new Error("Table index is NaN")
        }
        if (key > 0 && (key | 0) == key) {
            ensure_notarraymode(table);
            if (value == null) {
                delete table.uints[key]
            } else {
                table.uints[key] = value
            }
        } else {
            if (value == null) {
                delete table.floats[key]
            } else {
                table.floats[key] = value
            }
        }
        break;
    case "boolean":
        if (value == null) {
            delete table.bool[key]
        } else {
            table.bool[key] = value
        }
        break;
    case "object":
        if (key == null) {
            throw new Error("Table index is nil")
        }
        var bFound = value == null;
        for (var i in table.objs) {
            if (table.objs[i][0] == key) {
                if (value == null) {
                    table.objs.splice(i, 1)
                } else {
                    bFound = true;
                    table.objs[i][1] = value
                }
                break
            }
        }
        if (!bFound) {
            table.objs.push([key, value])
        }
        break;
    default:
        throw new Error("Unsupported key for table: " + typeof key)
    }
}

function lua_tableget(table, key) {
    if (table == null) {
        throw new Error("attempt to index field '" + key + "' in a nil value")
    }
    if (typeof table == "object") {
        var v = lua_rawget(table, key);
        if (v != null) {
            return v
        }
        var h = table.metatable && table.metatable.str["__index"];
        if (h == null) {
            return null
        }
    } else {
        var h = table.metatable && table.metatable.str["__index"];
        if (h == null) {
            throw new Error("Unable to index key " + key + " from " + table)
        }
    } if (typeof h == "function") {
        return lua_rawcall(h, [table, key])[0]
    } else {
        return lua_tableget(h, key)
    }
}

function lua_tableset(table, key, value) {
    if (table == null) {
        throw new Error("attempt to set field '" + key + "' in a nil value")
    }
    if (typeof table == "object") {
        var v = lua_rawget(table, key);
        if (v != null) {
            lua_rawset(table, key, value);
            return
        }
        var h = table.metatable && table.metatable.str["__newindex"];
        if (h == null) {
            lua_rawset(table, key, value);
            return
        }
    } else {
        var h = table.metatable && table.metatable.str["__newindex"];
        if (h == null) {
            throw new Error("Unable to set key " + key + " in table " + table)
        }
    } if (typeof h == "function") {
        lua_rawcall(h, [table, key, value])
    } else {
        lua_tableset(h, key, value)
    }
}

function lua_concat(op1, op2) {
    if (typeof op1 == "number" && typeof op2 == "number") {
        return "" + op1 + op2
    } else if ((typeof op1 == "string" || typeof op1 == "number") && (typeof op2 == "string" || typeof op2 == "number")) {
        return op1 + op2
    } else {
        var h = op1.metatable && op1.metatable.str["__concat"] || op2.metatable && op2.metatable.str["__concat"];
        if (h) {
            return lua_rawcall(h, [op1, op2])[0]
        } else {
            throw new Error("Unable to concat " + op1 + " and " + op2)
        }
    }
}

function _ipairs_next(table, index) {
    var entry;
    if (table.arraymode) {
        entry = table.uints[index]
    } else {
        entry = table.uints[index + 1]
    } if (entry == null) {
        return [null, null]
    }
    return [index + 1, entry]
}
var lua_libs = {};
var lua_core = {
    assert: function (value, message) {
        if (arguments.length < 1) {
            message = "assertion failed!"
        }
        if (value != null && value !== false) {
            return [value]
        } else {
            throw new Error(message)
        }
    },
    collectgarbage: function () {},
    dofile: function () {
        not_supported()
    },
    error: function (message, level) {
        throw new Error(message)
    },
    getfenv: function (func, table) {
        not_supported()
    },
    getmetatable: function (op) {
        return [op.metatable && (op.metatable.str["__metatable"] || op.metatable)]
    },
    ipairs: function (table) {
        return [_ipairs_next, table, 0]
    },
    load: function (func, chunkname) {
        var script = "",
            chunk;
        while ((chunk = func()) != null && chunk != "") {
            script += chunk
        }
        try {
            return [lua_load(script, chunkname)]
        } catch (e) {
            return [null, e.message]
        }
    },
    loadfile: function () {
        not_supported()
    },
    loadstring: function (string, chunkname) {
        try {
            return [lua_load(string, chunkname)]
        } catch (e) {
            return [null, e.message]
        }
    },
    next: function () {
        not_supported()
    },
    pairs: function (table) {
        var props = [],
            i;
        for (i in table.str) {
            props.push(i)
        }
        if (table.arraymode) {
            var j = table.uints.length;
            while (j-- > 0) {
                if (table.uints[j] != null) {
                    props.push(j + 1)
                }
            }
        } else {
            for (i in table.uints) {
                props.push(parseFloat(i))
            }
        }
        for (i in table.floats) {
            props.push(parseFloat(i))
        }
        for (i in table.bool) {
            props.push(i === "true" ? true : false)
        }
        for (i in table.objs) {
            props.push(table.objs[i][0])
        }
        i = 0;
        return [
            function (table, key) {
                var entry;
                do {
                    if (i >= props.length) {
                        return [null, null]
                    }
                    key = props[i++];
                    entry = lua_rawget(table, key)
                } while (entry == null);
                return [key, entry]
            },
            table, null
        ]
    },
    pcall: function (func) {
        try {
            return [true].concat(func.apply(null, slice(arguments, 1)))
        } catch (e) {
            return [false, e.message]
        }
    },
    print: lua_print,
    rawequal: function (op1, op2) {
        return [op1 == op2 || op1 == null && op2 == null]
    },
    rawget: function (table, key) {
        if (typeof table == "object" && table != null) {
            return [lua_rawget(table, key)]
        }
        throw new Error("Unable to index key " + key + " from " + table)
    },
    rawset: function (table, key, value) {
        if (typeof table == "object" && table != null && key != null) {
            lua_rawset(table, key, value);
            return [table]
        }
        throw new Error("Unable set key " + key + " in " + table)
    },
    select: function (n) {
        if (n === "#") {
            return [arguments.length - 1]
        } else {
            n = lua_assertfloat(n);
            if (n >= 1) {
                return slice(arguments, lua_assertfloat(n))
            } else {
                throw new Error("Index out of range")
            }
        }
    },
    setfenv: function (func, table) {
        not_supported()
    },
    setmetatable: function (table, metatable) {
        if (typeof table != "object" || table == null) {
            throw new Error("table expected, got " + table)
        }
        if (metatable == null) {
            delete table.metatable
        } else if (typeof metatable === "object") {
            table.metatable = metatable
        } else {
            throw new Error("table or nil expected, got " + metatable)
        }
        return [table]
    },
    tonumber: function (e, base) {
        if (typeof e == "number") {
            return [e]
        }
        if (base === 10 || base == null) {
            return [parseFloat(e)]
        } else {
            return [parseInt(e, base)]
        }
    },
    tostring: function (e) {
        if (e == null) {
            return ["nil"]
        }
        var h = e.metatable && e.metatable.str["__tostring"];
        if (h) {
            return lua_rawcall(h, [e])
        } else {
            switch (typeof e) {
            case "number":
            case "boolean":
                return [e.toString()];
            case "string":
                return [e];
            case "object":
                return ["table"];
            case "function":
                return ["function"];
            default:
                return ["nil"]
            }
        }
    },
    type: function (v) {
        switch (typeof v) {
        case "number":
            return ["number"];
        case "string":
            return ["string"];
        case "boolean":
            return ["boolean"];
        case "function":
            return ["function"];
        case "object":
            return [v === null ? "nil" : "table"];
        case "undefined":
            return ["nil"];
        default:
            throw new Error("Unepected value of type " + typeof v)
        }
    },
    unpack: function (list, i, j) {
        ensure_arraymode(list);
        if (list.length != null) {
            j = list.length
        } else {
            j = 0;
            while (list.uints[j++] != null) {}
            list.length = --j
        } if (i == null || i < 1) {
            i = 1
        }
        if (j == null) {
            j = list.length
        }
        throw new ReturnValues(list.uints.slice(i - 1, j))
    },
    _VERSION: "Lua 5.1",
    xpcall: function () {
        not_supported()
    }
};
var _lua_coroutine = lua_libs["coroutine"] = {};
_lua_coroutine["resume"] = _lua_coroutine["running"] = _lua_coroutine["status"] = _lua_coroutine["wrap"] = _lua_coroutine["yield"] = _lua_coroutine["create"] = function () {
    not_supported()
};
var _lua_debug = lua_libs["debug"] = {
    getmetatable: function (obj) {
        return [obj.metatable]
    }
};
_lua_debug["traceback"] = _lua_debug["getfenv"] = _lua_debug["gethook"] = _lua_debug["getinfo"] = _lua_debug["getlocal"] = _lua_debug["getregistry"] = _lua_debug["getupvalue"] = _lua_debug["setfenv"] = _lua_debug["sethook"] = _lua_debug["setlocal"] = _lua_debug["setupvalue"] = _lua_debug["debug"] = function () {
    not_supported()
};
var _lua_write_buffer = "";
var _lua_io = lua_libs["io"] = {
    write: function () {
        _lua_write_buffer += Array.prototype.join.call(arguments, "");
        var lines = _lua_write_buffer.split("\n");
        while (lines.length > 1) {
            _lua_print(lines.shift())
        }
        _lua_write_buffer = lines[0];
        return []
    },
    flush: function () {},
    stderr: null,
    stdin: null,
    stdout: null
};
_lua_io["close"] = _lua_io["input"] = _lua_io["lines"] = _lua_io["output"] = _lua_io["popen"] = _lua_io["read"] = _lua_io["tmpfile"] = _lua_io["type"] = _lua_io["open"] = function () {
    not_supported()
};
var _lua_randmax = 4294967296;
var _lua_randseed = Math.random() * _lua_randmax & _lua_randmax - 1;
lua_libs["math"] = {
    abs: function (x) {
        return [Math.abs(x)]
    },
    acos: function (x) {
        return [Math.acos(x)]
    },
    asin: function (x) {
        return [Math.asin(x)]
    },
    atan: function (x) {
        return [Math.atan(x)]
    },
    atan2: function (y, x) {
        return [Math.atan2(y, x)]
    },
    ceil: function (x) {
        return [Math.ceil(x)]
    },
    cos: function (x) {
        return [Math.cos(x)]
    },
    cosh: function (x) {
        return [(Math.exp(x) + Math.exp(-x)) / 2]
    },
    deg: function (x) {
        return [x * (180 / Math.PI)]
    },
    exp: function (x) {
        return [Math.exp(x)]
    },
    floor: function (x) {
        return [Math.floor(x)]
    },
    fmod: function (x, y) {
        return [x % y]
    },
    frexp: function (m, e) {
        not_supported()
    },
    huge: Infinity,
    ldexp: function (m, e) {
        return [m * Math.pow(2, e)]
    },
    log: function (x) {
        return [Math.log(x)]
    },
    log10: function (x) {
        return [Math.log(x) / Math.LN10]
    },
    max: function () {
        return [Math.max.apply(null, arguments)]
    },
    min: function () {
        return [Math.min.apply(null, arguments)]
    },
    modf: function (x) {
        var frac = x % 1;
        return [x - frac, frac]
    },
    pi: Math.PI,
    pow: function (x, y) {
        return [Math.pow(x, y)]
    },
    rad: function (x) {
        return [x * (Math.PI / 180)]
    },
    sin: function (x) {
        return [Math.sin(x)]
    },
    sinh: function (x) {
        return [(Math.exp(x) - Math.exp(-x)) / 2]
    },
    sqrt: function (x) {
        return [Math.sqrt(x)]
    },
    tan: function (x) {
        return [Math.tan(x)]
    },
    tanh: function (x) {
        var a = Math.exp(x);
        var b = Math.exp(-x);
        return [(a - b) / (a + b)]
    },
    random: function (m, n) {
        _lua_randseed = ~_lua_randseed + (_lua_randseed << 15);
        _lua_randseed = _lua_randseed ^ _lua_randseed >>> 12;
        _lua_randseed = _lua_randseed + (_lua_randseed << 2);
        _lua_randseed = _lua_randseed ^ _lua_randseed >>> 4;
        _lua_randseed = _lua_randseed * 2057;
        _lua_randseed = _lua_randseed ^ _lua_randseed >>> 16;
        var val;
        if (_lua_randseed < 0) {
            val = (_lua_randseed + _lua_randmax) / _lua_randmax % 1
        } else {
            val = _lua_randseed / _lua_randmax % 1
        } if (arguments.length >= 2) {
            m = m | 0;
            n = n | 0;
            if (m > n) {
                throw new Error("Invalid range")
            }
            return [Math.floor(val * (n - m + 1) + m)]
        } else if (arguments.length == 1) {
            m = m | 0;
            return [Math.floor(val * m + 1)]
        } else {
            return [val]
        }
    },
    randomseed: function (x) {
        _lua_randseed = x & _lua_randmax - 1
    }
};
var _lua_clock_start = (new Date).getTime() / 1e3;
lua_libs["os"] = {
    clock: function () {
        return [(new Date).getTime() / 1e3 - _lua_clock_script]
    },
    date: function (format, time) {
        return ["[" + time + "]" + format]
    },
    difftime: function (t2, t1) {
        return [t2 - t1]
    },
    execute: function () {
        return 0
    },
    exit: function () {
        not_supported()
    },
    getenv: function (varname) {
        return [null]
    },
    remove: function () {
        not_supported()
    },
    rename: function () {
        not_supported()
    },
    setlocale: function () {
        not_supported()
    },
    time: function (table) {
        if (table) {
            not_supported()
        } else {
            return [Math.floor((new Date).getTime() / 1e3)]
        }
    }
};
var lua_packages = lua_newtable();

function lua_createmodule(G, name, options) {
    var t = lua_tableget(lua_packages, name) || lua_tableget(G, name) || lua_newtable();
    lua_tableset(G, name, t);
    lua_tableset(lua_packages, name, t);
    lua_tableset(t, "_NAME", name);
    lua_tableset(t, "_M", t);
    lua_tableset(t, "_PACKAGE", name.split(".").slice(0, -1).join("."));
    for (var i = 0; i < options.length; i++) {
        lua_call(options[i], [t])
    }
    return t
}

function lua_module(name) {
    var t = lua_tableget(lua_packages, name);
    if (t == null) {
        throw new Error("Module " + name + " not found. Module must be loaded before use.")
    }
    return t
}

function lua_require(G, name) {
    var t = lua_module(name);
    var pkg = G;
    var names = name.split(".");
    for (var i = 0; i < names.length - 1; i++) {
        if (!lua_tableget(pkg, names[i])) {
            var newPkg = lua_newtable();
            lua_tableset(pkg, names[i], newPkg);
            pkg = newPkg
        }
    }
    lua_tableset(pkg, names[names.length - 1], t);
    return t
}
lua_libs["package"] = {
    path: "",
    cpath: "",
    loaded: lua_packages,
    loaders: lua_newtable(),
    preload: lua_newtable(),
    loadlib: function () {
        not_supported()
    }
};
lua_libs["string"] = {
    byte: function (s, i, j) {
        s = check_string(s);
        if (i == null) {
            i = 1
        }
        if (j == null) {
            j = i
        }
        var result = [];
        while (i <= j && i <= s.length) {
            result.push(s.charCodeAt(i - 1));
            i++
        }
        return result
    },
    char: function () {
        return [String.fromCharCode.apply(null, arguments)]
    },
    dump: function (func) {
        not_supported()
    },
    find: function () {
        not_supported()
    },
    format: function (formatstring) {
        return ["[" + slice(arguments, 1).join(", ") + "]" + arguments[0]]
    },
    gmatch: function (s, pattern) {
        not_supported()
    },
    gsub: function (s, pattern, repl, n) {
        not_supported()
    },
    len: function (s) {
        return [check_string(s).length]
    },
    lower: function (s) {
        return [check_string(s).toLowerCase()]
    },
    match: function (s) {
        not_supported()
    },
    rep: function (s, n) {
        s = check_string(s);
        if (typeof n == "number") {
            var result = [];
            while (n-- > 0) {
                result.push(s)
            }
            return [result.join("")]
        } else {
            throw new Error("Input not string and number")
        }
    },
    reverse: function (s) {
        return [check_string(s).split("").reverse().join("")]
    },
    sub: function (s, i, j) {
        i = i < 0 ? i + s.length + 1 : i >= 0 ? i : 0;
        if (j == null) {
            j = -1
        }
        j = j < 0 ? j + s.length + 1 : j >= 0 ? j : 0;
        if (i < 1) {
            i = 1
        }
        if (j > s.length) {
            j = s.length
        }
        if (i <= j) {
            return [s.substr(i - 1, j - i + 1)]
        } else {
            return [""]
        }
    },
    upper: function (s) {
        return [check_string(s).toUpperCase()]
    }
};
String.prototype["metatable"] = lua_newtable(null, "__index", lua_newtable2(lua_libs["string"]));
lua_libs["table"] = {
    concat: function (table, sep, i, j) {
        ensure_arraymode(table);
        if (sep == null) {
            sep = ""
        }
        if (i != null) {
            if (j == null) {
                j = table.uints.length
            }
            return [table.uints.slice(i - 1, j).join(sep)]
        } else {
            return [table.uints.join(sep)]
        }
    },
    insert: function (table, pos, value) {
        ensure_arraymode(table);
        if (arguments.length == 2) {
            value = pos;
            pos = table.uints.length + 1
        }
        table.uints.splice(pos - 1, 0, value);
        if (table.length != null) {
            table.length++
        }
        return []
    },
    maxn: function (table) {
        if (table.arraymode) {
            return [table.uints.length]
        } else {
            var max = 0;
            for (var i in table.uints) {
                var val = parseFloat(i);
                if (val > max) {
                    max = val
                }
            }
            return [max]
        }
    },
    remove: function (table, pos) {
        ensure_arraymode(table);
        if (pos == null) {
            pos = table.uints.length
        } else {
            pos = lua_assertfloat(pos)
        } if (table.uints.length) {
            var value = table.uints[pos - 1];
            table.uints.splice(pos - 1, 1);
            if (table.length != null) {
                table.length--
            }
            return [value]
        } else {
            return []
        }
    },
    sort: function (table, comp) {
        ensure_arraymode(table);
        if (comp) {
            table.uints.sort(function (a, b) {
                return comp(a, b)[0] ? -1 : 1
            })
        } else {
            table.uints.sort(function (a, b) {
                return lua_lt(a, b) ? -1 : 1
            })
        }
        return []
    }
};
lua_libs["bit"] = {
    tobit: function (x) {
        return [x << 0]
    },
    tohex: function (x, n) {
        if (n > 0) {
            var str = x.toString(16).substr(-n);
            while (str.length < n) {
                str = "0" + str
            }
            return [str]
        } else if (n < 0) {
            var str = x.toString(16).substr(n).toUpperCase();
            while (str.length < -n) {
                str = "0" + str
            }
            return [str]
        } else {
            return [x.toString(16)]
        }
    },
    bnot: function (x) {
        return [~x]
    },
    bor: function (x) {
        x = lua_assertfloat(x);
        for (var i = 1; i < arguments.length; i++) {
            x |= arguments[i]
        }
        return [x]
    },
    band: function (x) {
        x = lua_assertfloat(x);
        for (var i = 1; i < arguments.length; i++) {
            x &= arguments[i]
        }
        return [x]
    },
    bxor: function (x) {
        x = lua_assertfloat(x);
        for (var i = 1; i < arguments.length; i++) {
            x ^= arguments[i]
        }
        return [x]
    },
    lshift: function (x, n) {
        return [x << n]
    },
    rshift: function (x, n) {
        return [x >>> n]
    },
    arshift: function (x, n) {
        return [x >> n]
    },
    rol: function (x, n) {
        n &= 15;
        return [x << n | x >>> -n]
    },
    ror: function (x, n) {
        n &= 15;
        return [x >>> n | x << -n]
    },
    bswap: function (x) {
        x = x >> 1 & 1431655765 | (x & 1431655765) << 1;
        x = x >> 2 & 858993459 | (x & 858993459) << 2;
        x = x >> 4 & 252645135 | (x & 252645135) << 4;
        x = x >> 8 & 16711935 | (x & 16711935) << 8;
        x = x >> 16 | x << 16;
        return [x]
    }
};
(function () {
    if (!ArrayBuffer.prototype.slice) {
        ArrayBuffer.prototype.slice = function (start, end) {
            var i, result, resultArray, that;
            that = new Uint8Array(this);
            if (end === undefined) {
                end = that.length
            }
            result = new ArrayBuffer(end - start);
            resultArray = new Uint8Array(result);
            i = 0;
            while (i < resultArray.length) {
                resultArray[i] = that[i + start];
                i++
            }
            return result
        }
    }
    THREE.Euler.DefaultOrder = "YXZ";
    window.CSPlayer = {
        GoFullscreen: function () {
            if (CSPlayer.gameInstance != null) {
                return CSPlayer.gameInstance.gameInput.GoFullscreen()
            }
        },
        UInt8MaxValue: 255,
        UInt16MaxValue: 65535,
        UInt32MaxValue: 4294967295,
        GlobalSizeMultiplier: 1 / 16,
        LerpMultiplier: 15,
        Components: {},
        ComponentInstances: {},
        Projector: new THREE.Projector,
        HasFlag: function (val, flag) {
            return (val & flag) === flag
        },
        VertexShader: "varying vec2 fragUV;\nvarying vec4 diffuse;\n\nuniform vec3 lightDiffuseColor;\nuniform vec3 ambientColor;\n\nvoid main() {\n  fragUV = uv;\n  vec4 modelViewPosition = modelViewMatrix *  vec4(position, 1.0);\n  \n  vec3 worldNormal = normalize( normalMatrix * normal );\n  diffuse = vec4( max( vec3(0,0,0), dot( worldNormal, vec3( 0.0, 0.0, 1.0 ) ) * lightDiffuseColor ) + ambientColor, 1.0 );\n  \n  gl_Position = projectionMatrix * modelViewPosition;\n}",
        FragmentShader: "uniform sampler2D map;\nuniform vec4 colorMod;\nvarying vec2 fragUV;\nvarying vec4 diffuse;\n\nvoid main() {\n  vec4 color = texture2D(map, fragUV);\n  if(color.a < 0.001) discard;\n  color *= diffuse;\n  color *= colorMod;\n  color.rgb *= colorMod.a;\n  gl_FragColor = color;\n}"
    };
    CSPlayer.AssetType = {
        Sprite: 5,
        Model: 0,
        ModelAnimation: 6,
        Map: 1,
        TileSet: 3,
        Scene: 2,
        Script: 7,
        Document: 4,
        Sound: 8,
        Font: 9,
        SoundInstance: CSPlayer.UInt8MaxValue + 0
    };
    CSPlayer.ComponentType = {
        Transform: 0,
        Camera: 1,
        ModelRenderer: 2,
        MapRenderer: 3,
        ScriptedBehavior: 4,
        Physics: 5,
        NetworkSync: 6,
        TextRenderer: 7
    };
    CSPlayer.AssetTypeNames = {};
    CSPlayer.AssetTypeNames[CSPlayer.AssetType.Sprite] = "Sprite";
    CSPlayer.AssetTypeNames[CSPlayer.AssetType.Model] = "Model";
    CSPlayer.AssetTypeNames[CSPlayer.AssetType.ModelAnimation] = "ModelAnimation";
    CSPlayer.AssetTypeNames[CSPlayer.AssetType.Map] = "Map";
    CSPlayer.AssetTypeNames[CSPlayer.AssetType.TileSet] = "TileSet";
    CSPlayer.AssetTypeNames[CSPlayer.AssetType.Scene] = "Scene";
    CSPlayer.AssetTypeNames[CSPlayer.AssetType.Script] = "Script";
    CSPlayer.AssetTypeNames[CSPlayer.AssetType.Document] = "Document";
    CSPlayer.AssetTypeNames[CSPlayer.AssetType.Sound] = "Sound";
    CSPlayer.AssetTypeNames[CSPlayer.AssetType.Font] = "Font";
    CSPlayer.SetScreenRatio = function (ratio) {
        CSPlayer.ScreenRatio = ratio;
        return CSPlayer.UpdateCanvasSize()
    };
    CSPlayer.UpdateCanvasSize = function () {
        var height, width;
        width = window.innerWidth;
        height = window.innerHeight;
        if (CSPlayer.ScreenRatio != null) {
            height = window.innerWidth / CSPlayer.ScreenRatio;
            if (height > window.innerHeight) {
                width *= window.innerHeight / height;
                height = window.innerHeight
            }
        }
        CSPlayer.renderer.setSize(width, height);
        CSPlayer.canvas.style.top = Math.floor((window.innerHeight - height) / 2) + "px";
        return CSPlayer.canvas.style.left = Math.floor((window.innerWidth - width) / 2) + "px"
    };
    CSPlayer.Init = function (scriptRootPath, canvasContainer, callback) {
        CSPlayer.ScriptRootPath = scriptRootPath || "";
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        if (window.AudioContext != null) {
            CSPlayer.audioCtx = new AudioContext;
            CSPlayer.masterGain = CSPlayer.audioCtx.createGain();
            CSPlayer.masterGain.gain.value = 1;
            CSPlayer.masterGain.connect(CSPlayer.audioCtx.destination)
        }
        return WebGLHelper.CreateGLCanvas(canvasContainer, "CSPlayerCanvas", false, function (canvas) {
            CSPlayer.scene = new THREE.Scene;
            CSPlayer.scene.autoUpdate = false;
            CSPlayer.scene.add(new THREE.AmbientLight(Math.random() * 2105376));
            CSPlayer.renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                precision: "mediump",
                alpha: false,
                antialias: false,
                stencil: false
            });
            CSPlayer.renderer.autoClearColor = false;
            CSPlayer.renderer.sortObjects = true;
            CSPlayer.renderer.setFaceCulling(THREE.CullFaceNone);
            CSPlayer.renderer.setBlending(THREE.CustomBlending, THREE.AddEquation, THREE.OneFactor, THREE.OneMinusSrcAlphaFactor);
            canvas.setAttribute("tabindex", 0);
            CSPlayer.canvas = canvas;
            $(window).resize(CSPlayer.UpdateCanvasSize);
            CSPlayer.SetScreenRatio(window.innerWidth / window.innerHeight);
            return CSPlayer.DownloadUrl(CSPlayer.ScriptRootPath + "Inflate.js", "blob", function (blob) {
                var urlConstructor;
                urlConstructor = window.URL || window.webkitURL;
                CSPlayer.InflateWorkerBlobURL = urlConstructor.createObjectURL(blob);
                return callback(canvas)
            })
        }, function (e) {
            callback(null);
            return console.error("Failed to create WebGL canvas: " + e)
        })
    };
    CSPlayer.DownloadUrl = function (url, responseType, callback, progressCallback) {
        var length, request;
        length = 0;
        request = new XMLHttpRequest;
        if (progressCallback) {
            request.onprogress = function (_this) {
                return function (progressEvent) {
                    if (progressEvent.lengthComputable) {
                        return progressCallback(progressEvent.loaded, progressEvent.total)
                    }
                }
            }(this)
        }
        request.onreadystatechange = function (_this) {
            return function () {
                if (request.readyState === 4) {
                    if (request.status === 0 || request.status === 200) {
                        return callback(request.response)
                    } else {
                        return callback(new Error("Download failed"))
                    }
                }
            }
        }(this);
        request.open("GET", url, true);
        request.responseType = responseType;
        return request.send(null)
    };
    CSPlayer.RunGame = function (baseUrl, callback, progressCallback) {
        progressCallback(0, 1, "Downloading game package...");
        return CSPlayer.GamePackage.LoadFromBaseUrl(baseUrl, function (gamePackage) {
            CSPlayer.gameInstance = new CSPlayer.GameInstance(gamePackage, CSPlayer.canvas);
            return CSPlayer.gameInstance.Init(function () {
                callback();
                CSPlayer.gameInstance.LoadScene(gamePackage.startupSceneId);
                CSPlayer.updateInterval = 1 / 60 * 1e3;
                CSPlayer.lastTimestamp = 0;
                CSPlayer.accumulatedTime = 0;
                return CSPlayer.DoFrame()
            }, progressCallback)
        }, progressCallback)
    };
    CSPlayer.DoFrame = function (timestamp) {
        requestAnimationFrame(CSPlayer.DoFrame);
        timestamp = timestamp || 0;
        CSPlayer.accumulatedTime += timestamp - CSPlayer.lastTimestamp;
        CSPlayer.lastTimestamp = timestamp;
        if (CSPlayer.accumulatedTime > 5 * CSPlayer.updateInterval) {
            CSPlayer.accumulatedTime = CSPlayer.updateInterval * 5
        }
        while (CSPlayer.accumulatedTime >= CSPlayer.updateInterval) {
            CSPlayer.gameInstance.Update();
            CSPlayer.accumulatedTime -= CSPlayer.updateInterval
        }
        return CSPlayer.gameInstance.Draw()
    }
}).call(this);
(function () {
    CSPlayer.BinaryReader = function () {
        var textDecoder;
        if (typeof TextDecoder !== "undefined" && TextDecoder !== null) {
            textDecoder = new TextDecoder;
            BinaryReader.DecodeString = function (array) {
                return textDecoder.decode(array)
            }
        } else {
            BinaryReader.DecodeString = function (array) {
                return String.fromCharCode.apply(null, array)
            }
        }

        function BinaryReader(buffer) {
            this.view = new DataView(buffer);
            this.cursor = 0
        }
        BinaryReader.prototype.ReadUInt8 = function () {
            var val;
            val = this.view.getUint8(this.cursor);
            this.cursor += 1;
            return val
        };
        BinaryReader.prototype.ReadUInt16 = function () {
            var val;
            val = this.view.getUint16(this.cursor, true);
            this.cursor += 2;
            return val
        };
        BinaryReader.prototype.ReadInt32 = function () {
            var val;
            val = this.view.getInt32(this.cursor, true);
            this.cursor += 4;
            return val
        };
        BinaryReader.prototype.ReadUInt32 = function () {
            var val;
            val = this.view.getUint32(this.cursor, true);
            this.cursor += 4;
            return val
        };
        BinaryReader.prototype.ReadFloat32 = function () {
            var val;
            val = this.view.getFloat32(this.cursor, true);
            this.cursor += 4;
            return val
        };
        BinaryReader.prototype.ReadFloat64 = function () {
            var val;
            val = this.view.getFloat64(this.cursor, true);
            this.cursor += 8;
            return val
        };
        BinaryReader.prototype.Read7BitEncodedInt = function () {
            var bitIndex, num, returnValue;
            returnValue = 0;
            bitIndex = 0;
            while (true) {
                if (bitIndex !== 35) {
                    num = this.ReadUInt8();
                    returnValue |= (num & 127) << bitIndex;
                    bitIndex += 7
                } else {
                    throw new Error("Invalid 7-bit encoded int")
                } if ((num & 128) === 0) {
                    break
                }
            }
            return returnValue
        };
        BinaryReader.prototype.ReadBoolean = function () {
            return this.ReadUInt8() !== 0
        };
        BinaryReader.prototype.ReadString = function () {
            var length, val;
            length = this.Read7BitEncodedInt();
            val = CSPlayer.BinaryReader.DecodeString(new Uint8Array(this.view.buffer.slice(this.cursor, this.cursor + length)));
            this.cursor += length;
            return val
        };
        BinaryReader.prototype.ReadPoint = function () {
            return {
                x: this.ReadInt32(),
                y: this.ReadInt32()
            }
        };
        BinaryReader.prototype.ReadVector2 = function () {
            return new THREE.Vector2(this.ReadFloat32(), this.ReadFloat32())
        };
        BinaryReader.prototype.ReadVector3 = function () {
            return new THREE.Vector3(this.ReadFloat32(), this.ReadFloat32(), this.ReadFloat32())
        };
        BinaryReader.prototype.ReadIntVector3 = function () {
            return new THREE.Vector3(this.ReadInt32(), this.ReadInt32(), this.ReadInt32())
        };
        BinaryReader.prototype.ReadQuaternion = function () {
            var w;
            w = this.ReadFloat32();
            return new THREE.Quaternion(this.ReadFloat32(), this.ReadFloat32(), this.ReadFloat32(), w)
        };
        BinaryReader.prototype.ReadBytes = function (length) {
            var bytes;
            bytes = new Uint8Array(this.view.buffer.slice(this.cursor, this.cursor + length));
            this.cursor += length;
            return bytes
        };
        return BinaryReader
    }()
}).call(this);
(function () {
    CSPlayer.NodeTree = function () {
        function NodeTree(nextNodeId) {
            this.nextNodeId = nextNodeId;
            this.rootNodes = [];
            this.nodesById = {}
        }
        NodeTree.prototype.GenerateNextNodeId = function () {
            return this.nextNodeId++
        };
        NodeTree.prototype.Walk = function (callback) {
            var walkRecurse;
            walkRecurse = function (nodes, callback) {
                var node, _i, _len, _results;
                _results = [];
                for (_i = 0, _len = nodes.length; _i < _len; _i++) {
                    node = nodes[_i];
                    callback(node);
                    if (node.children.length > 0) {
                        _results.push(walkRecurse(node.children, callback))
                    } else {
                        _results.push(void 0)
                    }
                }
                return _results
            };
            return walkRecurse(this.rootNodes, callback)
        };
        NodeTree.prototype.Clear = function () {
            var clearRecurse;
            clearRecurse = function (nodes) {
                var node, _i, _len, _results;
                _results = [];
                for (_i = 0, _len = nodes.length; _i < _len; _i++) {
                    node = nodes[_i];
                    if (node.children.length > 0) {
                        clearRecurse(node.children)
                    }
                    _results.push(node.nodeTree = null)
                }
                return _results
            };
            clearRecurse(this.rootNodes);
            this.nodesById = {};
            return this.rootNodes.length = 0
        };
        NodeTree.prototype.AddNode = function (node) {
            this.nodesById[node.nodeId] = node;
            if (node.parentNodeId !== CSPlayer.UInt16MaxValue) {
                return this.nodesById[node.parentNodeId].children.push(node)
            } else {
                return this.rootNodes.push(node)
            }
        };
        NodeTree.prototype.DeleteNode = function (nodeId) {
            var index, node;
            node = this.nodesById[nodeId];
            if (node.parentNodeId !== CSPlayer.UInt16MaxValue) {
                index = this.nodesById[node.parentNodeId].children.indexOf(node);
                this.nodesById[node.parentNodeId].children.splice(index, 1)
            } else {
                index = this.rootNodes.indexOf(node);
                this.rootNodes.splice(index, 1)
            }
            delete this.nodesById[nodeId];
            return node.nodeTree = null
        };
        return NodeTree
    }();
    CSPlayer.Node = function () {
        function Node(nodeTree, nodeId, parentNodeId, name) {
            this.nodeTree = nodeTree;
            this.nodeId = nodeId;
            this.parentNodeId = parentNodeId != null ? parentNodeId : CSPlayer.UInt16MaxValue;
            this.name = name;
            this.children = []
        }
        return Node
    }()
}).call(this);
(function () {
    CSPlayer.BlockUVLayout = function () {
        function BlockUVLayout() {}
        BlockUVLayout.QuadTransform = {
            None: 0,
            Rotate90: 1 << 0,
            Rotate180: 1 << 1,
            Rotate270: 1 << 2,
            MirrorHorizontal: 1 << 3,
            MirrorVertical: 1 << 4
        };
        BlockUVLayout.PaneDepthDivider = 4;
        BlockUVLayout.ApplyQuadUVTransform = function (uv, startOffset, origin, transform) {
            var cosTheta, sinTheta, x, y;
            if ((transform & CSPlayer.BlockUVLayout.QuadTransform.MirrorHorizontal) !== 0) {
                uv[startOffset + 0 * 2 + 0] = origin.x + (origin.x - uv[startOffset + 0 * 2 + 0]);
                uv[startOffset + 1 * 2 + 0] = origin.x + (origin.x - uv[startOffset + 1 * 2 + 0]);
                uv[startOffset + 2 * 2 + 0] = origin.x + (origin.x - uv[startOffset + 2 * 2 + 0]);
                uv[startOffset + 3 * 2 + 0] = origin.x + (origin.x - uv[startOffset + 3 * 2 + 0])
            }
            if ((transform & CSPlayer.BlockUVLayout.QuadTransform.MirrorVertical) !== 0) {
                uv[startOffset + 0 * 2 + 1] = origin.y + (origin.y - uv[startOffset + 0 * 2 + 1]);
                uv[startOffset + 1 * 2 + 1] = origin.y + (origin.y - uv[startOffset + 1 * 2 + 1]);
                uv[startOffset + 2 * 2 + 1] = origin.y + (origin.y - uv[startOffset + 2 * 2 + 1]);
                uv[startOffset + 3 * 2 + 1] = origin.y + (origin.y - uv[startOffset + 3 * 2 + 1])
            }
            cosTheta = 1;
            sinTheta = 0;
            if ((transform & CSPlayer.BlockUVLayout.QuadTransform.Rotate90) !== 0) {
                cosTheta = 0;
                sinTheta = 1
            } else if ((transform & CSPlayer.BlockUVLayout.QuadTransform.Rotate180) !== 0) {
                cosTheta = -1;
                sinTheta = 0
            } else if ((transform & CSPlayer.BlockUVLayout.QuadTransform.Rotate270) !== 0) {
                cosTheta = 0;
                sinTheta = -1
            }
            x = origin.x + (uv[startOffset + 0 * 2 + 0] - origin.x) * cosTheta - (uv[startOffset + 0 * 2 + 1] - origin.y) * sinTheta;
            y = origin.y + (uv[startOffset + 0 * 2 + 0] - origin.x) * sinTheta + (uv[startOffset + 0 * 2 + 1] - origin.y) * cosTheta;
            uv[startOffset + 0 * 2 + 0] = x;
            uv[startOffset + 0 * 2 + 1] = y;
            x = origin.x + (uv[startOffset + 1 * 2 + 0] - origin.x) * cosTheta - (uv[startOffset + 1 * 2 + 1] - origin.y) * sinTheta;
            y = origin.y + (uv[startOffset + 1 * 2 + 0] - origin.x) * sinTheta + (uv[startOffset + 1 * 2 + 1] - origin.y) * cosTheta;
            uv[startOffset + 1 * 2 + 0] = x;
            uv[startOffset + 1 * 2 + 1] = y;
            x = origin.x + (uv[startOffset + 2 * 2 + 0] - origin.x) * cosTheta - (uv[startOffset + 2 * 2 + 1] - origin.y) * sinTheta;
            y = origin.y + (uv[startOffset + 2 * 2 + 0] - origin.x) * sinTheta + (uv[startOffset + 2 * 2 + 1] - origin.y) * cosTheta;
            uv[startOffset + 2 * 2 + 0] = x;
            uv[startOffset + 2 * 2 + 1] = y;
            x = origin.x + (uv[startOffset + 3 * 2 + 0] - origin.x) * cosTheta - (uv[startOffset + 3 * 2 + 1] - origin.y) * sinTheta;
            y = origin.y + (uv[startOffset + 3 * 2 + 0] - origin.x) * sinTheta + (uv[startOffset + 3 * 2 + 1] - origin.y) * cosTheta;
            uv[startOffset + 3 * 2 + 0] = x;
            uv[startOffset + 3 * 2 + 1] = y
        };
        BlockUVLayout.ApplyQuadUVTransformXY = function (uv, origin, transform) {
            var cosTheta, sinTheta;
            if ((transform & CSPlayer.BlockUVLayout.QuadTransform.MirrorHorizontal) !== 0) {
                uv[0].x = origin.x + (origin.x - uv[0].x);
                uv[1].x = origin.x + (origin.x - uv[1].x);
                uv[2].x = origin.x + (origin.x - uv[2].x);
                uv[3].x = origin.x + (origin.x - uv[3].x)
            }
            if ((transform & CSPlayer.BlockUVLayout.QuadTransform.MirrorVertical) !== 0) {
                uv[0].y = origin.y + (origin.y - uv[0].y);
                uv[1].y = origin.y + (origin.y - uv[1].y);
                uv[2].y = origin.y + (origin.y - uv[2].y);
                uv[3].y = origin.y + (origin.y - uv[3].y)
            }
            cosTheta = 1;
            sinTheta = 0;
            if ((transform & CSPlayer.BlockUVLayout.QuadTransform.Rotate90) !== 0) {
                cosTheta = 0;
                sinTheta = 1
            } else if ((transform & CSPlayer.BlockUVLayout.QuadTransform.Rotate180) !== 0) {
                cosTheta = -1;
                sinTheta = 0
            } else if ((transform & CSPlayer.BlockUVLayout.QuadTransform.Rotate270) !== 0) {
                cosTheta = 0;
                sinTheta = -1
            }
            uv[0].set(origin.x + (uv[0].x - origin.x) * cosTheta - (uv[0].y - origin.y) * sinTheta, origin.y + (uv[0].x - origin.x) * sinTheta + (uv[0].y - origin.y) * cosTheta);
            uv[1].set(origin.x + (uv[1].x - origin.x) * cosTheta - (uv[1].y - origin.y) * sinTheta, origin.y + (uv[1].x - origin.x) * sinTheta + (uv[1].y - origin.y) * cosTheta);
            uv[2].set(origin.x + (uv[2].x - origin.x) * cosTheta - (uv[2].y - origin.y) * sinTheta, origin.y + (uv[2].x - origin.x) * sinTheta + (uv[2].y - origin.y) * cosTheta);
            uv[3].set(origin.x + (uv[3].x - origin.x) * cosTheta - (uv[3].y - origin.y) * sinTheta, origin.y + (uv[3].x - origin.x) * sinTheta + (uv[3].y - origin.y) * cosTheta)
        };
        return BlockUVLayout
    }()
}).call(this);
(function () {
    CSPlayer.GameControl = function () {
        var CurrentFormatVersion, OldestSupportedFormatVersion;
        CurrentFormatVersion = 1;
        OldestSupportedFormatVersion = 1;
        GameControl.ControlType = {
            Axis: 0,
            Button: 1
        };
        GameControl.ControlSource = {
            Keyboard: 0,
            MouseButton: 1,
            JoystickButton: 2,
            JoystickAxis: 3
        };
        GameControl.Keys = {
            None: 0,
            Back: 8,
            Tab: 9,
            Enter: 13,
            Pause: 19,
            CapsLock: 20,
            Kana: 21,
            Kanji: 25,
            Escape: 27,
            ImeConvert: 28,
            ImeNoConvert: 29,
            Space: 32,
            PageUp: 33,
            PageDown: 34,
            End: 35,
            Home: 36,
            Left: 37,
            Up: 38,
            Right: 39,
            Down: 40,
            Select: 41,
            Print: 42,
            Execute: 43,
            PrintScreen: 44,
            Insert: 45,
            Delete: 46,
            Help: 47,
            D0: 48,
            D1: 49,
            D2: 50,
            D3: 51,
            D4: 52,
            D5: 53,
            D6: 54,
            D7: 55,
            D8: 56,
            D9: 57,
            A: 65,
            B: 66,
            C: 67,
            D: 68,
            E: 69,
            F: 70,
            G: 71,
            H: 72,
            I: 73,
            J: 74,
            K: 75,
            L: 76,
            M: 77,
            N: 78,
            O: 79,
            P: 80,
            Q: 81,
            R: 82,
            S: 83,
            T: 84,
            U: 85,
            V: 86,
            W: 87,
            X: 88,
            Y: 89,
            Z: 90,
            LeftWindows: 91,
            RightWindows: 92,
            Apps: 93,
            Sleep: 95,
            NumPad0: 96,
            NumPad1: 97,
            NumPad2: 98,
            NumPad3: 99,
            NumPad4: 100,
            NumPad5: 101,
            NumPad6: 102,
            NumPad7: 103,
            NumPad8: 104,
            NumPad9: 105,
            Multiply: 106,
            Add: 107,
            Separator: 108,
            Subtract: 109,
            Decimal: 110,
            Divide: 111,
            F1: 112,
            F2: 113,
            F3: 114,
            F4: 115,
            F5: 116,
            F6: 117,
            F7: 118,
            F8: 119,
            F9: 120,
            F10: 121,
            F11: 122,
            F12: 123,
            F13: 124,
            F14: 125,
            F15: 126,
            F16: 127,
            F17: 128,
            F18: 129,
            F19: 130,
            F20: 131,
            F21: 132,
            F22: 133,
            F23: 134,
            F24: 135,
            NumLock: 144,
            Scroll: 145,
            LeftShift: 160,
            RightShift: 161,
            LeftControl: 162,
            RightControl: 163,
            LeftAlt: 164,
            RightAlt: 165,
            BrowserBack: 166,
            BrowserForward: 167,
            BrowserRefresh: 168,
            BrowserStop: 169,
            BrowserSearch: 170,
            BrowserFavorites: 171,
            BrowserHome: 172,
            VolumeMute: 173,
            VolumeDown: 174,
            VolumeUp: 175,
            MediaNextTrack: 176,
            MediaPreviousTrack: 177,
            MediaStop: 178,
            MediaPlayPause: 179,
            LaunchMail: 180,
            SelectMedia: 181,
            LaunchApplication1: 182,
            LaunchApplication2: 183,
            OemSemicolon: 186,
            OemPlus: 187,
            OemComma: 188,
            OemMinus: 189,
            OemPeriod: 190,
            OemQuestion: 191,
            OemTilde: 192,
            ChatPadGreen: 202,
            ChatPadOrange: 203,
            OemOpenBrackets: 219,
            OemPipe: 220,
            OemCloseBrackets: 221,
            OemQuotes: 222,
            Oem8: 223,
            OemBackslash: 226,
            ProcessKey: 229,
            OemCopy: 242,
            OemAuto: 243,
            OemEnlW: 244,
            Attn: 246,
            Crsel: 247,
            Exsel: 248,
            EraseEof: 249,
            Play: 250,
            Zoom: 251,
            Pa1: 253,
            OemClear: 254
        };

        function GameControl(id, name) {
            this.id = id;
            this.name = name
        }
        GameControl.Deserialize = function (reader, formatVersion) {
            var control, id, name;
            id = reader.ReadUInt16();
            name = reader.ReadString();
            control = new CSPlayer.GameControl(id, name);
            control.type = reader.ReadUInt8();
            control.source = reader.ReadUInt8();
            control.positiveKey = reader.ReadUInt8();
            control.negativeKey = reader.ReadUInt8();
            control.positiveButtonIndex = reader.ReadUInt8();
            control.negativeButtonIndex = reader.ReadUInt8();
            control.joystickIndex = reader.ReadUInt8();
            control.joystickAxisIndex = reader.ReadUInt8();
            control.joystickAxisDeadZone = reader.ReadFloat32();
            control.axisSensitivity = reader.ReadFloat32();
            control.axisGravity = reader.ReadFloat32();
            control.axisSnap = reader.ReadBoolean();
            return control
        };
        return GameControl
    }()
}).call(this);
(function () {
    CSPlayer.Asset = function () {
        Asset.AssetTypeDirectories = {};
        Asset.AssetTypeDirectories[CSPlayer.AssetType.Sprite] = "Sprites";
        Asset.AssetTypeDirectories[CSPlayer.AssetType.Model] = "Models";
        Asset.AssetTypeDirectories[CSPlayer.AssetType.ModelAnimation] = "ModelAnimations";
        Asset.AssetTypeDirectories[CSPlayer.AssetType.Map] = "Maps";
        Asset.AssetTypeDirectories[CSPlayer.AssetType.TileSet] = "TileSets";
        Asset.AssetTypeDirectories[CSPlayer.AssetType.Scene] = "Scenes";
        Asset.AssetTypeDirectories[CSPlayer.AssetType.Script] = "Scripts";
        Asset.AssetTypeDirectories[CSPlayer.AssetType.Document] = "Documents";
        Asset.AssetTypeDirectories[CSPlayer.AssetType.Sound] = "Sounds";
        Asset.AssetTypeDirectories[CSPlayer.AssetType.Font] = "Fonts";
        Asset.AssetTypeExtensions = {};
        Asset.AssetTypeExtensions[CSPlayer.AssetType.Sprite] = "cssprite";
        Asset.AssetTypeExtensions[CSPlayer.AssetType.Model] = "csmodel";
        Asset.AssetTypeExtensions[CSPlayer.AssetType.ModelAnimation] = "csmodelanim";
        Asset.AssetTypeExtensions[CSPlayer.AssetType.Map] = "csmap";
        Asset.AssetTypeExtensions[CSPlayer.AssetType.TileSet] = "cstileset";
        Asset.AssetTypeExtensions[CSPlayer.AssetType.Scene] = "csscene";
        Asset.AssetTypeExtensions[CSPlayer.AssetType.Script] = "csscript";
        Asset.AssetTypeExtensions[CSPlayer.AssetType.Document] = "csdoc";
        Asset.AssetTypeExtensions[CSPlayer.AssetType.Sound] = "cssnd";
        Asset.AssetTypeExtensions[CSPlayer.AssetType.Font] = "csfont";

        function Asset(id, assetType) {
            this.id = id;
            this.assetType = assetType
        }
        Asset.LoadFromUrl = function (assetId, entryType, url, callback) {
            switch (entryType) {
            case CSPlayer.AssetType.Model:
                return CSPlayer.Model.LoadFromUrl(assetId, url, callback);
            case CSPlayer.AssetType.ModelAnimation:
                return CSPlayer.ModelAnimation.LoadFromUrl(assetId, url, callback);
            case CSPlayer.AssetType.Map:
                return CSPlayer.Map.LoadFromUrl(assetId, url, callback);
            case CSPlayer.AssetType.TileSet:
                return CSPlayer.TileSet.LoadFromUrl(assetId, url, callback);
            case CSPlayer.AssetType.Scene:
                return CSPlayer.Scene.LoadFromUrl(assetId, url, callback);
            case CSPlayer.AssetType.Script:
                return CSPlayer.Script.LoadFromUrl(assetId, url, callback);
            case CSPlayer.AssetType.Sound:
                return CSPlayer.Sound.LoadFromUrl(assetId, url, callback);
            case CSPlayer.AssetType.Font:
                return CSPlayer.Font.LoadFromUrl(assetId, url, callback);
            case CSPlayer.AssetType.Document:
                return callback(null, null)
            }
        };
        return Asset
    }()
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Model = function (_super) {
        var CurrentFormatVersion, OldestSupportedFormatVersion;
        __extends(Model, _super);
        OldestSupportedFormatVersion = 5;
        CurrentFormatVersion = 5;

        function Model(id) {
            Model.__super__.constructor.call(this, id, CSPlayer.AssetType.Model);
            this.nodeTree = new CSPlayer.NodeTree
        }
        Model.LoadFromUrl = function (id, url, callback) {
            return CSPlayer.DownloadUrl(url, "arraybuffer", function (_this) {
                return function (buffer) {
                    var reader;
                    reader = new CSPlayer.BinaryReader(buffer);
                    return _this.Deserialize(id, reader, callback)
                }
            }(this))
        };
        Model.Deserialize = function (id, reader, callback) {
            var assetType, formatVersion, i, img, index, model, node, nodeCount, s, textureData, textureDataLength, _i, _j, _ref;
            assetType = reader.ReadUInt8();
            if (assetType !== CSPlayer.AssetType.Model) {
                callback({
                    message: "Invalid asset type: " + assetType
                });
                return
            }
            formatVersion = reader.ReadUInt16();
            if (formatVersion < OldestSupportedFormatVersion || formatVersion > CurrentFormatVersion) {
                callback({
                    message: "Unsupported format version: " + formatVersion
                });
                return
            }
            model = new CSPlayer.Model(id);
            model.nodeTree.nextNodeId = reader.ReadUInt16();
            nodeCount = reader.ReadUInt16();
            for (index = _i = 0; 0 <= nodeCount ? _i < nodeCount : _i > nodeCount; index = 0 <= nodeCount ? ++_i : --_i) {
                node = CSPlayer.ModelNode.Deserialize(model.nodeTree, reader, formatVersion);
                model.nodeTree.AddNode(node)
            }
            textureDataLength = reader.ReadInt32();
            textureData = reader.ReadBytes(textureDataLength);
            img = new Image;
            img.onload = function () {
                model.image = img;
                return callback(null, model)
            };
            s = "";
            for (i = _j = 0, _ref = textureData.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
                s += String.fromCharCode(textureData[i])
            }
            return img.src = "data:image/png;base64," + btoa(s)
        };
        return Model
    }(CSPlayer.Asset);
    CSPlayer.ModelNode = function (_super) {
        __extends(ModelNode, _super);

        function ModelNode(nodeTree, nodeId, parentNodeId, name) {
            ModelNode.__super__.constructor.call(this, nodeTree, nodeId, parentNodeId, name);
            this.uvQuadOffsets = [];
            this.uvQuadTransforms = []
        }
        ModelNode.Deserialize = function (nodeTree, reader, formatVersion) {
            var i, node, unwrapMode, _i, _j;
            node = new CSPlayer.ModelNode(nodeTree, reader.ReadUInt16(), reader.ReadUInt16(), reader.ReadString());
            node.position = reader.ReadVector3();
            node.pivotOffset = reader.ReadVector3();
            node.scale = reader.ReadVector3();
            node.orientation = reader.ReadQuaternion();
            node.blockSize = {
                x: reader.ReadUInt16(),
                y: reader.ReadUInt16(),
                z: reader.ReadUInt16()
            };
            unwrapMode = reader.ReadUInt8();
            for (i = _i = 0; _i <= 5; i = ++_i) {
                node.uvQuadOffsets.push(reader.ReadPoint())
            }
            for (i = _j = 0; _j <= 5; i = ++_j) {
                node.uvQuadTransforms.push(reader.ReadUInt8())
            }
            return node
        };
        return ModelNode
    }(CSPlayer.Node)
}).call(this);
(function () {
    var ModelNodeAnimation, ModelNodeBlockSizeKeyFrame, ModelNodeKeyFrame, ModelNodeOrientationKeyFrame, ModelNodePivotOffsetKeyFrame, ModelNodePositionKeyFrame, ModelNodeScaleKeyFrame, __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.ModelAnimation = function (_super) {
        var CurrentFormatVersion, OldestSupportedFormatVersion;
        __extends(ModelAnimation, _super);
        OldestSupportedFormatVersion = 2;
        CurrentFormatVersion = 3;

        function ModelAnimation(id) {
            ModelAnimation.__super__.constructor.call(this, id, CSPlayer.AssetType.ModelAnimation);
            this.nodeAnimsByNodeName = {}
        }
        ModelAnimation.LoadFromUrl = function (id, url, callback) {
            return CSPlayer.DownloadUrl(url, "arraybuffer", function (_this) {
                return function (buffer) {
                    var reader;
                    reader = new CSPlayer.BinaryReader(buffer);
                    return _this.Deserialize(id, reader, callback)
                }
            }(this))
        };
        ModelAnimation.Deserialize = function (id, reader, callback) {
            var assetType, formatVersion, index, modelAnim, nodeCount, nodeName, _i;
            assetType = reader.ReadUInt8();
            if (assetType !== CSPlayer.AssetType.ModelAnimation) {
                callback({
                    message: "Invalid asset type: " + assetType
                });
                return
            }
            formatVersion = reader.ReadUInt16();
            if (formatVersion < OldestSupportedFormatVersion || formatVersion > CurrentFormatVersion) {
                callback({
                    message: "Unsupported format version: " + formatVersion
                });
                return
            }
            modelAnim = new CSPlayer.ModelAnimation(id);
            modelAnim.duration = reader.ReadUInt16();
            if (formatVersion >= 3) {
                modelAnim.holdLastKeyFrame = reader.ReadBoolean()
            } else {
                modelAnim.holdLastKeyFrame = false
            }
            nodeCount = reader.ReadUInt16();
            for (index = _i = 0; 0 <= nodeCount ? _i < nodeCount : _i > nodeCount; index = 0 <= nodeCount ? ++_i : --_i) {
                nodeName = reader.ReadString();
                modelAnim.nodeAnimsByNodeName[nodeName] = ModelNodeAnimation.Deserialize(reader, formatVersion)
            }
            return callback(null, modelAnim)
        };
        return ModelAnimation
    }(CSPlayer.Asset);
    ModelNodeAnimation = function () {
        function ModelNodeAnimation() {
            this.positionKeyFrames = [];
            this.orientationKeyFrames = [];
            this.blockSizeKeyFrames = [];
            this.pivotOffsetKeyFrames = [];
            this.scaleKeyFrames = []
        }
        ModelNodeAnimation.Deserialize = function (reader, formatVersion) {
            var DeserializeKeyFrames, nodeAnim;
            nodeAnim = new ModelNodeAnimation;
            DeserializeKeyFrames = function (keyFrameClass) {
                var i, keyFrameCount, keyFrames, _i;
                keyFrameCount = reader.ReadUInt16();
                keyFrames = [];
                for (i = _i = 0; 0 <= keyFrameCount ? _i < keyFrameCount : _i > keyFrameCount; i = 0 <= keyFrameCount ? ++_i : --_i) {
                    keyFrames.push(keyFrameClass.Deserialize(reader, formatVersion))
                }
                return keyFrames
            };
            nodeAnim.positionKeyFrames = DeserializeKeyFrames(ModelNodePositionKeyFrame);
            nodeAnim.orientationKeyFrames = DeserializeKeyFrames(ModelNodeOrientationKeyFrame);
            nodeAnim.blockSizeKeyFrames = DeserializeKeyFrames(ModelNodeBlockSizeKeyFrame);
            nodeAnim.pivotOffsetKeyFrames = DeserializeKeyFrames(ModelNodePivotOffsetKeyFrame);
            nodeAnim.scaleKeyFrames = DeserializeKeyFrames(ModelNodeScaleKeyFrame);
            return nodeAnim
        };
        ModelNodeAnimation.prototype.GetNearestKeyFrames = function (keyFrames, frame, holdLastKeyFrame) {
            var i, nextIndex, _i, _ref;
            if (keyFrames.length > 0 && keyFrames[keyFrames.length - 1].index <= frame) {
                return {
                    previous: keyFrames[keyFrames.length - 1],
                    next: holdLastKeyFrame ? keyFrames[keyFrames.length - 1] : keyFrames[0]
                }
            }
            for (i = _i = 0, _ref = keyFrames.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                if (keyFrames[i].index > frame) {
                    nextIndex = i;
                    if (nextIndex === 0 && holdLastKeyFrame) {
                        nextIndex = keyFrames.length - 1
                    }
                    return {
                        previous: keyFrames[(i + keyFrames.length - 1) % keyFrames.length],
                        next: keyFrames[nextIndex]
                    }
                }
            }
            return null
        };
        return ModelNodeAnimation
    }();
    ModelNodeKeyFrame = function () {
        function ModelNodeKeyFrame(index, interpolationMode) {
            this.index = index;
            this.interpolationMode = interpolationMode
        }
        return ModelNodeKeyFrame
    }();
    ModelNodePositionKeyFrame = function (_super) {
        __extends(ModelNodePositionKeyFrame, _super);

        function ModelNodePositionKeyFrame(index, interpolationMode, delta) {
            this.delta = delta;
            ModelNodePositionKeyFrame.__super__.constructor.call(this, index, interpolationMode)
        }
        ModelNodePositionKeyFrame.Deserialize = function (reader, formatVersion) {
            return new ModelNodePositionKeyFrame(reader.ReadUInt16(), reader.ReadUInt8(), reader.ReadVector3())
        };
        return ModelNodePositionKeyFrame
    }(ModelNodeKeyFrame);
    ModelNodePivotOffsetKeyFrame = function (_super) {
        __extends(ModelNodePivotOffsetKeyFrame, _super);

        function ModelNodePivotOffsetKeyFrame(index, interpolationMode, delta) {
            this.delta = delta;
            ModelNodePivotOffsetKeyFrame.__super__.constructor.call(this, index, interpolationMode)
        }
        ModelNodePivotOffsetKeyFrame.Deserialize = function (reader, formatVersion) {
            return new ModelNodePivotOffsetKeyFrame(reader.ReadUInt16(), reader.ReadUInt8(), reader.ReadVector3())
        };
        return ModelNodePivotOffsetKeyFrame
    }(ModelNodeKeyFrame);
    ModelNodeOrientationKeyFrame = function (_super) {
        __extends(ModelNodeOrientationKeyFrame, _super);

        function ModelNodeOrientationKeyFrame(index, interpolationMode, delta) {
            this.delta = delta;
            ModelNodeOrientationKeyFrame.__super__.constructor.call(this, index, interpolationMode)
        }
        ModelNodeOrientationKeyFrame.Deserialize = function (reader, formatVersion) {
            return new ModelNodeOrientationKeyFrame(reader.ReadUInt16(), reader.ReadUInt8(), reader.ReadQuaternion())
        };
        return ModelNodeOrientationKeyFrame
    }(ModelNodeKeyFrame);
    ModelNodeBlockSizeKeyFrame = function (_super) {
        __extends(ModelNodeBlockSizeKeyFrame, _super);

        function ModelNodeBlockSizeKeyFrame(index, interpolationMode, delta) {
            this.delta = delta;
            ModelNodeBlockSizeKeyFrame.__super__.constructor.call(this, index, interpolationMode)
        }
        ModelNodeBlockSizeKeyFrame.Deserialize = function (reader, formatVersion) {
            return new ModelNodeBlockSizeKeyFrame(reader.ReadUInt16(), reader.ReadUInt8(), reader.ReadIntVector3())
        };
        return ModelNodeBlockSizeKeyFrame
    }(ModelNodeKeyFrame);
    ModelNodeScaleKeyFrame = function (_super) {
        __extends(ModelNodeScaleKeyFrame, _super);

        function ModelNodeScaleKeyFrame(index, interpolationMode, delta) {
            this.delta = delta;
            ModelNodeScaleKeyFrame.__super__.constructor.call(this, index, interpolationMode)
        }
        ModelNodeScaleKeyFrame.Deserialize = function (reader, formatVersion) {
            return new ModelNodeScaleKeyFrame(reader.ReadUInt16(), reader.ReadUInt8(), reader.ReadVector3())
        };
        return ModelNodeScaleKeyFrame
    }(ModelNodeKeyFrame)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Map = function (_super) {
        var CurrentFormatVersion, OldestSupportedFormatVersion, getChunkBlockLocation;
        __extends(Map, _super);
        OldestSupportedFormatVersion = 4;
        CurrentFormatVersion = 4;
        Map.BlockOrientation = {
            North: 0,
            East: 1,
            South: 2,
            West: 3
        };

        function Map(id) {
            Map.__super__.constructor.call(this, id, CSPlayer.AssetType.Map);
            this.tileSetId = void 0
        }
        Map.prototype.SetBlockAt = function (blockLocation, blockId, blockOrientation) {
            var chunk, chunkLocation;
            chunkLocation = new THREE.Vector3(Math.floor(blockLocation.x / CSPlayer.MapChunk.ChunkWidth), Math.floor(blockLocation.y / CSPlayer.MapChunk.ChunkHeight), Math.floor(blockLocation.z / CSPlayer.MapChunk.ChunkDepth));
            chunk = this.chunks[chunkLocation.x + "_" + chunkLocation.y + "_" + chunkLocation.z];
            if (chunk == null) {
                chunk = new CSPlayer.MapChunk(true);
                chunk.location = chunkLocation;
                this.chunks[chunkLocation.x + "_" + chunkLocation.y + "_" + chunkLocation.z] = chunk
            }
            chunk.SetBlockAt({
                x: blockLocation.x - chunkLocation.x * CSPlayer.MapChunk.ChunkWidth,
                y: blockLocation.y - chunkLocation.y * CSPlayer.MapChunk.ChunkHeight,
                z: blockLocation.z - chunkLocation.z * CSPlayer.MapChunk.ChunkDepth
            }, blockId, blockOrientation)
        };
        getChunkBlockLocation = function (map, blockLocation) {
            var chunk, chunkLocation;
            chunkLocation = {
                x: Math.floor(blockLocation.x / CSPlayer.MapChunk.ChunkWidth),
                y: Math.floor(blockLocation.y / CSPlayer.MapChunk.ChunkHeight),
                z: Math.floor(blockLocation.z / CSPlayer.MapChunk.ChunkDepth)
            };
            chunk = map.chunks[chunkLocation.x + "_" + chunkLocation.y + "_" + chunkLocation.z];
            if (chunk == null) {
                return [null, null]
            }
            return [chunk, {
                x: blockLocation.x - chunkLocation.x * CSPlayer.MapChunk.ChunkWidth,
                y: blockLocation.y - chunkLocation.y * CSPlayer.MapChunk.ChunkHeight,
                z: blockLocation.z - chunkLocation.z * CSPlayer.MapChunk.ChunkDepth
            }]
        };
        Map.prototype.GetBlockIDAt = function (blockLocation) {
            var chunk, chunkBlockLocation, _ref;
            _ref = getChunkBlockLocation(this, blockLocation), chunk = _ref[0], chunkBlockLocation = _ref[1];
            if (chunk == null) {
                return CSPlayer.UInt8MaxValue
            }
            return chunk.GetBlockIDAt(chunkBlockLocation)
        };
        Map.prototype.GetBlockOrientationAt = function (blockLocation) {
            var chunk, chunkBlockLocation, _ref;
            _ref = getChunkBlockLocation(this, blockLocation), chunk = _ref[0], chunkBlockLocation = _ref[1];
            if (chunk == null) {
                return CSPlayer.Map.BlockOrientation.North
            }
            return chunk.GetBlockOrientationAt(chunkBlockLocation)
        };
        Map.LoadFromUrl = function (id, url, callback) {
            return CSPlayer.DownloadUrl(url, "arraybuffer", function (_this) {
                return function (buffer) {
                    var reader;
                    reader = new CSPlayer.BinaryReader(buffer);
                    return _this.Deserialize(id, reader, function (err, map) {
                        if (err != null) {
                            callback(err);
                            return
                        }
                        return CSPlayer.DownloadUrl(url + "chunks", "arraybuffer", function (chunksBuffer) {
                            var chunksReader;
                            chunksReader = new CSPlayer.BinaryReader(chunksBuffer);
                            return _this.DeserializeChunks(chunksReader, function (err, mapChunks) {
                                if (err != null) {
                                    callback(err);
                                    return
                                }
                                map.chunks = mapChunks;
                                return callback(null, map)
                            })
                        })
                    })
                }
            }(this))
        };
        Map.Deserialize = function (id, reader, callback) {
            var assetType, formatVersion, map;
            assetType = reader.ReadUInt8();
            if (assetType !== CSPlayer.AssetType.Map) {
                callback({
                    message: "Invalid asset type: " + assetType
                });
                return
            }
            formatVersion = reader.ReadUInt16();
            if (formatVersion < OldestSupportedFormatVersion || formatVersion > CurrentFormatVersion) {
                callback({
                    message: "Unsupported format version: " + formatVersion
                });
                return
            }
            map = new CSPlayer.Map(id);
            map.tileSetId = reader.ReadUInt16();
            return callback(null, map)
        };
        Map.DeserializeChunks = function (reader, callback) {
            var chunkCount, chunkIndex, chunks, doNextChunk, formatVersion;
            chunks = {};
            formatVersion = reader.ReadUInt16();
            chunkCount = reader.ReadUInt32();
            chunkIndex = 0;
            doNextChunk = function () {
                var x, y, z;
                if (chunkIndex === chunkCount) {
                    callback(null, chunks);
                    return
                }
                x = reader.ReadInt32();
                y = reader.ReadInt32();
                z = reader.ReadInt32();
                return CSPlayer.MapChunk.Deserialize(reader, formatVersion, function (chunk) {
                    if (chunk.blockIDs != null) {
                        chunks[x + "_" + y + "_" + z] = chunk;
                        chunk.location = new THREE.Vector3(x, y, z)
                    }
                    chunkIndex++;
                    return doNextChunk()
                })
            };
            doNextChunk()
        };
        return Map
    }(CSPlayer.Asset);
    CSPlayer.MapChunk = function () {
        MapChunk.ChunkWidth = 32;
        MapChunk.ChunkHeight = 32;
        MapChunk.ChunkDepth = 32;
        MapChunk.ChunkSize = MapChunk.ChunkWidth * MapChunk.ChunkHeight * MapChunk.ChunkDepth;

        function MapChunk(createEmpty) {
            var i, _i, _ref;
            if (createEmpty == null) {
                createEmpty = false
            }
            if (createEmpty) {
                this.blockIDs = new Uint8Array(CSPlayer.MapChunk.ChunkSize);
                for (i = _i = 0, _ref = CSPlayer.MapChunk.ChunkSize; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                    this.blockIDs[i] = CSPlayer.UInt8MaxValue
                }
                this.blockOrientations = new Uint8Array(CSPlayer.MapChunk.ChunkSize)
            }
        }
        MapChunk.IsInBounds = function (blockLocation) {
            return 0 <= blockLocation.x && blockLocation.x < CSPlayer.MapChunk.ChunkWidth && 0 <= blockLocation.y && blockLocation.y < CSPlayer.MapChunk.ChunkHeight && 0 <= blockLocation.z && blockLocation.z < CSPlayer.MapChunk.ChunkDepth
        };
        MapChunk.prototype.GetBlockIDAt = function (blockLocation) {
            return this.blockIDs[blockLocation.z * CSPlayer.MapChunk.ChunkWidth * CSPlayer.MapChunk.ChunkHeight + blockLocation.y * CSPlayer.MapChunk.ChunkWidth + blockLocation.x]
        };
        MapChunk.prototype.GetBlockOrientationAt = function (blockLocation) {
            return this.blockOrientations[blockLocation.z * CSPlayer.MapChunk.ChunkWidth * CSPlayer.MapChunk.ChunkHeight + blockLocation.y * CSPlayer.MapChunk.ChunkWidth + blockLocation.x]
        };
        MapChunk.prototype.SetBlockAt = function (blockLocation, blockId, blockOrientation) {
            var offset;
            offset = blockLocation.z * CSPlayer.MapChunk.ChunkWidth * CSPlayer.MapChunk.ChunkHeight + blockLocation.y * CSPlayer.MapChunk.ChunkWidth + blockLocation.x;
            this.blockIDs[offset] = blockId;
            return this.blockOrientations[offset] = blockOrientation
        };
        MapChunk.prototype.SetupFromCompressedData = function (compressedData, formatVersion, callback) {
            var e, worker;
            if (CSPlayer.InflateWorkerBlobURL != null) {
                try {
                    worker = new Worker(CSPlayer.InflateWorkerBlobURL)
                } catch (_error) {
                    e = _error;
                    worker = new Worker(CSPlayer.ScriptRootPath + "Inflate.js")
                }
            } else {
                worker = new Worker(CSPlayer.ScriptRootPath + "Inflate.js")
            }
            worker.onmessage = function (_this) {
                return function (event) {
                    if (event.data.onappend) {
                        if (event.data.data !== -1) {
                            _this.blockIDs = new Uint8Array(event.data.data.buffer.slice(0, CSPlayer.MapChunk.ChunkSize));
                            _this.blockOrientations = new Uint8Array(event.data.data.buffer.slice(CSPlayer.MapChunk.ChunkSize, CSPlayer.MapChunk.ChunkSize + CSPlayer.MapChunk.ChunkSize))
                        }
                        worker.terminate();
                        return callback()
                    }
                }
            }(this);
            return worker.postMessage({
                append: true,
                data: compressedData
            })
        };
        MapChunk.Deserialize = function (reader, formatVersion, callback) {
            var chunk, compressedDataLength;
            chunk = new CSPlayer.MapChunk;
            compressedDataLength = reader.ReadUInt32();
            return chunk.SetupFromCompressedData(reader.ReadBytes(compressedDataLength), formatVersion, function () {
                return callback(chunk)
            })
        };
        return MapChunk
    }()
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.TileSet = function (_super) {
        var CurrentFormatVersion, OldestSupportedFormatVersion;
        __extends(TileSet, _super);
        OldestSupportedFormatVersion = 3;
        CurrentFormatVersion = 3;
        TileSet.BlockShape = {
            Cube: 0,
            Pane: 1,
            Stairs: 2,
            Slope: 3,
            InvertedSlope: 4,
            HorizontalSlab: 5,
            VerticalSlab: 6,
            Post: 7,
            InvertedStairs: 8,
            StairsCorner: 9,
            SlopeCorner: 10,
            PaneCorner: 11,
            None: CSPlayer.UInt8MaxValue
        };
        TileSet.QuadsPerShape = {};
        TileSet.QuadsPerShape[TileSet.BlockShape.Cube] = 6;
        TileSet.QuadsPerShape[TileSet.BlockShape.Pane] = 6;
        TileSet.QuadsPerShape[TileSet.BlockShape.PaneCorner] = 10;
        TileSet.QuadsPerShape[TileSet.BlockShape.Stairs] = 10;
        TileSet.QuadsPerShape[TileSet.BlockShape.InvertedStairs] = 10;
        TileSet.QuadsPerShape[TileSet.BlockShape.StairsCorner] = 12;
        TileSet.QuadsPerShape[TileSet.BlockShape.Slope] = 5;
        TileSet.QuadsPerShape[TileSet.BlockShape.InvertedSlope] = 5;
        TileSet.QuadsPerShape[TileSet.BlockShape.SlopeCorner] = 5;
        TileSet.QuadsPerShape[TileSet.BlockShape.HorizontalSlab] = 6;
        TileSet.QuadsPerShape[TileSet.BlockShape.VerticalSlab] = 6;
        TileSet.QuadsPerShape[TileSet.BlockShape.Post] = 6;

        function TileSet(id, tileSize) {
            this.tileSize = tileSize;
            TileSet.__super__.constructor.call(this, id, CSPlayer.AssetType.TileSet);
            this.blockTypes = []
        }
        TileSet.LoadFromUrl = function (id, url, callback) {
            return CSPlayer.DownloadUrl(url, "arraybuffer", function (_this) {
                return function (buffer) {
                    var reader;
                    reader = new CSPlayer.BinaryReader(buffer);
                    return _this.Deserialize(id, reader, callback)
                }
            }(this))
        };
        TileSet.Deserialize = function (id, reader, callback) {
            var assetType, formatVersion, i, img, s, textureData, textureDataLength, tileSet, _i, _ref;
            assetType = reader.ReadUInt8();
            if (assetType !== CSPlayer.AssetType.TileSet) {
                callback({
                    message: "Invalid asset type: " + assetType
                });
                return
            }
            formatVersion = reader.ReadUInt16();
            if (formatVersion < OldestSupportedFormatVersion || formatVersion > CurrentFormatVersion) {
                callback({
                    message: "Unsupported format version: " + formatVersion
                });
                return
            }
            tileSet = new CSPlayer.TileSet(id, reader.ReadUInt16());
            textureDataLength = reader.ReadInt32();
            textureData = reader.ReadBytes(textureDataLength);
            img = new Image;
            img.onload = function () {
                var blockTypeIndex, i, quadCount, shape, unwrapMode, uvQuadOffsets, uvQuadTransforms, _i, _j, _k, _ref;
                tileSet.image = img;
                for (blockTypeIndex = _i = 0, _ref = CSPlayer.UInt8MaxValue; 0 <= _ref ? _i < _ref : _i > _ref; blockTypeIndex = 0 <= _ref ? ++_i : --_i) {
                    shape = reader.ReadUInt8();
                    unwrapMode = reader.ReadUInt8();
                    quadCount = CSPlayer.TileSet.QuadsPerShape[shape];
                    uvQuadOffsets = [];
                    for (i = _j = 0; 0 <= quadCount ? _j < quadCount : _j > quadCount; i = 0 <= quadCount ? ++_j : --_j) {
                        uvQuadOffsets.push(reader.ReadPoint())
                    }
                    uvQuadTransforms = [];
                    for (i = _k = 0; 0 <= quadCount ? _k < quadCount : _k > quadCount; i = 0 <= quadCount ? ++_k : --_k) {
                        uvQuadTransforms.push(reader.ReadUInt8())
                    }
                    tileSet.blockTypes.push(new CSPlayer.BlockType(shape, unwrapMode, uvQuadOffsets, uvQuadTransforms))
                }
                return callback(null, tileSet)
            };
            s = "";
            for (i = _i = 0, _ref = textureData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                s += String.fromCharCode(textureData[i])
            }
            return img.src = "data:image/png;base64," + btoa(s)
        };
        return TileSet
    }(CSPlayer.Asset);
    CSPlayer.BlockType = function () {
        function BlockType(shape, unwrapMode, uvQuadOffsets, uvQuadTransforms) {
            this.shape = shape;
            this.unwrapMode = unwrapMode;
            this.uvQuadOffsets = uvQuadOffsets;
            this.uvQuadTransforms = uvQuadTransforms
        }
        return BlockType
    }()
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Scene = function (_super) {
        var CurrentFormatVersion, OldestSupportedFormatVersion;
        __extends(Scene, _super);
        OldestSupportedFormatVersion = 11;
        CurrentFormatVersion = 12;

        function Scene(id) {
            Scene.__super__.constructor.call(this, id, CSPlayer.AssetType.Scene);
            this.nodeTree = null
        }
        Scene.LoadFromUrl = function (id, url, callback) {
            return CSPlayer.DownloadUrl(url, "arraybuffer", function (_this) {
                return function (buffer) {
                    var reader;
                    reader = new CSPlayer.BinaryReader(buffer);
                    return _this.Deserialize(id, reader, callback)
                }
            }(this))
        };
        Scene.Deserialize = function (id, reader, callback) {
            var assetType, e, formatVersion, i, node, nodeCount, scene, _i;
            assetType = reader.ReadUInt8();
            if (assetType !== CSPlayer.AssetType.Scene) {
                callback({
                    message: "Invalid asset type: " + assetType
                });
                return
            }
            formatVersion = reader.ReadUInt16();
            if (formatVersion < OldestSupportedFormatVersion || formatVersion > CurrentFormatVersion) {
                callback({
                    message: "Unsupported format version: " + formatVersion
                });
                return
            }
            scene = new CSPlayer.Scene(id);
            scene.nodeTree = new CSPlayer.NodeTree(reader.ReadUInt16());
            nodeCount = reader.ReadUInt16();
            for (i = _i = 0; 0 <= nodeCount ? _i < nodeCount : _i > nodeCount; i = 0 <= nodeCount ? ++_i : --_i) {
                try {
                    node = CSPlayer.SceneNode.Deserialize(scene.nodeTree, reader, formatVersion)
                } catch (_error) {
                    e = _error;
                    callback({
                        message: "Could not deserialize scene node"
                    });
                    return
                }
                scene.nodeTree.AddNode(node)
            }
            return callback(null, scene)
        };
        return Scene
    }(CSPlayer.Asset);
    CSPlayer.SceneNode = function (_super) {
        __extends(SceneNode, _super);

        function SceneNode(nodeTree, nodeId, parentNodeId, name) {
            SceneNode.__super__.constructor.call(this, nodeTree, nodeId, parentNodeId, name);
            this.components = [];
            this.componentsById = {};
            this.nextComponentId = 0
        }
        SceneNode.Deserialize = function (nodeTree, reader, formatVersion) {
            var component, componentCount, index, node, _i;
            node = new CSPlayer.SceneNode(nodeTree, reader.ReadUInt16(), reader.ReadUInt16(), reader.ReadString());
            node.nextComponentId = reader.ReadUInt16();
            componentCount = reader.ReadUInt8();
            for (index = _i = 0; 0 <= componentCount ? _i < componentCount : _i > componentCount; index = 0 <= componentCount ? ++_i : --_i) {
                component = CSPlayer.Components.Component.Deserialize(reader, formatVersion);
                node.components.push(component);
                node.componentsById[component.componentId] = component;
                if (component instanceof CSPlayer.Components.Transform) {
                    node.transform = component
                }
            }
            return node
        };
        return SceneNode
    }(CSPlayer.Node)
}).call(this);
(function () {
    var ScriptNodeHoleCameraProjectionMode, ScriptNodeHoleMapBlockOrientation, ScriptNodeHolePhysicsBodyType, ScriptNodeHolePluggable, ScriptNodeHoleQuaternion, ScriptNodeHoleSimpleValue, ScriptNodeHoleStringValue, ScriptNodeHoleVector3, ScriptNodeTypeInfo, __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    ScriptNodeTypeInfo = function () {
        function ScriptNodeTypeInfo(canBeUsedAsStatement, canBeUsedAsPeice, holeTypes) {
            this.canBeUsedAsStatement = canBeUsedAsStatement;
            this.canBeUsedAsPeice = canBeUsedAsPeice;
            this.holeTypes = holeTypes
        }
        return ScriptNodeTypeInfo
    }();
    CSPlayer.ScriptNode = function () {
        function ScriptNode(nodeId) {
            this.nodeId = nodeId
        }
        ScriptNode.Deserialize = function (reader, formatVersion) {
            var node;
            node = new CSPlayer.ScriptNode(reader.ReadUInt32());
            node.upNodeId = reader.ReadUInt32();
            node.downNodeId = reader.ReadUInt32();
            node.childNodeId = reader.ReadUInt32();
            node.upNodeHoleIndex = reader.ReadUInt8();
            node.position = reader.ReadPoint();
            node.data = CSPlayer.ScriptNodeData.Deserialize(reader, formatVersion);
            return node
        };
        ScriptNode.prototype.SerializeToLua = function (script, indentationLevel, scriptAPIVersion) {
            var Delta, InterpolationType, IsMax, PairFunction, Squared, Unlock, alignment, amount, amountValue, angle, animationValue, axis, bImpulse, bOriented, bRotation, blockID, blockNameValue, blockOrientation, bodyType, booleanHoleValue, booleanValue, cameraComponentValue, compareType, content, degreesOrRadians, destroyableValue, dictionaryValue, direction, distance, downNode, end, endNumberValue, eulerAnglesValue, expressionHoleValue, firstVectorValue, fontValue, fovValue, frictionValue, fullInfo, functionName, functionType, gameObjectHoleValue, gravity, hValue, height, idValue, indentation, indexVariableName, keyOrIndexVariableName, leftNodeHoleValue, leftNumberValue, local, lowerBoundValue, lowerNumberValue, mapRendererValue, mapValue, mass, messageName, modelRendererValue, modelValue, name, nameValue, newParentHoleValue, nodeHoleValue, nodeTypeInfo, normal, numberValue, offset, offsetHoleValue, opType, opacityValue, orientationValue, parameters, parentGameObjectValue, physicsValue, position, positionValue, projectionMode, projectionModeValue, quat1, quat2, quaternionHoleValue, quaternionValue, radius, ray, rendererValue, resizable, rightNodeHoleValue, rightNumberValue, scaleValue, secondVectorValue, sizeValue, sizeX, sizeY, soundInstanceValue, soundValue, startNumberValue, strFunctionName, targetType, targetValue, text, textRendererValue, tileSetValue, timeValue, trigoType, type, upperBoundValue, upperNumberValue, useIndices, valueVariableName, vector, vectorHoleValue, vectorValue, velocityValue, visibleValue, volume, wValue, xNodeHoleValue, xValue, xyzNodeHoleValue, yNodeHoleValue, yValue, zNodeHoleValue, zValue;
            content = "";
            indentation = new Array(indentationLevel + 1).join("    ");
            nodeTypeInfo = CSPlayer.ScriptNodeData.NodeTypeInfos[this.data.nodeType];
            if (!nodeTypeInfo.canBeUsedAsPiece && nodeTypeInfo.canBeUsedAsStatement) {
                content = indentation
            }
            switch (this.data.nodeType) {
            case "Event":
                functionName = this.data.holeValues[0];
                switch (functionName) {
                case "Message":
                    functionName = this.data.holeValues[1];
                    parameters = " data ";
                    break;
                default:
                    parameters = ""
                }
                content += "function Behavior:" + functionName + "(" + parameters + ")\n";
                if (this.childNodeId !== CSPlayer.UInt32MaxValue) {
                    content += script.nodesById[this.childNodeId].SerializeToLua(script, indentationLevel + 1, scriptAPIVersion) + "\n"
                }
                content += indentation + "end\n\n";
                break;
            case "If":
                content += "if ";
                booleanHoleValue = this.data.holeValues[0];
                content += booleanHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " then\n";
                if (this.childNodeId !== CSPlayer.UInt32MaxValue) {
                    content += script.nodesById[this.childNodeId].SerializeToLua(script, indentationLevel + 1, scriptAPIVersion) + "\n"
                }
                end = true;
                if (this.downNodeId !== CSPlayer.UInt32MaxValue) {
                    downNode = script.nodesById[this.downNodeId];
                    switch (downNode.data.nodeType) {
                    case "Else":
                    case "ElseIf":
                        end = false
                    }
                }
                if (end) {
                    content += indentation + "end"
                }
                break;
            case "Else":
                content += "else\n";
                if (this.childNodeId !== CSPlayer.UInt32MaxValue) {
                    content += script.nodesById[this.childNodeId].SerializeToLua(script, indentationLevel + 1, scriptAPIVersion) + "\n"
                }
                content += indentation + "end";
                break;
            case "ElseIf":
                content += "elseif ";
                booleanHoleValue = this.data.holeValues[0];
                content += booleanHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " then\n";
                if (this.childNodeId !== CSPlayer.UInt32MaxValue) {
                    content += script.nodesById[this.childNodeId].SerializeToLua(script, indentationLevel + 1, scriptAPIVersion) + "\n"
                }
                end = true;
                if (this.downNodeId !== CSPlayer.UInt32MaxValue) {
                    downNode = script.nodesById[this.downNodeId];
                    switch (downNode.data.nodeType) {
                    case "Else":
                    case "ElseIf":
                        end = false
                    }
                }
                if (end) {
                    content += indentation + "end"
                }
                break;
            case "While":
                content += "while ";
                booleanHoleValue = this.data.holeValues[0];
                content += booleanHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " do\n";
                if (this.childNodeId !== CSPlayer.UInt32MaxValue) {
                    content += script.nodesById[this.childNodeId].SerializeToLua(script, indentationLevel + 1, scriptAPIVersion) + "\n"
                }
                content += indentation + "end";
                break;
            case "For":
                indexVariableName = this.data.holeValues[0];
                startNumberValue = this.data.holeValues[1];
                endNumberValue = this.data.holeValues[2];
                content += "for " + indexVariableName + " = " + startNumberValue.SerializeToLua(script, scriptAPIVersion) + ", " + endNumberValue.SerializeToLua(script, scriptAPIVersion) + " do\n";
                if (this.childNodeId !== CSPlayer.UInt32MaxValue) {
                    content += script.nodesById[this.childNodeId].SerializeToLua(script, indentationLevel + 1, scriptAPIVersion) + "\n"
                }
                content += indentation + "end";
                break;
            case "ForEach":
                useIndices = this.data.holeValues[0];
                keyOrIndexVariableName = this.data.holeValues[1];
                valueVariableName = this.data.holeValues[2];
                dictionaryValue = this.data.holeValues[3];
                PairFunction = useIndices ? "ipairs" : "pairs";
                content += "for " + keyOrIndexVariableName + ", " + valueVariableName + " in " + PairFunction + "( " + dictionaryValue.SerializeToLua(script, scriptAPIVersion) + " ) do\n";
                if (this.childNodeId !== CSPlayer.UInt32MaxValue) {
                    content += script.nodesById[this.childNodeId].SerializeToLua(script, indentationLevel + 1, scriptAPIVersion) + "\n"
                }
                content += indentation + "end";
                break;
            case "Comment":
                content += "-- " + this.data.holeValues[0] + "\n";
                if (this.childNodeId !== CSPlayer.UInt32MaxValue) {
                    content += indentation + "do\n" + script.nodesById[this.childNodeId].SerializeToLua(script, indentationLevel + 1, scriptAPIVersion) + "\n" + indentation + "end\n"
                }
                break;
            case "BooleanNot":
                nodeHoleValue = this.data.holeValues[0];
                content += "( not ";
                content += nodeHoleValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "BooleanOp":
                opType = this.data.holeValues[0];
                leftNodeHoleValue = this.data.holeValues[1];
                rightNodeHoleValue = this.data.holeValues[2];
                content += "( " + leftNodeHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " " + opType + " ";
                content += rightNodeHoleValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "DefineLocalVariable":
                content += "local " + this.data.holeValues[0];
                expressionHoleValue = this.data.holeValues[1];
                if (expressionHoleValue.NodeId !== CSPlayer.UInt32MaxValue) {
                    content += " = ";
                    content += expressionHoleValue.SerializeToLua(script, scriptAPIVersion)
                }
                break;
            case "SetValue":
                content += this.data.holeValues[0];
                content += " = ";
                expressionHoleValue = this.data.holeValues[1];
                content += expressionHoleValue.NodeId !== CSPlayer.UInt32MaxValue ? expressionHoleValue.SerializeToLua(script, scriptAPIVersion) : "nil";
                break;
            case "GetValue":
                content += this.data.holeValues[0];
                break;
            case "SelfGameObject":
                content += "self.gameObject";
                break;
            case "StringValue":
                content += CSPlayer.ScriptNodeData.ToLuaString(this.data.holeValues[0]);
                break;
            case "NumberValue":
                content += "" + this.data.holeValues[0];
                break;
            case "BooleanValue":
                content += this.data.holeValues[0] ? "true" : "false";
                break;
            case "NilValue":
                content += "nil";
                break;
            case "BigFourOp":
                opType = this.data.holeValues[0];
                leftNodeHoleValue = this.data.holeValues[1];
                rightNodeHoleValue = this.data.holeValues[2];
                content += "( " + leftNodeHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " " + opType + " ";
                content += rightNodeHoleValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "Concatenate":
                leftNodeHoleValue = this.data.holeValues[0];
                rightNodeHoleValue = this.data.holeValues[1];
                content += "( " + leftNodeHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " .. ";
                content += rightNodeHoleValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "Compare":
                compareType = this.data.holeValues[0];
                leftNodeHoleValue = this.data.holeValues[1];
                rightNodeHoleValue = this.data.holeValues[2];
                content += "( " + leftNodeHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " " + compareType + " ";
                content += rightNodeHoleValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "MathAbs":
                numberValue = this.data.holeValues[0];
                content += "math.abs( " + numberValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "MathRoundFloorCeil":
                functionType = this.data.holeValues[0];
                numberValue = this.data.holeValues[1];
                content += "math." + functionType + "( " + numberValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "MathMinMax":
                IsMax = this.data.holeValues[0];
                leftNumberValue = this.data.holeValues[1];
                rightNumberValue = this.data.holeValues[2];
                content += (IsMax ? "math.max( " : "math.min( ") + leftNumberValue.SerializeToLua(script, scriptAPIVersion) + ", " + rightNumberValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "MathClamp":
                numberValue = this.data.holeValues[0];
                lowerBoundValue = this.data.holeValues[1];
                upperBoundValue = this.data.holeValues[2];
                content += "math.clamp( " + numberValue.SerializeToLua(script, scriptAPIVersion) + ", " + lowerBoundValue.SerializeToLua(script, scriptAPIVersion) + ", " + upperBoundValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "MathRandomFloat":
                lowerNumberValue = this.data.holeValues[0];
                upperNumberValue = this.data.holeValues[1];
                content += "math.randomrange( ";
                content += lowerNumberValue.SerializeToLua(script, scriptAPIVersion) + ", ";
                content += upperNumberValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "MathRandomInt":
                lowerNumberValue = this.data.holeValues[0];
                upperNumberValue = this.data.holeValues[1];
                content += "math.random( ";
                content += lowerNumberValue.SerializeToLua(script, scriptAPIVersion) + ", ";
                content += upperNumberValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "MathCosSinTan":
                trigoType = this.data.holeValues[0];
                numberValue = this.data.holeValues[1];
                content += "math." + trigoType + "( " + numberValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "MathAtan2":
                yValue = this.data.holeValues[0];
                xValue = this.data.holeValues[1];
                content += "math.atan2( " + yValue.SerializeToLua(script, scriptAPIVersion) + ", " + xValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "MathDegreesRadians":
                degreesOrRadians = this.data.holeValues[0];
                numberValue = this.data.holeValues[1];
                content += "math." + degreesOrRadians + "( " + numberValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "Vector3New":
                xNodeHoleValue = this.data.holeValues[0];
                yNodeHoleValue = this.data.holeValues[1];
                zNodeHoleValue = this.data.holeValues[2];
                content += "Vector3:New( " + xNodeHoleValue.SerializeToLua(script, scriptAPIVersion) + ", " + yNodeHoleValue.SerializeToLua(script, scriptAPIVersion) + ", " + zNodeHoleValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "Vector3NewSingle":
                xyzNodeHoleValue = this.data.holeValues[0];
                content += "Vector3:New( " + xyzNodeHoleValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "Vector3Length":
                vectorValue = this.data.holeValues[0];
                Squared = this.data.holeValues[1];
                content += vectorValue.SerializeToLua(script, scriptAPIVersion) + (Squared ? ":SqrLength()" : ":Length()");
                break;
            case "Vector3Distance":
                firstVectorValue = this.data.holeValues[0];
                secondVectorValue = this.data.holeValues[1];
                content += "Vector3.Distance( " + firstVectorValue.SerializeToLua(script, scriptAPIVersion) + ", " + secondVectorValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "Vector3Normalize":
                vectorValue = this.data.holeValues[0];
                content += vectorValue.SerializeToLua(script, scriptAPIVersion) + ":Normalize()";
                break;
            case "Vector3Normalized":
                vectorValue = this.data.holeValues[0];
                content += vectorValue.SerializeToLua(script, scriptAPIVersion) + ":Normalized()";
                break;
            case "Vector3Interpolation":
                firstVectorValue = this.data.holeValues[0];
                secondVectorValue = this.data.holeValues[1];
                amountValue = this.data.holeValues[2];
                InterpolationType = this.data.holeValues[3];
                content += "Vector3." + InterpolationType + "( " + firstVectorValue.SerializeToLua(script, scriptAPIVersion) + ", " + secondVectorValue.SerializeToLua(script, scriptAPIVersion) + "," + amountValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "Vector3Cross":
                firstVectorValue = this.data.holeValues[0];
                secondVectorValue = this.data.holeValues[1];
                content += "Vector3.Cross( " + firstVectorValue.SerializeToLua(script, scriptAPIVersion) + ", " + secondVectorValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "Vector3Dot":
                firstVectorValue = this.data.holeValues[0];
                secondVectorValue = this.data.holeValues[1];
                content += "Vector3.Dot( " + firstVectorValue.SerializeToLua(script, scriptAPIVersion) + ", " + secondVectorValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "Vector3Angle":
                firstVectorValue = this.data.holeValues[0];
                secondVectorValue = this.data.holeValues[1];
                content += "Vector3.Angle( " + firstVectorValue.SerializeToLua(script, scriptAPIVersion) + ", " + secondVectorValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "Vector3Transform":
                vectorValue = this.data.holeValues[0];
                quaternionValue = this.data.holeValues[1];
                content += "Vector3.Rotate( " + vectorValue.SerializeToLua(script, scriptAPIVersion) + ", " + quaternionValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "RayNew":
                position = this.data.holeValues[0];
                direction = this.data.holeValues[1];
                content += "Ray:New( " + position.SerializeToLua(script, scriptAPIVersion) + ", " + direction.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "RayIntersects":
                ray = this.data.holeValues[0];
                fullInfo = this.data.holeValues[1];
                targetType = this.data.holeValues[2];
                targetValue = this.data.holeValues[3];
                if (fullInfo) {
                    content += ray.SerializeToLua(script, scriptAPIVersion) + ":Get" + targetType + "HitInfo( " + targetValue.SerializeToLua(script, scriptAPIVersion) + " )"
                } else {
                    content += ray.SerializeToLua(script, scriptAPIVersion) + ":Intersects" + targetType + "( " + targetValue.SerializeToLua(script, scriptAPIVersion) + " )"
                }
                break;
            case "PlaneNew":
                normal = this.data.holeValues[0];
                distance = this.data.holeValues[1];
                content += "Plane:New( " + normal.SerializeToLua(script, scriptAPIVersion) + ", " + distance.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "QuaternionFromAxisAngle":
                axis = this.data.holeValues[0];
                angle = this.data.holeValues[1];
                content += "Quaternion:FromAxisAngle( " + axis.SerializeToLua(script, scriptAPIVersion) + ", " + angle.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "QuaternionSlerp":
                quat1 = this.data.holeValues[0];
                quat2 = this.data.holeValues[1];
                amount = this.data.holeValues[2];
                content += "Quaternion.Slerp( " + quat1.SerializeToLua(script, scriptAPIVersion) + ", " + quat2.SerializeToLua(script, scriptAPIVersion) + ", " + amount.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "Print":
                content += "print( ";
                content += this.data.holeValues[0].SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "FindAsset":
                content += "CS.FindAsset( ";
                content += this.data.holeValues[0].SerializeToLua(script, scriptAPIVersion);
                content += ", ";
                content += this.data.holeValues[1].SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "LoadScene":
                content += "CS.LoadScene( ";
                content += this.data.holeValues[0].SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "AppendScene":
                content += "CS.AppendScene( ";
                content += this.data.holeValues[0].SerializeToLua(script, scriptAPIVersion);
                content += ", ";
                content += this.data.holeValues[1].SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "Instantiate":
                content += "CS.Instantiate( ";
                content += this.data.holeValues[0].SerializeToLua(script, scriptAPIVersion);
                content += ", ";
                content += this.data.holeValues[1].SerializeToLua(script, scriptAPIVersion);
                content += ", ";
                content += this.data.holeValues[2].SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "FindGameObject":
                nameValue = this.data.holeValues[0];
                content += "CS.FindGameObject( ";
                content += nameValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "CreateGameObject":
                nameValue = this.data.holeValues[0];
                parentGameObjectValue = this.data.holeValues[1];
                content += "CS.CreateGameObject( ";
                content += nameValue.SerializeToLua(script, scriptAPIVersion);
                if (parentGameObjectValue.NodeId !== CSPlayer.UInt32MaxValue) {
                    content += ", " + parentGameObjectValue.SerializeToLua(script, scriptAPIVersion)
                }
                content += " )";
                break;
            case "Destroy":
                destroyableValue = this.data.holeValues[0];
                content += "CS.Destroy( " + destroyableValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "Exit":
                content += "CS.Exit()";
                break;
            case "InputGetAxisValue":
                content += "CS.Input.GetAxisValue( ";
                content += this.data.holeValues[0].SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "InputIsButtonDown":
                content += "CS.Input.IsButtonDown( ";
                content += this.data.holeValues[0].SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "InputWasButtonJustPressed":
                content += "CS.Input.WasButtonJustPressed( ";
                content += this.data.holeValues[0].SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "InputWasButtonJustReleased":
                content += "CS.Input.WasButtonJustReleased( ";
                content += this.data.holeValues[0].SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "InputSetMouseVisible":
                visibleValue = this.data.holeValues[0];
                content += "CS.Input.SetMouseVisible( " + visibleValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "InputLockOrUnlockMouse":
                Unlock = this.data.holeValues[0];
                content += "CS.Input." + (Unlock ? "UnlockMouse()" : "LockMouse()");
                break;
            case "InputGetMousePositionOrDelta":
                Delta = this.data.holeValues[0];
                content += "CS.Input.GetMouse" + (Delta ? "Delta()" : "Position()");
                break;
            case "ScreenGetSize":
                content += "CS.Screen.GetSize()";
                break;
            case "ScreenSetSize":
                sizeX = this.data.holeValues[0];
                sizeY = this.data.holeValues[1];
                content += "CS.Screen.SetSize( " + sizeX.SerializeToLua(script, scriptAPIVersion) + ", " + sizeY.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "ScreenSetResizable":
                resizable = this.data.holeValues[0];
                content += "CS.Screen.SetResizable( " + resizable.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "AudioSetMasterVolume":
                volume = this.data.holeValues[0];
                content += "CS.Audio.SetMasterVolume( " + volume.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsSetGravity":
                gravity = this.data.holeValues[0];
                content += "CS.Physics.SetGravity( " + gravity.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "GameObjectGetName":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetName()";
                break;
            case "GameObjectSetName":
                gameObjectHoleValue = this.data.holeValues[0];
                name = this.data.holeValues[1];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetName( " + name.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "GameObjectGetParent":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetParent()";
                break;
            case "GameObjectSetParent":
                gameObjectHoleValue = this.data.holeValues[0];
                newParentHoleValue = this.data.holeValues[1];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetParent( " + newParentHoleValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "GameObjectFindChild":
                gameObjectHoleValue = this.data.holeValues[0];
                name = this.data.holeValues[1];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += ":FindChild( " + name.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "GameObjectGetChildren":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetChildren()";
                break;
            case "GameObjectGetComponent":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetComponent( ";
                content += this.data.holeValues[1].SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "GameObjectCreateComponent":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += ":CreateComponent( ";
                content += this.data.holeValues[1].SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "GameObjectGetScriptedBehavior":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion);
                if (scriptAPIVersion >= 4) {
                    content += ":GetScriptedBehavior( "
                } else {
                    content += ":GetScriptedBehaviorByScript( "
                }
                content += this.data.holeValues[1].SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "GameObjectCreateScriptedBehavior":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += ":CreateScriptedBehavior( ";
                content += this.data.holeValues[1].SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "GameObjectSendMessage":
                gameObjectHoleValue = this.data.holeValues[0];
                messageName = this.data.holeValues[1];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SendMessage( " + CSPlayer.ScriptNodeData.ToLuaString(messageName) + ", " + this.data.holeValues[2].SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "TransformSetPosition":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion) + ".transform";
                vectorHoleValue = this.data.holeValues[1];
                local = this.data.holeValues[2] ? "Local" : "";
                content += ":Set" + local + "Position( ";
                content += vectorHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "TransformSetOrientation":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion) + ".transform";
                quaternionHoleValue = this.data.holeValues[1];
                local = this.data.holeValues[2] ? "Local" : "";
                content += ":Set" + local + "Orientation( ";
                content += quaternionHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "TransformSetEulerAngles":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion) + ".transform";
                vectorHoleValue = this.data.holeValues[1];
                local = this.data.holeValues[2] ? "Local" : "";
                content += ":Set" + local + "EulerAngles( ";
                content += vectorHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "TransformSetLocalScale":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion) + ".transform";
                vectorHoleValue = this.data.holeValues[1];
                content += ":SetLocalScale( ";
                content += vectorHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "TransformGetPosition":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion) + ".transform";
                local = this.data.holeValues[1] ? "Local" : "";
                content += ":Get" + local + "Position()";
                break;
            case "TransformGetOrientation":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion) + ".transform";
                local = this.data.holeValues[1] ? "Local" : "";
                content += ":Get" + local + "Orientation()";
                break;
            case "TransformGetEulerAngles":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion) + ".transform";
                local = this.data.holeValues[1] ? "Local" : "";
                content += ":Get" + local + "EulerAngles()";
                break;
            case "TransformGetLocalScale":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion) + ".transform";
                content += ":GetLocalScale()";
                break;
            case "TransformMove":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion) + ".transform";
                type = this.data.holeValues[2];
                if (type === "Global") {
                    type = ""
                }
                content += ":Move" + type + "( ";
                offsetHoleValue = this.data.holeValues[1];
                content += offsetHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "TransformRotate":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion) + ".transform";
                local = this.data.holeValues[2] ? "Local" : "";
                content += ":Rotate" + local + "( ";
                quaternionHoleValue = this.data.holeValues[1];
                content += quaternionHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "TransformRotateEulerAngles":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion) + ".transform";
                local = this.data.holeValues[2] ? "Local" : "";
                content += ":RotateEulerAngles" + local + "( ";
                vectorHoleValue = this.data.holeValues[1];
                content += vectorHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "TransformLookAt":
                gameObjectHoleValue = this.data.holeValues[0];
                content += gameObjectHoleValue.SerializeToLua(script, scriptAPIVersion) + ".transform";
                content += ":LookAt( ";
                vectorHoleValue = this.data.holeValues[1];
                content += vectorHoleValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "CameraSetProjectionMode":
                cameraComponentValue = this.data.holeValues[0];
                projectionModeValue = this.data.holeValues[1];
                content += cameraComponentValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetProjectionMode( " + projectionModeValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "CameraProjectionMode":
                projectionMode = this.data.holeValues[0];
                content += "Camera.ProjectionMode." + Object.keys(CSPlayer.Map.BlockOrientation)[projectionMode];
                break;
            case "CameraSetFOV":
                cameraComponentValue = this.data.holeValues[0];
                fovValue = this.data.holeValues[1];
                content += cameraComponentValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetFOV( " + fovValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "CameraSetOrthographicScale":
                cameraComponentValue = this.data.holeValues[0];
                scaleValue = this.data.holeValues[1];
                content += cameraComponentValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetOrthographicScale( " + scaleValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "CameraSetRenderViewportPosition":
                cameraComponentValue = this.data.holeValues[0];
                xValue = this.data.holeValues[1];
                yValue = this.data.holeValues[2];
                content += cameraComponentValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetRenderViewportPosition( ";
                content += xValue.SerializeToLua(script, scriptAPIVersion) + ", " + yValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "CameraSetRenderViewportSize":
                cameraComponentValue = this.data.holeValues[0];
                wValue = this.data.holeValues[1];
                hValue = this.data.holeValues[2];
                content += cameraComponentValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetRenderViewportSize( ";
                content += wValue.SerializeToLua(script, scriptAPIVersion) + ", " + hValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "CameraCreateRay":
                cameraComponentValue = this.data.holeValues[0];
                positionValue = this.data.holeValues[1];
                content += cameraComponentValue.SerializeToLua(script, scriptAPIVersion);
                content += ":CreateRay( ";
                content += positionValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "CameraGetFOVOrthographicScale":
                cameraComponentValue = this.data.holeValues[0];
                functionName = this.data.holeValues[1];
                content += cameraComponentValue.SerializeToLua(script, scriptAPIVersion);
                content += ":Get" + functionName + "()";
                break;
            case "RendererSetOpacity":
                rendererValue = this.data.holeValues[0];
                opacityValue = this.data.holeValues[1];
                content += rendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetOpacity( ";
                content += opacityValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "RendererGetOpacity":
                rendererValue = this.data.holeValues[0];
                content += rendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetOpacity()";
                break;
            case "ModelRendererSetModel":
                modelRendererValue = this.data.holeValues[0];
                modelValue = this.data.holeValues[1];
                content += modelRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetModel( ";
                content += modelValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "ModelRendererGetModel":
                modelRendererValue = this.data.holeValues[0];
                content += modelRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetModel()";
                break;
            case "ModelRendererSetAnimation":
                modelRendererValue = this.data.holeValues[0];
                animationValue = this.data.holeValues[1];
                content += modelRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetAnimation( ";
                content += animationValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "ModelRendererGetAnimation":
                modelRendererValue = this.data.holeValues[0];
                content += modelRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetAnimation()";
                break;
            case "ModelRendererSetAnimationTime":
                modelRendererValue = this.data.holeValues[0];
                timeValue = this.data.holeValues[1];
                content += modelRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetAnimationTime( ";
                content += timeValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "ModelRendererStartAnimationPlayback":
                modelRendererValue = this.data.holeValues[0];
                booleanValue = this.data.holeValues[1];
                content += modelRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":StartAnimationPlayback( ";
                content += booleanValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "ModelRendererStopAnimationPlayback":
                modelRendererValue = this.data.holeValues[0];
                content += modelRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":StopAnimationPlayback()";
                break;
            case "ModelRendererIsAnimationPlaying":
                modelRendererValue = this.data.holeValues[0];
                content += modelRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":IsAnimationPlaying()";
                break;
            case "ModelRendererGetBlockTransform":
                modelRendererValue = this.data.holeValues[0];
                blockNameValue = this.data.holeValues[1];
                content += modelRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetBlockTransform( ";
                content += blockNameValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "MapRendererSetMap":
                mapRendererValue = this.data.holeValues[0];
                mapValue = this.data.holeValues[1];
                content += mapRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetMap( ";
                content += mapValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "MapRendererGetMap":
                mapRendererValue = this.data.holeValues[0];
                content += mapRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetMap()";
                break;
            case "MapRendererSetTileSet":
                mapRendererValue = this.data.holeValues[0];
                tileSetValue = this.data.holeValues[1];
                content += mapRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetTileSet( ";
                content += tileSetValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "MapRendererGetTileSet":
                mapRendererValue = this.data.holeValues[0];
                content += mapRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetTileSet()";
                break;
            case "TextRendererSetFont":
                textRendererValue = this.data.holeValues[0];
                fontValue = this.data.holeValues[1];
                content += textRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetFont( " + fontValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "TextRendererGetFont":
                textRendererValue = this.data.holeValues[0];
                content += textRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetFont()";
                break;
            case "TextRendererSetText":
                textRendererValue = this.data.holeValues[0];
                text = this.data.holeValues[1];
                content += textRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetText( " + text.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "TextRendererGetText":
                textRendererValue = this.data.holeValues[0];
                content += textRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetText()";
                break;
            case "TextRendererSetAlignment":
                textRendererValue = this.data.holeValues[0];
                alignment = this.data.holeValues[1];
                content += textRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetAlignment( " + alignment.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "TextRendererGetAlignment":
                textRendererValue = this.data.holeValues[0];
                content += textRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetAlignment()";
                break;
            case "TextRendererGetTextWidth":
                textRendererValue = this.data.holeValues[0];
                text = this.data.holeValues[0];
                content += textRendererValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetTextWidth(";
                if (text.NodeId !== CSPlayer.UInt16MaxValue || text.RawValue !== "") {
                    content += " " + text.SerializeToLua(script, scriptAPIVersion) + " "
                }
                content += ")";
                break;
            case "PhysicsSetBodyType":
                physicsValue = this.data.holeValues[0];
                bodyType = this.data.holeValues[1];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetBodyType( " + bodyType.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsBodyType":
                bodyType = this.data.holeValues[0];
                content += "Physics.BodyType." + bodyType;
                break;
            case "PhysicsSetMass":
                physicsValue = this.data.holeValues[0];
                mass = this.data.holeValues[1];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetMass( " + mass.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsSetFreezePositionOrRotation":
                physicsValue = this.data.holeValues[0];
                bRotation = this.data.holeValues[1];
                xValue = this.data.holeValues[2];
                yValue = this.data.holeValues[3];
                zValue = this.data.holeValues[4];
                strFunctionName = bRotation ? "SetFreezeRotation" : "SetFreezePosition";
                content += physicsValue.SerializeToLua(script, scriptAPIVersion);
                content += ":" + strFunctionName + "( " + xValue.SerializeToLua(script, scriptAPIVersion) + ", " + yValue.SerializeToLua(script, scriptAPIVersion) + ", " + zValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsSetupAsBox":
                physicsValue = this.data.holeValues[0];
                sizeValue = this.data.holeValues[1];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetupAsBox( " + sizeValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsSetupAsSphere":
                physicsValue = this.data.holeValues[0];
                radius = this.data.holeValues[1];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetupAsSphere( " + radius.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsSetupAsCapsule":
                physicsValue = this.data.holeValues[0];
                radius = this.data.holeValues[1];
                height = this.data.holeValues[2];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetupAsCapsule( " + radius.SerializeToLua(script, scriptAPIVersion) + ", " + height.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsSetupAsMap":
                physicsValue = this.data.holeValues[0];
                mapValue = this.data.holeValues[1];
                tileSetValue = this.data.holeValues[2];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetupAsMap( " + mapValue.SerializeToLua(script, scriptAPIVersion);
                content += ", " + tileSetValue.SerializeToLua(script, scriptAPIVersion);
                content += " )";
                break;
            case "PhysicsWarpPosition":
                physicsValue = this.data.holeValues[0];
                position = this.data.holeValues[1];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion) + ":WarpPosition( " + position.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsOffsetPosition":
                physicsValue = this.data.holeValues[0];
                bOriented = this.data.holeValues[1];
                offset = this.data.holeValues[2];
                string(strFunctionName = bOriented ? "OffsetPositionOriented" : "OffsetPosition");
                content += physicsValue.SerializeToLua(script, scriptAPIVersion) + ":" + strFunctionName + "( " + offset.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsWarpEulerAngles":
                physicsValue = this.data.holeValues[0];
                eulerAnglesValue = this.data.holeValues[1];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion);
                content += ":WarpEulerAngles( " + eulerAnglesValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsWarpOrientation":
                physicsValue = this.data.holeValues[0];
                orientationValue = this.data.holeValues[1];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion);
                content += ":WarpOrientation( " + orientationValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsOffsetEulerAngles":
                physicsValue = this.data.holeValues[0];
                eulerAnglesValue = this.data.holeValues[1];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion);
                content += ":OffsetEulerAngles( " + eulerAnglesValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsOffsetOrientation":
                physicsValue = this.data.holeValues[0];
                orientationValue = this.data.holeValues[1];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion);
                content += ":OffsetOrientation( " + orientationValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsGetLinearVelocity":
                physicsValue = this.data.holeValues[0];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion) + ":GetLinearVelocity()";
                break;
            case "PhysicsSetLinearVelocity":
                physicsValue = this.data.holeValues[0];
                velocityValue = this.data.holeValues[1];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion) + ":SetLinearVelocity( " + velocityValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsGetAngularVelocity":
                physicsValue = this.data.holeValues[0];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion) + ":GetAngularVelocity()";
                break;
            case "PhysicsSetAngularVelocity":
                physicsValue = this.data.holeValues[0];
                velocityValue = this.data.holeValues[1];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion) + ":SetAngularVelocity( " + velocityValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsApplyForceOrImpulse":
                physicsValue = this.data.holeValues[0];
                bImpulse = this.data.holeValues[1];
                vector = this.data.holeValues[2];
                functionName = bImpulse ? ":ApplyImpulse( " : ":ApplyForce( ";
                content += physicsValue.SerializeToLua(script, scriptAPIVersion) + functionName + vector.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsApplyTorqueOrAngularImpulse":
                physicsValue = this.data.holeValues[0];
                bImpulse = this.data.holeValues[1];
                vector = this.data.holeValues[2];
                functionName = bImpulse ? ":ApplyAngularImpulse( " : ":ApplyTorque( ";
                content += physicsValue.SerializeToLua(script, scriptAPIVersion) + functionName + vector.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsGetFriction":
                physicsValue = this.data.holeValues[0];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion) + ":GetFriction()";
                break;
            case "PhysicsSetFriction":
                physicsValue = this.data.holeValues[0];
                frictionValue = this.data.holeValues[1];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion) + ":SetFriction( " + frictionValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "PhysicsGetAnisotropicFriction":
                physicsValue = this.data.holeValues[0];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion) + ":GetAnisotropicFriction()";
                break;
            case "PhysicsSetAnisotropicFriction":
                physicsValue = this.data.holeValues[0];
                frictionValue = this.data.holeValues[1];
                content += physicsValue.SerializeToLua(script, scriptAPIVersion) + ":SetAnisotropicFriction( " + frictionValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "MapGetBlockIDAt":
                mapValue = this.data.holeValues[0];
                xValue = this.data.holeValues[1];
                yValue = this.data.holeValues[2];
                zValue = this.data.holeValues[3];
                content += mapValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetBlockIDAt( " + xValue.SerializeToLua(script, scriptAPIVersion) + ", " + yValue.SerializeToLua(script, scriptAPIVersion) + "," + zValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "MapGetBlockOrientationAt":
                mapValue = this.data.holeValues[0];
                xValue = this.data.holeValues[1];
                yValue = this.data.holeValues[2];
                zValue = this.data.holeValues[3];
                content += mapValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetBlockOrientationAt( " + xValue.SerializeToLua(script, scriptAPIVersion) + ", " + yValue.SerializeToLua(script, scriptAPIVersion) + "," + zValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "MapSetBlockAt":
                mapValue = this.data.holeValues[0];
                xValue = this.data.holeValues[1];
                yValue = this.data.holeValues[2];
                zValue = this.data.holeValues[3];
                blockID = this.data.holeValues[4];
                blockOrientation = this.data.holeValues[5];
                content += mapValue.SerializeToLua(script, scriptAPIVersion);
                content += ":SetBlockAt( " + xValue.SerializeToLua(script, scriptAPIVersion) + ", " + yValue.SerializeToLua(script, scriptAPIVersion) + "," + zValue.SerializeToLua(script, scriptAPIVersion) + "," + blockID.SerializeToLua(script, scriptAPIVersion) + "," + blockOrientation.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "MapBlockOrientation":
                blockOrientation = this.data.holeValues[0];
                content += "Map.BlockOrientation." + blockOrientation;
                break;
            case "TileSetGetBlockTypeShape":
                tileSetValue = this.data.holeValues[0];
                idValue = this.data.holeValues[1];
                content += tileSetValue.SerializeToLua(script, scriptAPIVersion);
                content += ":GetBlockTypeShape( " + idValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "SoundPlay":
                soundValue = this.data.holeValues[0];
                content += soundValue.SerializeToLua(script, scriptAPIVersion) + ":Play()";
                break;
            case "SoundCreateInstance":
                soundValue = this.data.holeValues[0];
                content += soundValue.SerializeToLua(script, scriptAPIVersion) + ":CreateInstance()";
                break;
            case "SoundInstancePlay":
                soundInstanceValue = this.data.holeValues[0];
                content += soundInstanceValue.SerializeToLua(script, scriptAPIVersion) + ":Play()";
                break;
            case "SoundInstanceStop":
                soundInstanceValue = this.data.holeValues[0];
                content += soundInstanceValue.SerializeToLua(script, scriptAPIVersion) + ":Stop()";
                break;
            case "SoundInstancePause":
                soundInstanceValue = this.data.holeValues[0];
                content += soundInstanceValue.SerializeToLua(script, scriptAPIVersion) + ":Pause()";
                break;
            case "SoundInstanceResume":
                soundInstanceValue = this.data.holeValues[0];
                content += soundInstanceValue.SerializeToLua(script, scriptAPIVersion) + ":Resume()";
                break;
            case "SoundInstanceGetState":
                soundInstanceValue = this.data.holeValues[0];
                content += soundInstanceValue.SerializeToLua(script, scriptAPIVersion) + ":GetState()";
                break;
            case "SoundInstanceSetLoop":
                soundInstanceValue = this.data.holeValues[0];
                booleanValue = this.data.holeValues[1];
                content += soundInstanceValue.SerializeToLua(script, scriptAPIVersion) + ":SetLoop( " + booleanValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "SoundInstanceGetLoop":
                soundInstanceValue = this.data.holeValues[0];
                content += soundInstanceValue.SerializeToLua(script, scriptAPIVersion) + ":GetLoop()";
                break;
            case "SoundInstanceSetVolume":
                soundInstanceValue = this.data.holeValues[0];
                numberValue = this.data.holeValues[1];
                content += soundInstanceValue.SerializeToLua(script, scriptAPIVersion) + ":SetVolume( " + numberValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "SoundInstanceGetVolume":
                soundInstanceValue = this.data.holeValues[0];
                content += soundInstanceValue.SerializeToLua(script, scriptAPIVersion) + ":GetVolume()";
                break;
            case "SoundInstanceSetPitch":
                soundInstanceValue = this.data.holeValues[0];
                numberValue = this.data.holeValues[1];
                content += soundInstanceValue.SerializeToLua(script, scriptAPIVersion) + ":SetPitch( " + numberValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "SoundInstanceGetPitch":
                soundInstanceValue = this.data.holeValues[0];
                content += soundInstanceValue.SerializeToLua(script, scriptAPIVersion) + ":GetPitch()";
                break;
            case "SoundInstanceSetPan":
                soundInstanceValue = this.data.holeValues[0];
                numberValue = this.data.holeValues[1];
                content += soundInstanceValue.SerializeToLua(script, scriptAPIVersion) + ":SetPan( " + numberValue.SerializeToLua(script, scriptAPIVersion) + " )";
                break;
            case "SoundInstanceGetPan":
                soundInstanceValue = this.data.holeValues[0];
                content += soundInstanceValue.SerializeToLua(script, scriptAPIVersion) + ":GetPan()"
            }
            if (this.downNodeId !== CSPlayer.UInt32MaxValue) {
                content += "\n" + script.nodesById[this.downNodeId].SerializeToLua(script, indentationLevel, scriptAPIVersion)
            }
            return content
        };
        return ScriptNode
    }();
    CSPlayer.ScriptNodeData = function () {
        ScriptNodeData.NodeTypeInfos = {
            Event: new ScriptNodeTypeInfo(false, false, ["EventType", "StringValue"]),
            If: new ScriptNodeTypeInfo(true, false, ["Boolean"]),
            Else: new ScriptNodeTypeInfo(true, false, []),
            ElseIf: new ScriptNodeTypeInfo(true, false, ["Boolean"]),
            While: new ScriptNodeTypeInfo(true, false, ["Boolean"]),
            For: new ScriptNodeTypeInfo(true, false, ["StringValue", "Number", "Number"]),
            ForEach: new ScriptNodeTypeInfo(true, false, ["BooleanValue", "StringValue", "StringValue", "Expression"]),
            Comment: new ScriptNodeTypeInfo(true, false, ["StringValue"]),
            BooleanNot: new ScriptNodeTypeInfo(false, true, ["Boolean"]),
            BooleanOp: new ScriptNodeTypeInfo(false, true, ["StringValue", "Boolean", "Boolean"]),
            Compare: new ScriptNodeTypeInfo(false, true, ["StringValue", "Expression", "Expression"]),
            DefineLocalVariable: new ScriptNodeTypeInfo(true, false, ["StringValue", "Expression"]),
            SetValue: new ScriptNodeTypeInfo(true, false, ["StringValue", "Expression"]),
            GetValue: new ScriptNodeTypeInfo(false, true, ["StringValue"]),
            SelfGameObject: new ScriptNodeTypeInfo(false, true, []),
            NumberValue: new ScriptNodeTypeInfo(false, true, ["NumberValue"]),
            StringValue: new ScriptNodeTypeInfo(false, true, ["StringValue"]),
            BooleanValue: new ScriptNodeTypeInfo(false, true, ["BooleanValue"]),
            NilValue: new ScriptNodeTypeInfo(false, true, []),
            BigFourOp: new ScriptNodeTypeInfo(false, true, ["StringValue", "Expression", "Expression"]),
            Concatenate: new ScriptNodeTypeInfo(false, true, ["Expression", "Expression"]),
            MathAbs: new ScriptNodeTypeInfo(false, true, ["Number"]),
            MathRoundFloorCeil: new ScriptNodeTypeInfo(false, true, ["StringValue", "Number"]),
            MathMinMax: new ScriptNodeTypeInfo(false, true, ["BooleanValue", "Number", "Number"]),
            MathClamp: new ScriptNodeTypeInfo(false, true, ["Number", "Number", "Number"]),
            MathRandomFloat: new ScriptNodeTypeInfo(false, true, ["Number", "Number"]),
            MathRandomInt: new ScriptNodeTypeInfo(false, true, ["Number", "Number"]),
            MathCosSinTan: new ScriptNodeTypeInfo(false, true, ["StringValue", "Number"]),
            MathAtan2: new ScriptNodeTypeInfo(false, true, ["Number", "Number"]),
            MathDegreesRadians: new ScriptNodeTypeInfo(false, true, ["StringValue", "Number"]),
            Vector3New: new ScriptNodeTypeInfo(false, true, ["Number", "Number", "Number"]),
            Vector3NewSingle: new ScriptNodeTypeInfo(false, true, ["Number"]),
            Vector3Length: new ScriptNodeTypeInfo(false, true, ["Vector3", "BooleanValue"]),
            Vector3Normalize: new ScriptNodeTypeInfo(true, false, ["Vector3"]),
            Vector3Normalized: new ScriptNodeTypeInfo(false, true, ["Vector3"]),
            Vector3Distance: new ScriptNodeTypeInfo(false, true, ["Vector3", "Vector3"]),
            Vector3Interpolation: new ScriptNodeTypeInfo(false, true, ["Vector3", "Vector3", "Number", "StringValue"]),
            Vector3Cross: new ScriptNodeTypeInfo(false, true, ["Vector3", "Vector3"]),
            Vector3Dot: new ScriptNodeTypeInfo(false, true, ["Vector3", "Vector3"]),
            Vector3Angle: new ScriptNodeTypeInfo(false, true, ["Vector3", "Vector3"]),
            Vector3Transform: new ScriptNodeTypeInfo(false, true, ["Vector3", "Quaternion"]),
            RayNew: new ScriptNodeTypeInfo(false, true, ["Vector3", "Vector3"]),
            RayIntersects: new ScriptNodeTypeInfo(false, true, ["Ray", "BooleanValue", "StringValue", "Expression"]),
            PlaneNew: new ScriptNodeTypeInfo(false, true, ["Vector3", "Number"]),
            QuaternionFromAxisAngle: new ScriptNodeTypeInfo(false, true, ["Vector3", "Number"]),
            QuaternionSlerp: new ScriptNodeTypeInfo(false, true, ["Quaternion", "Quaternion", "Number"]),
            FindAsset: new ScriptNodeTypeInfo(false, true, ["String", "String"]),
            LoadScene: new ScriptNodeTypeInfo(true, false, ["Scene"]),
            AppendScene: new ScriptNodeTypeInfo(true, false, ["Scene", "GameObject"]),
            Instantiate: new ScriptNodeTypeInfo(false, true, ["String", "Scene", "GameObject"]),
            FindGameObject: new ScriptNodeTypeInfo(false, true, ["String"]),
            CreateGameObject: new ScriptNodeTypeInfo(false, true, ["String", "GameObject"]),
            Destroy: new ScriptNodeTypeInfo(true, false, ["Expression"]),
            Exit: new ScriptNodeTypeInfo(true, false, []),
            Print: new ScriptNodeTypeInfo(true, false, ["Expression"]),
            InputGetAxisValue: new ScriptNodeTypeInfo(false, true, ["String"]),
            InputIsButtonDown: new ScriptNodeTypeInfo(false, true, ["String"]),
            InputWasButtonJustPressed: new ScriptNodeTypeInfo(false, true, ["String"]),
            InputWasButtonJustReleased: new ScriptNodeTypeInfo(false, true, ["String"]),
            InputSetMouseVisible: new ScriptNodeTypeInfo(true, false, ["Boolean"]),
            InputLockOrUnlockMouse: new ScriptNodeTypeInfo(true, false, ["BooleanValue"]),
            InputGetMousePositionOrDelta: new ScriptNodeTypeInfo(false, true, ["BooleanValue"]),
            ScreenSetSize: new ScriptNodeTypeInfo(true, false, ["Number", "Number"]),
            ScreenGetSize: new ScriptNodeTypeInfo(false, true, []),
            ScreenSetResizable: new ScriptNodeTypeInfo(true, false, ["Boolean"]),
            AudioSetMasterVolume: new ScriptNodeTypeInfo(true, false, ["Number"]),
            PhysicsSetGravity: new ScriptNodeTypeInfo(true, false, ["Vector3"]),
            GameObjectGetName: new ScriptNodeTypeInfo(false, true, ["GameObject"]),
            GameObjectSetName: new ScriptNodeTypeInfo(true, false, ["GameObject", "String"]),
            GameObjectGetParent: new ScriptNodeTypeInfo(false, true, ["GameObject"]),
            GameObjectSetParent: new ScriptNodeTypeInfo(true, false, ["GameObject", "GameObject"]),
            GameObjectGetChildren: new ScriptNodeTypeInfo(false, true, ["GameObject"]),
            GameObjectGetComponent: new ScriptNodeTypeInfo(false, true, ["GameObject", "String"]),
            GameObjectCreateComponent: new ScriptNodeTypeInfo(false, true, ["GameObject", "String"]),
            GameObjectGetScriptedBehavior: new ScriptNodeTypeInfo(false, true, ["GameObject", "Script"]),
            GameObjectCreateScriptedBehavior: new ScriptNodeTypeInfo(false, true, ["GameObject", "Script"]),
            GameObjectSendMessage: new ScriptNodeTypeInfo(true, false, ["GameObject", "StringValue", "Expression"]),
            TransformSetPosition: new ScriptNodeTypeInfo(true, false, ["GameObject", "Vector3", "BooleanValue"]),
            TransformSetOrientation: new ScriptNodeTypeInfo(true, false, ["GameObject", "Quaternion", "BooleanValue"]),
            TransformSetEulerAngles: new ScriptNodeTypeInfo(true, false, ["GameObject", "Vector3", "BooleanValue"]),
            TransformSetLocalScale: new ScriptNodeTypeInfo(true, false, ["GameObject", "Vector3"]),
            TransformGetPosition: new ScriptNodeTypeInfo(false, true, ["GameObject", "BooleanValue"]),
            TransformGetOrientation: new ScriptNodeTypeInfo(false, true, ["GameObject", "BooleanValue"]),
            TransformGetEulerAngles: new ScriptNodeTypeInfo(false, true, ["GameObject", "BooleanValue"]),
            TransformGetLocalScale: new ScriptNodeTypeInfo(false, true, ["GameObject"]),
            TransformMove: new ScriptNodeTypeInfo(true, false, ["GameObject", "Vector3", "StringValue"]),
            TransformRotate: new ScriptNodeTypeInfo(true, false, ["GameObject", "Quaternion", "BooleanValue"]),
            TransformRotateEulerAngles: new ScriptNodeTypeInfo(true, false, ["GameObject", "Vector3", "BooleanValue"]),
            TransformLookAt: new ScriptNodeTypeInfo(true, false, ["GameObject", "Vector3"]),
            CameraSetProjectionMode: new ScriptNodeTypeInfo(true, false, ["CameraComponent", "CameraProjectionMode"]),
            CameraProjectionMode: new ScriptNodeTypeInfo(false, true, ["StringValue"]),
            CameraSetFOV: new ScriptNodeTypeInfo(true, false, ["CameraComponent", "Number"]),
            CameraSetOrthographicScale: new ScriptNodeTypeInfo(true, false, ["CameraComponent", "Number"]),
            CameraSetRenderViewportPosition: new ScriptNodeTypeInfo(true, false, ["CameraComponent", "Number", "Number"]),
            CameraSetRenderViewportSize: new ScriptNodeTypeInfo(true, false, ["CameraComponent", "Number", "Number"]),
            CameraCreateRay: new ScriptNodeTypeInfo(false, true, ["CameraComponent", "Expression"]),
            RendererSetOpacity: new ScriptNodeTypeInfo(true, false, ["RendererComponent", "Number"]),
            RendererGetOpacity: new ScriptNodeTypeInfo(false, true, ["RendererComponent"]),
            ModelRendererSetModel: new ScriptNodeTypeInfo(true, false, ["ModelRendererComponent", "Model"]),
            ModelRendererGetModel: new ScriptNodeTypeInfo(false, true, ["ModelRendererComponent"]),
            ModelRendererSetAnimation: new ScriptNodeTypeInfo(true, false, ["ModelRendererComponent", "ModelAnimation"]),
            ModelRendererGetAnimation: new ScriptNodeTypeInfo(false, true, ["ModelRendererComponent"]),
            ModelRendererSetAnimationTime: new ScriptNodeTypeInfo(true, false, ["ModelRendererComponent", "Number"]),
            ModelRendererStartAnimationPlayback: new ScriptNodeTypeInfo(true, false, ["ModelRendererComponent", "Boolean"]),
            ModelRendererStopAnimationPlayback: new ScriptNodeTypeInfo(true, false, ["ModelRendererComponent"]),
            ModelRendererIsAnimationPlaying: new ScriptNodeTypeInfo(false, true, ["ModelRendererComponent"]),
            ModelRendererGetBlockTransform: new ScriptNodeTypeInfo(false, true, ["ModelRendererComponent", "String"]),
            MapRendererSetMap: new ScriptNodeTypeInfo(true, false, ["MapRendererComponent", "Map"]),
            MapRendererGetMap: new ScriptNodeTypeInfo(false, true, ["MapRendererComponent"]),
            MapRendererSetTileSet: new ScriptNodeTypeInfo(true, false, ["MapRendererComponent", "TileSet"]),
            MapRendererGetTileSet: new ScriptNodeTypeInfo(false, true, ["MapRendererComponent"]),
            TextRendererSetFont: new ScriptNodeTypeInfo(true, false, ["TextRendererComponent", "Font"]),
            TextRendererGetFont: new ScriptNodeTypeInfo(false, true, ["TextRendererComponent"]),
            TextRendererSetText: new ScriptNodeTypeInfo(true, false, ["TextRendererComponent", "String"]),
            TextRendererGetText: new ScriptNodeTypeInfo(false, true, ["TextRendererComponent"]),
            TextRendererSetAlignment: new ScriptNodeTypeInfo(true, false, ["TextRendererComponent", "TextAlignment"]),
            TextRendererGetAlignment: new ScriptNodeTypeInfo(false, true, ["TextRendererComponent"]),
            TextAlignment: new ScriptNodeTypeInfo(false, true, ["StringValue"]),
            TextRendererGetTextWidth: new ScriptNodeTypeInfo(false, true, ["TextRendererComponent", "String"]),
            PhysicsSetBodyType: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "PhysicsBodyType"]),
            PhysicsBodyType: new ScriptNodeTypeInfo(false, true, ["StringValue"]),
            PhysicsSetMass: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Number"]),
            PhysicsSetFreezePositionOrRotation: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "BooleanValue", "Boolean", "Boolean", "Boolean"]),
            PhysicsSetupAsBox: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Vector3"]),
            PhysicsSetupAsSphere: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Number"]),
            PhysicsSetupAsCapsule: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Number", "Number"]),
            PhysicsSetupAsMap: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Map", "TileSet"]),
            PhysicsWarpPosition: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Vector3"]),
            PhysicsOffsetPosition: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "BooleanValue", "Vector3"]),
            PhysicsWarpEulerAngles: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Vector3"]),
            PhysicsWarpOrientation: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Quaternion"]),
            PhysicsOffsetEulerAngles: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Vector3"]),
            PhysicsOffsetOrientation: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Quaternion"]),
            PhysicsGetLinearVelocity: new ScriptNodeTypeInfo(false, true, ["PhysicsComponent"]),
            PhysicsSetLinearVelocity: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Vector3"]),
            PhysicsGetAngularVelocity: new ScriptNodeTypeInfo(false, true, ["PhysicsComponent"]),
            PhysicsSetAngularVelocity: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Vector3"]),
            PhysicsApplyForceOrImpulse: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "BooleanValue", "Vector3"]),
            PhysicsApplyTorqueOrAngularImpulse: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "BooleanValue", "Vector3"]),
            PhysicsGetFriction: new ScriptNodeTypeInfo(false, true, ["PhysicsComponent"]),
            PhysicsSetFriction: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Number"]),
            PhysicsGetAnisotropicFriction: new ScriptNodeTypeInfo(false, true, ["PhysicsComponent"]),
            PhysicsSetAnisotropicFriction: new ScriptNodeTypeInfo(true, false, ["PhysicsComponent", "Vector3"]),
            MapGetBlockIDAt: new ScriptNodeTypeInfo(false, true, ["Map", "Number", "Number", "Number"]),
            MapGetBlockOrientationAt: new ScriptNodeTypeInfo(false, true, ["Map", "Number", "Number", "Number"]),
            MapSetBlockAt: new ScriptNodeTypeInfo(true, false, ["Map", "Number", "Number", "Number", "Number", "MapBlockOrientation"]),
            MapBlockOrientation: new ScriptNodeTypeInfo(false, true, ["MapBlockOrientationValue"]),
            TileSetGetBlockTypeShape: new ScriptNodeTypeInfo(false, true, ["TileSet", "Number"]),
            SoundPlay: new ScriptNodeTypeInfo(true, false, ["Sound"]),
            SoundCreateInstance: new ScriptNodeTypeInfo(false, true, ["Sound"]),
            SoundInstancePlay: new ScriptNodeTypeInfo(true, false, ["SoundInstance"]),
            SoundInstanceStop: new ScriptNodeTypeInfo(true, false, ["SoundInstance"]),
            SoundInstancePause: new ScriptNodeTypeInfo(true, false, ["SoundInstance"]),
            SoundInstanceResume: new ScriptNodeTypeInfo(true, false, ["SoundInstance"]),
            SoundInstanceGetState: new ScriptNodeTypeInfo(false, true, ["SoundInstance"]),
            SoundInstanceSetLoop: new ScriptNodeTypeInfo(true, false, ["SoundInstance", "Boolean"]),
            SoundInstanceGetLoop: new ScriptNodeTypeInfo(false, true, ["SoundInstance"]),
            SoundInstanceSetVolume: new ScriptNodeTypeInfo(true, false, ["SoundInstance", "Number"]),
            SoundInstanceGetVolume: new ScriptNodeTypeInfo(false, true, ["SoundInstance"]),
            SoundInstanceSetPitch: new ScriptNodeTypeInfo(true, false, ["SoundInstance", "Number"]),
            SoundInstanceGetPitch: new ScriptNodeTypeInfo(false, true, ["SoundInstance"]),
            SoundInstanceSetPan: new ScriptNodeTypeInfo(true, false, ["SoundInstance", "Number"]),
            SoundInstanceGetPan: new ScriptNodeTypeInfo(false, true, ["SoundInstance"])
        };

        function ScriptNodeData(nodeType, holeValues) {
            this.nodeType = nodeType;
            this.holeValues = holeValues
        }
        ScriptNodeData.Deserialize = function (reader, formatVersion) {
            var holeIndex, holeType, holeValue, nodeData, nodeType, _i, _len, _ref;
            nodeType = reader.ReadString();
            nodeData = new CSPlayer.ScriptNodeData(nodeType, []);
            holeIndex = 0;
            _ref = CSPlayer.ScriptNodeData.NodeTypeInfos[nodeType].holeTypes;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                holeType = _ref[_i];
                holeValue = this.DeserializeHoleValue(reader, holeType, formatVersion);
                nodeData.holeValues.push(holeValue)
            }
            return nodeData
        };
        ScriptNodeData.DeserializeHoleValue = function (reader, holeType, formatVersion) {
            var nodeId;
            if (this.HoleTypeAcceptsNodePiece(holeType)) {
                nodeId = reader.ReadUInt32();
                switch (holeType) {
                case "String":
                    return new ScriptNodeHoleStringValue(nodeId, reader.ReadString());
                case "Number":
                    return new ScriptNodeHoleSimpleValue(nodeId, reader.ReadFloat64());
                case "Boolean":
                    return new ScriptNodeHoleSimpleValue(nodeId, reader.ReadBoolean());
                case "Vector3":
                    return new ScriptNodeHoleVector3(nodeId, reader.ReadVector3());
                case "Quaternion":
                    return new ScriptNodeHoleQuaternion(nodeId, reader.ReadQuaternion());
                case "MapBlockOrientation":
                    return new ScriptNodeHoleMapBlockOrientation(nodeId, reader.ReadUInt8());
                case "CameraProjectionMode":
                    return new ScriptNodeHoleCameraProjectionMode(nodeId, reader.ReadString());
                case "PhysicsBodyType":
                    return new ScriptNodeHolePhysicsBodyType(nodeId, reader.ReadString());
                default:
                    return new ScriptNodeHolePluggable(nodeId)
                }
            } else {
                switch (holeType) {
                case "EventType":
                    return reader.ReadString();
                case "StringValue":
                    return reader.ReadString();
                case "NumberValue":
                    return reader.ReadFloat64();
                case "BooleanValue":
                    return reader.ReadBoolean();
                case "MapBlockOrientationValue":
                    return reader.ReadByte();
                case "CameraProjectionModeValue":
                    return reader.ReadString();
                default:
                    throw new Error("Unsupported hole type: " + holeType)
                }
            }
        };
        ScriptNodeData.HoleTypeAcceptsNodePiece = function (holeType) {
            switch (holeType) {
            case "EventType":
            case "StringValue":
            case "NumberValue":
            case "BooleanValue":
            case "MapBlockOrientationValue":
            case "CameraProjectionModeValue":
                return false;
            default:
                return true
            }
        };
        ScriptNodeData.ToLuaString = function (value) {
            return '"' + value.replace("\\", "\\\\").replace('"', '\\"') + '"'
        };
        return ScriptNodeData
    }();
    ScriptNodeHolePluggable = function () {
        function ScriptNodeHolePluggable(nodeId) {
            this.nodeId = nodeId
        }
        ScriptNodeHolePluggable.prototype.SerializeToLua = function (script, scriptAPIVersion) {
            return script.nodesById[this.nodeId].SerializeToLua(script, 0, scriptAPIVersion)
        };
        return ScriptNodeHolePluggable
    }();
    ScriptNodeHoleStringValue = function (_super) {
        __extends(ScriptNodeHoleStringValue, _super);

        function ScriptNodeHoleStringValue(nodeId, rawValue) {
            this.rawValue = rawValue;
            ScriptNodeHoleStringValue.__super__.constructor.call(this, nodeId)
        }
        ScriptNodeHoleStringValue.prototype.SerializeToLua = function (script, scriptAPIVersion) {
            if (this.nodeId === CSPlayer.UInt32MaxValue) {
                return CSPlayer.ScriptNodeData.ToLuaString(this.rawValue)
            }
            return ScriptNodeHoleStringValue.__super__.SerializeToLua.call(this, script, scriptAPIVersion)
        };
        return ScriptNodeHoleStringValue
    }(ScriptNodeHolePluggable);
    ScriptNodeHoleSimpleValue = function (_super) {
        __extends(ScriptNodeHoleSimpleValue, _super);

        function ScriptNodeHoleSimpleValue(nodeId, rawValue) {
            this.rawValue = rawValue;
            ScriptNodeHoleSimpleValue.__super__.constructor.call(this, nodeId)
        }
        ScriptNodeHoleSimpleValue.prototype.SerializeToLua = function (script, scriptAPIVersion) {
            if (this.nodeId === CSPlayer.UInt32MaxValue) {
                return this.rawValue
            }
            return ScriptNodeHoleSimpleValue.__super__.SerializeToLua.call(this, script, scriptAPIVersion)
        };
        return ScriptNodeHoleSimpleValue
    }(ScriptNodeHolePluggable);
    ScriptNodeHoleVector3 = function (_super) {
        __extends(ScriptNodeHoleVector3, _super);

        function ScriptNodeHoleVector3(nodeId, rawValue) {
            this.rawValue = rawValue;
            ScriptNodeHoleVector3.__super__.constructor.call(this, nodeId)
        }
        ScriptNodeHoleVector3.prototype.SerializeToLua = function (script, scriptAPIVersion) {
            if (this.nodeId === CSPlayer.UInt32MaxValue) {
                return "Vector3:New( " + this.rawValue.x + ", " + this.rawValue.y + ", " + this.rawValue.z + " )"
            }
            return ScriptNodeHoleVector3.__super__.SerializeToLua.call(this, script, scriptAPIVersion)
        };
        return ScriptNodeHoleVector3
    }(ScriptNodeHolePluggable);
    ScriptNodeHoleQuaternion = function (_super) {
        __extends(ScriptNodeHoleQuaternion, _super);

        function ScriptNodeHoleQuaternion(nodeId, rawValue) {
            this.rawValue = rawValue;
            ScriptNodeHoleQuaternion.__super__.constructor.call(this, nodeId)
        }
        ScriptNodeHoleQuaternion.prototype.SerializeToLua = function (script, scriptAPIVersion) {
            if (this.nodeId === CSPlayer.UInt32MaxValue) {
                return "Quaternion:New( " + this.rawValue.x + ", " + this.rawValue.y + ", " + this.rawValue.z + ", " + this.rawValue.w + " )"
            }
            return ScriptNodeHoleQuaternion.__super__.SerializeToLua.call(this, script, scriptAPIVersion)
        };
        return ScriptNodeHoleQuaternion
    }(ScriptNodeHolePluggable);
    ScriptNodeHoleMapBlockOrientation = function (_super) {
        __extends(ScriptNodeHoleMapBlockOrientation, _super);

        function ScriptNodeHoleMapBlockOrientation(nodeId, rawValue) {
            this.rawValue = rawValue;
            ScriptNodeHoleMapBlockOrientation.__super__.constructor.call(this, nodeId)
        }
        ScriptNodeHoleMapBlockOrientation.prototype.SerializeToLua = function (script, scriptAPIVersion) {
            if (this.nodeId === CSPlayer.UInt32MaxValue) {
                return "Map.BlockOrientation." + Object.keys(CSPlayer.Map.BlockOrientation)[this.rawValue]
            }
            return ScriptNodeHoleMapBlockOrientation.__super__.SerializeToLua.call(this, script, scriptAPIVersion)
        };
        return ScriptNodeHoleMapBlockOrientation
    }(ScriptNodeHolePluggable);
    ScriptNodeHoleCameraProjectionMode = function (_super) {
        __extends(ScriptNodeHoleCameraProjectionMode, _super);

        function ScriptNodeHoleCameraProjectionMode(nodeId, rawValue) {
            this.rawValue = rawValue;
            ScriptNodeHoleCameraProjectionMode.__super__.constructor.call(this, nodeId)
        }
        ScriptNodeHoleCameraProjectionMode.prototype.SerializeToLua = function (script, scriptAPIVersion) {
            if (this.nodeId === CSPlayer.UInt32MaxValue) {
                return "Camera.ProjectionMode." + this.rawValue
            }
            return ScriptNodeHoleCameraProjectionMode.__super__.SerializeToLua.call(this, script, scriptAPIVersion)
        };
        return ScriptNodeHoleCameraProjectionMode
    }(ScriptNodeHolePluggable);
    ScriptNodeHolePhysicsBodyType = function (_super) {
        __extends(ScriptNodeHolePhysicsBodyType, _super);

        function ScriptNodeHolePhysicsBodyType(nodeId, rawValue) {
            this.rawValue = rawValue;
            ScriptNodeHolePhysicsBodyType.__super__.constructor.call(this, nodeId)
        }
        ScriptNodeHolePhysicsBodyType.prototype.SerializeToLua = function (script, scriptAPIVersion) {
            if (this.nodeId === CSPlayer.UInt32MaxValue) {
                return "Physics.BodyType." + this.rawValue
            }
            return ScriptNodeHolePhysicsBodyType.__super__.SerializeToLua.call(this, script, scriptAPIVersion)
        };
        return ScriptNodeHolePhysicsBodyType
    }(ScriptNodeHolePluggable)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Script = function (_super) {
        var CurrentFormatVersion, OldestSupportedFormatVersion, OldestSupportedVisualFormatVersion;
        __extends(Script, _super);
        OldestSupportedFormatVersion = 8;
        OldestSupportedVisualFormatVersion = 11;
        CurrentFormatVersion = 11;

        function Script(id) {
            Script.__super__.constructor.call(this, id, CSPlayer.AssetType.Script);
            this.scriptProperties = [];
            this.scriptPropertiesById = {};
            this.nextScriptPropertyId = 0
        }
        Script.LoadFromUrl = function (id, url, callback) {
            return CSPlayer.DownloadUrl(url, "arraybuffer", function (_this) {
                return function (buffer) {
                    var reader;
                    reader = new CSPlayer.BinaryReader(buffer);
                    return _this.Deserialize(id, reader, callback)
                }
            }(this))
        };
        Script.Deserialize = function (id, reader, callback) {
            var assetType, formatVersion, index, nextNodeId, node, nodeCount, property, propertyCount, script, _i, _j;
            assetType = reader.ReadUInt8();
            if (assetType !== CSPlayer.AssetType.Script) {
                callback({
                    message: "Invalid asset type: " + assetType
                });
                return
            }
            formatVersion = reader.ReadUInt16();
            if (formatVersion < OldestSupportedFormatVersion || formatVersion > CurrentFormatVersion) {
                callback({
                    message: "Unsupported format version: " + formatVersion
                });
                return
            }
            script = new CSPlayer.Script(id);
            script.isVisual = reader.ReadBoolean();
            if (script.isVisual) {
                if (formatVersion < OldestSupportedVisualFormatVersion) {
                    callback({
                        message: "Unsupported format version: " + formatVersion
                    });
                    return
                }
                script.nodesById = {};
                script.rootNodes = [];
                nodeCount = reader.ReadUInt32();
                nextNodeId = reader.ReadUInt32();
                for (index = _i = 0; 0 <= nodeCount ? _i < nodeCount : _i > nodeCount; index = 0 <= nodeCount ? ++_i : --_i) {
                    node = CSPlayer.ScriptNode.Deserialize(reader, formatVersion);
                    script.nodesById[node.nodeId] = node;
                    if (node.upNodeId === CSPlayer.UInt32MaxValue && node.data.nodeType === "Event") {
                        script.rootNodes.push(node)
                    }
                }
            } else {
                script.latestStateIndex = reader.ReadInt32();
                script.content = reader.ReadString()
            }
            propertyCount = reader.ReadUInt16();
            script.nextScriptPropertyId = reader.ReadUInt16();
            for (index = _j = 0; 0 <= propertyCount ? _j < propertyCount : _j > propertyCount; index = 0 <= propertyCount ? ++_j : --_j) {
                property = new CSPlayer.ScriptProperty(reader.ReadUInt16(), reader.ReadString());
                property.propertyType = reader.ReadUInt8();
                switch (property.propertyType) {
                case CSPlayer.ScriptProperty.ScriptPropertyType.Boolean:
                    property.defaultValue.booleanValue = reader.ReadBoolean();
                    break;
                case CSPlayer.ScriptProperty.ScriptPropertyType.Number:
                    property.defaultValue.numberValue = reader.ReadFloat64();
                    break;
                case CSPlayer.ScriptProperty.ScriptPropertyType.String:
                    property.defaultValue.stringValue = reader.ReadString()
                }
                script.scriptProperties.push(property);
                script.scriptPropertiesById[property.id] = property
            }
            return callback(null, script)
        };
        Script.prototype.SerializeToLua = function (scriptAPIVersion) {
            var content, node, _i, _len, _ref;
            content = "";
            _ref = this.rootNodes;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                content += node.SerializeToLua(this, 0, scriptAPIVersion)
            }
            return content
        };
        return Script
    }(CSPlayer.Asset);
    CSPlayer.ScriptProperty = function () {
        ScriptProperty.ScriptPropertyType = {
            Boolean: 0,
            Number: 1,
            String: 2
        };

        function ScriptProperty(id, name) {
            this.id = id;
            this.name = name;
            this.defaultValue = new CSPlayer.ScriptPropertyValue
        }
        return ScriptProperty
    }();
    CSPlayer.ScriptPropertyValue = function () {
        function ScriptPropertyValue() {
            this.booleanValue = false;
            this.numberValue = 0;
            this.stringValue = ""
        }
        return ScriptPropertyValue
    }()
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Sound = function (_super) {
        var CurrentFormatVersion, OldestSupportedFormatVersion;
        __extends(Sound, _super);
        OldestSupportedFormatVersion = 0;
        CurrentFormatVersion = 0;

        function Sound(id) {
            Sound.__super__.constructor.call(this, id, CSPlayer.AssetType.Sound)
        }
        Sound.LoadFromUrl = function (id, url, callback) {
            return CSPlayer.DownloadUrl(url, "arraybuffer", function (_this) {
                return function (buffer) {
                    var reader;
                    reader = new CSPlayer.BinaryReader(buffer);
                    return _this.Deserialize(id, reader, callback)
                }
            }(this))
        };
        Sound.Deserialize = function (id, reader, callback) {
            var assetType, sound, soundFileSize;
            assetType = reader.ReadUInt8();
            if (assetType !== CSPlayer.AssetType.Sound) {
                callback({
                    message: "Invalid asset type: " + assetType
                });
                return
            }
            sound = new CSPlayer.Sound(id);
            soundFileSize = reader.ReadUInt32();
            sound.rawData = reader.ReadBytes(soundFileSize);
            return callback(null, sound)
        };
        return Sound
    }(CSPlayer.Asset)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Font = function (_super) {
        var CurrentFormatVersion, OldestSupportedFormatVersion;
        __extends(Font, _super);
        OldestSupportedFormatVersion = 3;
        CurrentFormatVersion = 3;

        function Font(id) {
            Font.__super__.constructor.call(this, id, CSPlayer.AssetType.Font);
            this.characterRanges = []
        }
        Font.LoadFromUrl = function (id, url, callback) {
            return CSPlayer.DownloadUrl(url, "arraybuffer", function (_this) {
                return function (buffer) {
                    var reader;
                    reader = new CSPlayer.BinaryReader(buffer);
                    return _this.Deserialize(id, reader, callback)
                }
            }(this))
        };
        Font.Deserialize = function (id, reader, callback) {
            var assetType, charInfo, charRange, charRangeCount, font, formatVersion, i, img, s, textureData, textureDataLength, _i, _j, _k, _len, _ref, _ref1;
            assetType = reader.ReadUInt8();
            if (assetType !== CSPlayer.AssetType.Font) {
                callback({
                    message: "Invalid asset type: " + assetType
                });
                return
            }
            formatVersion = reader.ReadUInt16();
            if (formatVersion < OldestSupportedFormatVersion || formatVersion > CurrentFormatVersion) {
                callback({
                    message: "Unsupported format version: " + formatVersion
                });
                return
            }
            font = new CSPlayer.Font(id);
            font.baseCharacterWidth = reader.ReadUInt16();
            font.baseCharacterHeight = reader.ReadUInt16();
            charRangeCount = reader.ReadUInt16();
            for (i = _i = 0; 0 <= charRangeCount ? _i < charRangeCount : _i > charRangeCount; i = 0 <= charRangeCount ? ++_i : --_i) {
                charRange = new CSPlayer.CharacterRange(reader.ReadUInt32(), reader.ReadUInt32());
                font.characterRanges.push(charRange);
                _ref = charRange.characterInfos;
                for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                    charInfo = _ref[_j];
                    charInfo.startOffset = reader.ReadUInt16();
                    charInfo.endOffset = reader.ReadUInt16()
                }
            }
            textureDataLength = reader.ReadInt32();
            textureData = reader.ReadBytes(textureDataLength);
            img = new Image;
            img.onload = function () {
                font.image = img;
                return callback(null, font)
            };
            s = "";
            for (i = _k = 0, _ref1 = textureData.length; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
                s += String.fromCharCode(textureData[i])
            }
            return img.src = "data:image/png;base64," + btoa(s)
        };
        return Font
    }(CSPlayer.Asset);
    CSPlayer.CharacterRange = function () {
        function CharacterRange(startCharacter, endCharacter) {
            var characterCount, i;
            this.startCharacter = startCharacter;
            this.endCharacter = endCharacter;
            characterCount = this.endCharacter - this.startCharacter + 1;
            this.characterInfos = function () {
                var _i, _results;
                _results = [];
                for (i = _i = 0; 0 <= characterCount ? _i < characterCount : _i > characterCount; i = 0 <= characterCount ? ++_i : --_i) {
                    _results.push(new CSPlayer.CharacterInfo)
                }
                return _results
            }()
        }
        return CharacterRange
    }();
    CSPlayer.CharacterInfo = function () {
        function CharacterInfo() {
            this.startOffset = 0;
            this.endOffset = 0
        }
        return CharacterInfo
    }()
}).call(this);
(function () {
    CSPlayer.Components.Component = function () {
        Component.ComponentTypeMap = {};

        function Component(componentType) {
            this.componentType = componentType
        }
        Component.Deserialize = function (reader, formatVersion) {
            var component, componentClass, componentId, componentType;
            componentId = reader.ReadUInt16();
            componentType = reader.ReadUInt8();
            componentClass = CSPlayer.Components.Component.ComponentTypeMap[componentType];
            component = componentClass.Deserialize(reader, formatVersion);
            component.componentId = componentId;
            return component
        };
        return Component
    }()
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Components.Transform = function (_super) {
        __extends(Transform, _super);
        CSPlayer.Components.Component.ComponentTypeMap[CSPlayer.ComponentType.Transform] = Transform;

        function Transform() {
            Transform.__super__.constructor.call(this, CSPlayer.ComponentType.Transform);
            this.position = new THREE.Vector3;
            this.scale = new THREE.Vector3(1, 1, 1);
            this.orientation = new THREE.Quaternion
        }
        Transform.Deserialize = function (reader, formatVersion) {
            var component;
            component = new CSPlayer.Components.Transform;
            component.position = reader.ReadVector3();
            component.scale = reader.ReadVector3();
            component.orientation = reader.ReadQuaternion();
            return component
        };
        return Transform
    }(CSPlayer.Components.Component)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Components.Camera = function (_super) {
        __extends(Camera, _super);
        CSPlayer.Components.Component.ComponentTypeMap[CSPlayer.ComponentType.Camera] = Camera;
        Camera.CameraProjectionMode = {
            Perspective: 0,
            Orthographic: 1
        };

        function Camera() {
            Camera.__super__.constructor.call(this, CSPlayer.ComponentType.Camera);
            this.projectionMode = CSPlayer.Components.Camera.CameraProjectionMode.Perspective;
            this.fov = 45;
            this.orthographicScale = 10;
            this.renderViewportPosition = new THREE.Vector2(0, 0);
            this.renderViewportSize = new THREE.Vector2(1, 1)
        }
        Camera.Deserialize = function (reader, formatVersion) {
            var component;
            component = new CSPlayer.Components.Camera;
            component.projectionMode = reader.ReadUInt8();
            component.fov = reader.ReadFloat32();
            component.orthographicScale = reader.ReadFloat32();
            component.renderViewportPosition = reader.ReadVector2();
            component.renderViewportSize = reader.ReadVector2();
            return component
        };
        return Camera
    }(CSPlayer.Components.Component)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Components.ModelRenderer = function (_super) {
        __extends(ModelRenderer, _super);
        CSPlayer.Components.Component.ComponentTypeMap[CSPlayer.ComponentType.ModelRenderer] = ModelRenderer;

        function ModelRenderer() {
            ModelRenderer.__super__.constructor.call(this, CSPlayer.ComponentType.ModelRenderer);
            this.modelId = CSPlayer.UInt16MaxValue;
            this.opacity = 1
        }
        ModelRenderer.Deserialize = function (reader, formatVersion) {
            var component, revisionId;
            component = new CSPlayer.Components.ModelRenderer;
            component.modelId = reader.ReadUInt16();
            revisionId = reader.ReadUInt16();
            component.opacity = reader.ReadFloat32();
            return component
        };
        return ModelRenderer
    }(CSPlayer.Components.Component)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Components.MapRenderer = function (_super) {
        __extends(MapRenderer, _super);
        CSPlayer.Components.Component.ComponentTypeMap[CSPlayer.ComponentType.MapRenderer] = MapRenderer;

        function MapRenderer() {
            MapRenderer.__super__.constructor.call(this, CSPlayer.ComponentType.MapRenderer);
            this.mapId = CSPlayer.UInt16MaxValue;
            this.opacity = 1
        }
        MapRenderer.Deserialize = function (reader, formatVersion) {
            var component, revisionId;
            component = new CSPlayer.Components.MapRenderer;
            component.mapId = reader.ReadUInt16();
            revisionId = reader.ReadUInt16();
            component.opacity = reader.ReadFloat32();
            return component
        };
        return MapRenderer
    }(CSPlayer.Components.Component)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Components.TextRenderer = function (_super) {
        __extends(TextRenderer, _super);
        CSPlayer.Components.Component.ComponentTypeMap[CSPlayer.ComponentType.TextRenderer] = TextRenderer;

        function TextRenderer() {
            TextRenderer.__super__.constructor.call(this, CSPlayer.ComponentType.TextRenderer)
        }
        TextRenderer.Deserialize = function (reader, formatVersion) {
            var component;
            component = new CSPlayer.Components.TextRenderer;
            component.fontId = reader.ReadUInt16();
            component.text = reader.ReadString();
            if (formatVersion >= 12) {
                component.alignment = reader.ReadUInt8()
            }
            component.opacity = reader.ReadFloat32();
            return component
        };
        return TextRenderer
    }(CSPlayer.Components.Component)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Components.ScriptedBehavior = function (_super) {
        __extends(ScriptedBehavior, _super);
        CSPlayer.Components.Component.ComponentTypeMap[CSPlayer.ComponentType.ScriptedBehavior] = ScriptedBehavior;

        function ScriptedBehavior() {
            ScriptedBehavior.__super__.constructor.call(this, CSPlayer.ComponentType.ScriptedBehavior);
            this.scriptId = CSPlayer.UInt16MaxValue;
            this.scriptPropertyValuesById = {}
        }
        ScriptedBehavior.Deserialize = function (reader, formatVersion) {
            var component, index, propertyCount, propertyId, revisionId, scriptPropertyValue, _i;
            component = new CSPlayer.Components.ScriptedBehavior;
            component.scriptId = reader.ReadUInt16();
            revisionId = reader.ReadUInt16();
            propertyCount = reader.ReadUInt16();
            for (index = _i = 0; 0 <= propertyCount ? _i < propertyCount : _i > propertyCount; index = 0 <= propertyCount ? ++_i : --_i) {
                propertyId = reader.ReadUInt16();
                scriptPropertyValue = new CSPlayer.ScriptPropertyValue;
                scriptPropertyValue.booleanValue = reader.ReadBoolean();
                scriptPropertyValue.numberValue = reader.ReadFloat64();
                scriptPropertyValue.stringValue = reader.ReadString();
                component.scriptPropertyValuesById[propertyId] = scriptPropertyValue
            }
            return component
        };
        return ScriptedBehavior
    }(CSPlayer.Components.Component)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Components.Physics = function (_super) {
        __extends(Physics, _super);
        CSPlayer.Components.Component.ComponentTypeMap[CSPlayer.ComponentType.Physics] = Physics;

        function Physics() {
            Physics.__super__.constructor.call(this, CSPlayer.ComponentType.Physics);
            this.freezePosition = [false, false, false];
            this.freezeRotation = [false, false, false]
        }
        Physics.Deserialize = function (reader, formatVersion) {
            var component;
            component = new CSPlayer.Components.Physics;
            component.bodyType = reader.ReadUInt8();
            component.mass = reader.ReadFloat32();
            component.colliderType = reader.ReadUInt8();
            component.boxSize = reader.ReadVector3();
            component.sphereRadius = reader.ReadFloat32();
            component.capsuleRadius = reader.ReadFloat32();
            component.capsuleHeight = reader.ReadFloat32();
            component.modelId = reader.ReadUInt16();
            component.mapId = reader.ReadUInt16();
            component.tileSetId = reader.ReadUInt16();
            component.isTrigger = reader.ReadUInt8() !== 0;
            component.freezePosition[0] = reader.ReadUInt8() !== 0;
            component.freezePosition[1] = reader.ReadUInt8() !== 0;
            component.freezePosition[2] = reader.ReadUInt8() !== 0;
            component.freezeRotation[0] = reader.ReadUInt8() !== 0;
            component.freezeRotation[1] = reader.ReadUInt8() !== 0;
            component.freezeRotation[2] = reader.ReadUInt8() !== 0;
            component.characterControllerStepHeight = reader.ReadFloat32();
            component.characterControllerMaxSlope = reader.ReadFloat32();
            return component
        };
        return Physics
    }(CSPlayer.Components.Component)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.Components.NetworkSync = function (_super) {
        __extends(NetworkSync, _super);
        CSPlayer.Components.Component.ComponentTypeMap[CSPlayer.ComponentType.NetworkSync] = NetworkSync;

        function NetworkSync() {
            NetworkSync.__super__.constructor.call(this, CSPlayer.ComponentType.NetworkSync)
        }
        NetworkSync.Deserialize = function (reader, formatVersion) {
            var component;
            component = new CSPlayer.Components.NetworkSync;
            return component
        };
        return NetworkSync
    }(CSPlayer.Components.Component)
}).call(this);
(function () {
    CSPlayer.GamePackage = function () {
        var CurrentFormatVersion, OldestSupportedFormatVersion;
        OldestSupportedFormatVersion = 1;
        CurrentFormatVersion = 2;

        function GamePackage(title, startupSceneId, scriptAPIVersion) {
            this.title = title;
            this.startupSceneId = startupSceneId;
            this.scriptAPIVersion = scriptAPIVersion;
            this.controls = {};
            this.nextAssetId = 0;
            this.assets = {};
            this.assetFQNames = {};
            this.orderedAssetIds = []
        }
        GamePackage.GetPathForAsset = function (assetId, entryType) {
            return CSPlayer.Asset.AssetTypeDirectories[entryType] + "/" + assetId + "." + CSPlayer.Asset.AssetTypeExtensions[entryType]
        };
        GamePackage.LoadFromBaseUrl = function (baseUrl, callback, progressCallback) {
            return CSPlayer.DownloadUrl(baseUrl + "GamePackage.dat", "arraybuffer", function (_this) {
                return function (buffer) {
                    var reader;
                    reader = new CSPlayer.BinaryReader(buffer);
                    return _this.Deserialize(reader, baseUrl, callback, progressCallback)
                }
            }(this), progressCallback)
        };
        GamePackage.Deserialize = function (reader, baseUrl, callback, progressCallback) {
            var assetCount, assetsLoaded, control, formatVersion, gameControlCount, gamePackage, highestAssetId, i, index, loadNextAsset, scriptAPIVersion, startupSceneId, title, _i, _j;
            formatVersion = reader.ReadUInt8();
            if (formatVersion < OldestSupportedFormatVersion || formatVersion > CurrentFormatVersion) {
                callback(new Error("Unsupported format version: " + formatVersion));
                return
            }
            title = reader.ReadString();
            startupSceneId = reader.ReadUInt16();
            scriptAPIVersion = formatVersion > 1 ? reader.ReadUInt16() : 0;
            gamePackage = new CSPlayer.GamePackage(title, startupSceneId, scriptAPIVersion);
            gamePackage.baseUrl = baseUrl;
            gameControlCount = reader.ReadUInt16();
            for (index = _i = 0; 0 <= gameControlCount ? _i < gameControlCount : _i > gameControlCount; index = 0 <= gameControlCount ? ++_i : --_i) {
                control = CSPlayer.GameControl.Deserialize(reader, formatVersion);
                gamePackage.controls[control.name] = control
            }
            assetCount = reader.ReadUInt16();
            highestAssetId = 0;
            loadNextAsset = function (_this) {
                return function (callback) {
                    var assetId, entryType, fqName, url;
                    assetId = reader.ReadUInt16();
                    gamePackage.orderedAssetIds.push(assetId);
                    fqName = reader.ReadString();
                    entryType = reader.ReadUInt8();
                    highestAssetId = Math.max(assetId, highestAssetId);
                    url = baseUrl + "Data/" + _this.GetPathForAsset(assetId, entryType);
                    return CSPlayer.Asset.LoadFromUrl(assetId, entryType, url, function (err, asset) {
                        if (err != null) {
                            callback({
                                inner: err,
                                message: "Error loading " + fqName + ": " + err.message
                            });
                            return
                        }
                        if (asset !== null) {
                            gamePackage.assets[assetId] = asset;
                            gamePackage.assetFQNames[assetId] = fqName
                        } else {
                            console.warn('Skipping asset "' + fqName + '" (' + assetId + ") of type " + entryType)
                        }
                        return callback()
                    })
                }
            }(this);
            assetsLoaded = 0;
            for (i = _j = 0; 0 <= assetCount ? _j < assetCount : _j > assetCount; i = 0 <= assetCount ? ++_j : --_j) {
                loadNextAsset(function (err) {
                    if (err != null) {
                        console.error(err);
                        return
                    }
                    assetsLoaded++;
                    progressCallback(assetsLoaded, assetCount, "Downloading assets...");
                    if (assetsLoaded === assetCount) {
                        return callback(gamePackage)
                    }
                })
            }
            return gamePackage.nextAssetId = highestAssetId + 1
        };
        return GamePackage
    }()
}).call(this);
(function () {
    CSPlayer.ComponentInstances.Component = function () {
        Component.ComponentTypeMap = {};

        function Component(gameObject, componentType, createLuaSelf) {
            this.gameObject = gameObject;
            this.componentType = componentType;
            if (createLuaSelf == null) {
                createLuaSelf = true
            }
            this.luaSelf = createLuaSelf ? this.gameObject.gameInstance.scriptAPI.SetupLuaComponent(this) : null
        }
        Component.prototype.Awake = function () {};
        Component.prototype.WarmUp = function () {};
        Component.prototype.Start = function () {};
        Component.prototype.OnDestroy = function () {
            this.luaSelf.str["inner"] = null;
            this.luaSelf.str["gameObject"] = null;
            this.luaSelf = null
        };
        return Component
    }()
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.ComponentInstances.Transform = function (_super) {
        var tmpRotationMatrix;
        __extends(Transform, _super);
        CSPlayer.ComponentInstances.Component.ComponentTypeMap[CSPlayer.ComponentType.Transform] = Transform;

        function Transform(gameObject, component) {
            Transform.__super__.constructor.call(this, gameObject, component.componentType);
            this.gameObject.luaSelf.str["transform"] = this.luaSelf;
            this.object = new THREE.Object3D;
            this.object.position = component.position.clone();
            this.object.quaternion = component.orientation.clone();
            this.object.scale = component.scale.clone();
            if (this.gameObject.parentNodeId !== CSPlayer.UInt16MaxValue) {
                this.gameObject.gameInstance.nodeTree.nodesById[gameObject.parentNodeId].transform.object.add(this.object)
            } else {
                CSPlayer.scene.add(this.object)
            }
            this.object.updateMatrixWorld()
        }
        Transform.prototype.OnDestroy = function () {
            this.object.parent.remove(this.object);
            Transform.__super__.OnDestroy.call(this)
        };
        Transform.prototype.Update = function () {};
        tmpRotationMatrix = new THREE.Matrix4;
        Transform.prototype.GetGlobalMatrix = function () {
            return this.object.matrixWorld.clone()
        };
        Transform.prototype.GetGlobalPosition = function () {
            return (new THREE.Vector3).getPositionFromMatrix(this.object.matrixWorld)
        };
        Transform.prototype.GetParentGlobalOrientation = function () {
            var ancestorGameObject, ancestorOrientation;
            ancestorOrientation = new THREE.Quaternion;
            ancestorGameObject = this.object;
            while (ancestorGameObject.parent != null) {
                ancestorGameObject = ancestorGameObject.parent;
                ancestorOrientation.multiplyQuaternions(ancestorGameObject.quaternion, ancestorOrientation)
            }
            return ancestorOrientation
        };
        Transform.prototype.GetGlobalOrientation = function () {
            return (new THREE.Quaternion).multiplyQuaternions(this.GetParentGlobalOrientation(), this.object.quaternion)
        };
        Transform.prototype.GetGlobalEulerAngles = function () {
            return (new THREE.Euler).setFromQuaternion(this.GetGlobalOrientation())
        };
        Transform.prototype.SetGlobalMatrix = function (matrix) {
            matrix.multiplyMatrices((new THREE.Matrix4).getInverse(this.object.parent.matrixWorld), matrix);
            matrix.decompose(this.object.position, this.object.quaternion, this.object.scale);
            this.object.updateMatrixWorld()
        };
        Transform.prototype.SetGlobalPosition = function (pos) {
            this.object.parent.worldToLocal(pos);
            this.object.position.set(pos.x, pos.y, pos.z);
            this.object.updateMatrixWorld()
        };
        Transform.prototype.SetGlobalOrientation = function (quaternion) {
            var inverseParentQuaternion;
            inverseParentQuaternion = (new THREE.Quaternion).setFromRotationMatrix(tmpRotationMatrix.extractRotation(this.object.parent.matrixWorld)).inverse();
            quaternion.multiplyQuaternions(inverseParentQuaternion, quaternion);
            this.object.quaternion = quaternion;
            this.object.updateMatrixWorld()
        };
        Transform.prototype.SetGlobalEulerAngles = function (eulerAngles) {
            var globalQuaternion, inverseParentQuaternion;
            globalQuaternion = (new THREE.Quaternion).setFromEuler(eulerAngles);
            inverseParentQuaternion = (new THREE.Quaternion).setFromRotationMatrix(tmpRotationMatrix.extractRotation(this.object.parent.matrixWorld)).inverse();
            globalQuaternion.multiplyQuaternions(inverseParentQuaternion, globalQuaternion);
            this.object.quaternion = globalQuaternion;
            this.object.updateMatrixWorld()
        };
        Transform.prototype.RotateGlobal = function (quaternion) {
            var globalOrientation;
            globalOrientation = this.GetGlobalOrientation();
            globalOrientation.multiplyQuaternions(quaternion, globalOrientation);
            this.SetGlobalOrientation(globalOrientation)
        };
        Transform.prototype.RotateLocal = function (quaternion) {
            this.object.quaternion.multiplyQuaternions(quaternion, this.object.quaternion);
            this.object.updateMatrixWorld()
        };
        Transform.prototype.RotateGlobalEulerAngles = function (eulerAngles) {
            var quaternion;
            quaternion = (new THREE.Quaternion).setFromEuler(eulerAngles);
            this.RotateGlobal(quaternion)
        };
        Transform.prototype.RotateLocalEulerAngles = function (eulerAngles) {
            var quaternion;
            quaternion = (new THREE.Quaternion).setFromEuler(eulerAngles);
            this.object.quaternion.multiplyQuaternions(quaternion, this.object.quaternion);
            this.object.updateMatrixWorld()
        };
        Transform.prototype.MoveGlobal = function (offset) {
            offset.add(this.GetGlobalPosition());
            this.SetGlobalPosition(offset)
        };
        Transform.prototype.MoveLocal = function (offset) {
            this.object.position.add(offset);
            this.object.updateMatrixWorld()
        };
        Transform.prototype.MoveOriented = function (offset) {
            offset.applyQuaternion(this.object.quaternion);
            this.object.position.add(offset);
            this.object.updateMatrixWorld()
        };
        return Transform
    }(CSPlayer.ComponentInstances.Component)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.ComponentInstances.Camera = function (_super) {
        __extends(Camera, _super);
        CSPlayer.ComponentInstances.Component.ComponentTypeMap[CSPlayer.ComponentType.Camera] = Camera;

        function Camera(gameObject, component) {
            Camera.__super__.constructor.call(this, gameObject, component.componentType);
            this.gameObject.luaSelf.str["camera"] = this.luaSelf;
            this.fov = component.fov;
            this.orthographicScale = component.orthographicScale;
            this.orthographicTranslationMatrix = new THREE.Matrix4;
            this.viewportPosition = component.renderViewportPosition.clone();
            this.viewportSize = component.renderViewportSize.clone();
            this.cachedRatio = this.ComputeAspectRatio();
            this.SetProjectionMode(component.projectionMode);
            this.gameObject.gameInstance.activeCameras.push(this)
        }
        Camera.prototype.ComputeAspectRatio = function () {
            return this.gameObject.gameInstance.canvas.width * this.viewportSize.x / (this.gameObject.gameInstance.canvas.height * this.viewportSize.y)
        };
        Camera.prototype.SetProjectionMode = function (projectionMode) {
            var farClippingPlane, nearClippingPlane;
            nearClippingPlane = .1;
            farClippingPlane = 1e3;
            this.projectionMode = projectionMode;
            if (this.projectionMode === CSPlayer.Components.Camera.CameraProjectionMode.Perspective) {
                this.actualCamera = new THREE.PerspectiveCamera(this.fov, this.cachedRatio, nearClippingPlane, farClippingPlane)
            } else {
                this.actualCamera = new THREE.OrthographicCamera(-this.orthographicScale * this.cachedRatio / 2, this.orthographicScale * this.cachedRatio / 2, this.orthographicScale / 2, -this.orthographicScale / 2, nearClippingPlane, farClippingPlane)
            }
            this.projectionNeedsUpdate = true
        };
        Camera.prototype.OnDestroy = function () {
            var index;
            index = this.gameObject.gameInstance.activeCameras.indexOf(this);
            this.gameObject.gameInstance.activeCameras.splice(index, 1);
            return Camera.__super__.OnDestroy.call(this)
        };
        Camera.prototype.SetFOV = function (fov) {
            this.fov = fov;
            if (this.actualCamera instanceof THREE.PerspectiveCamera) {
                this.projectionNeedsUpdate = true
            }
        };
        Camera.prototype.SetOrthographicScale = function (scale) {
            this.orthographicScale = scale;
            if (this.actualCamera instanceof THREE.OrthographicCamera) {
                return this.projectionNeedsUpdate = true
            }
        };
        Camera.prototype.SetViewportPosition = function (x, y) {
            this.viewportPosition.x = x;
            this.viewportPosition.y = y;
            return this.projectionNeedsUpdate = true
        };
        Camera.prototype.SetViewportSize = function (x, y) {
            this.viewportSize.x = x;
            this.viewportSize.y = y;
            return this.projectionNeedsUpdate = true
        };
        Camera.prototype.Update = function () {};
        Camera.prototype.SetupRendering = function () {
            var ratio;
            this.actualCamera.position = this.gameObject.transform.GetGlobalPosition();
            this.actualCamera.quaternion = this.gameObject.transform.GetGlobalOrientation();
            ratio = this.ComputeAspectRatio();
            if (this.projectionNeedsUpdate || ratio !== this.cachedRatio) {
                this.projectionNeedsUpdate = false;
                this.cachedRatio = ratio;
                if (this.actualCamera instanceof THREE.PerspectiveCamera) {
                    this.actualCamera.fov = this.fov;
                    this.actualCamera.aspect = ratio;
                    this.actualCamera.updateProjectionMatrix()
                } else {
                    this.actualCamera.left = -this.orthographicScale * ratio / 2;
                    this.actualCamera.right = this.orthographicScale * ratio / 2;
                    this.actualCamera.top = this.orthographicScale / 2;
                    this.actualCamera.bottom = -this.orthographicScale / 2;
                    this.orthographicTranslationMatrix.makeTranslation(-.5 / (this.orthographicScale * ratio), .5 / this.orthographicScale, 0);
                    this.actualCamera.updateProjectionMatrix();
                    this.actualCamera.projectionMatrix.multiplyMatrices(this.actualCamera.projectionMatrix, this.orthographicTranslationMatrix)
                }
            }
            return CSPlayer.renderer.setViewport(this.viewportPosition.x * this.gameObject.gameInstance.canvas.width, (1 - this.viewportPosition.y - this.viewportSize.y) * this.gameObject.gameInstance.canvas.height, this.viewportSize.x * this.gameObject.gameInstance.canvas.width, this.viewportSize.y * this.gameObject.gameInstance.canvas.height)
        };
        return Camera
    }(CSPlayer.ComponentInstances.Component)
}).call(this);
(function () {
    var setupUVPoints, __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.ComponentInstances.ModelRenderer = function (_super) {
        var backNormal, blockScaledMatrix, bottomNormal, frontNormal, leftBottomBack, leftBottomFront, leftNormal, leftTopBack, leftTopFront, normalMatrix, rightBottomBack, rightBottomFront, rightNormal, rightTopBack, rightTopFront, rootNodeIdentityMatrix, setupQuad, topNormal;
        __extends(ModelRenderer, _super);
        CSPlayer.ComponentInstances.Component.ComponentTypeMap[CSPlayer.ComponentType.ModelRenderer] = ModelRenderer;

        function ModelRenderer(gameObject, component) {
            ModelRenderer.__super__.constructor.call(this, gameObject, component.componentType);
            this.gameObject.luaSelf.str["modelRenderer"] = this.luaSelf;
            this.modelRoot = new THREE.Object3D;
            this.gameObject.transform.object.add(this.modelRoot);
            this.modelRoot.updateMatrixWorld();
            this.colorMod = new THREE.Vector4(1, 1, 1, component.opacity);
            this.isAnimationPlaybackEnabled = true;
            if (component.modelId !== CSPlayer.UInt16MaxValue) {
                this.SetModel(this.gameObject.gameInstance.gamePackage.assets[component.modelId])
            }
        }
        ModelRenderer.prototype.SetOpacity = function (opacity) {
            this.colorMod.w = opacity;
            if (this.material != null) {
                return this.material.visible = this.colorMod.w > 0
            }
        };
        ModelRenderer.prototype.GetOpacity = function () {
            return this.colorMod.w
        };
        ModelRenderer.prototype.SetModel = function (model) {
            if (this.model) {
                if (this.material != null) {
                    this.gameObject.gameInstance.assetTextureCache.ReleaseTexture(this.model.id);
                    this.texture = null;
                    this.material.dispose();
                    this.material = null
                }
                while (this.modelRoot.children.length > 0) {
                    this.modelRoot.remove(this.modelRoot.children[0])
                }
            }
            this.model = model;
            if (this.model == null) {
                return
            }
            this.texture = this.gameObject.gameInstance.assetTextureCache.GetTexture(this.model.id, this.model.image);
            this.material = new THREE.ShaderMaterial({
                vertexShader: CSPlayer.VertexShader,
                fragmentShader: CSPlayer.FragmentShader,
                uniforms: {
                    map: {
                        type: "t",
                        value: this.texture
                    },
                    colorMod: {
                        type: "v4",
                        value: this.colorMod
                    },
                    lightDiffuseColor: {
                        type: "v3",
                        value: new THREE.Vector3(.3, .3, .3)
                    },
                    ambientColor: {
                        type: "v3",
                        value: new THREE.Vector3(.7, .7, .7)
                    }
                },
                side: THREE.DoubleSide,
                transparent: true,
                blending: THREE.CustomBlending,
                blendEquation: THREE.AddEquation,
                blendSrc: THREE.OneFactor,
                blendDst: THREE.OneMinusSrcAlphaFactor
            });
            this.material.visible = this.colorMod.w > 0;
            if (this.mesh != null) {
                this.mesh.geometry.dispose()
            }
            this.mesh = CSPlayer.ComponentInstances.ModelRenderer.BuildModelMesh(this.model.nodeTree, this.material);
            this.modelRoot.add(this.mesh);
            return this.mesh.updateMatrixWorld()
        };
        ModelRenderer.prototype.SetAnimation = function (animation) {
            this.modelAnimationPlayback = animation != null ? new CSPlayer.ModelAnimationPlayback(animation) : null;
            if (this.modelAnimationPlayback != null && this.model != null) {
                return this.modelAnimationPlayback.SetupNodeTree(this.modelRoot.children[0], this.model.nodeTree, true)
            }
        };
        ModelRenderer.prototype.GetAnimation = function () {
            if (this.modelAnimationPlayback != null) {
                return this.modelAnimationPlayback.animation
            } else {
                return null
            }
        };
        ModelRenderer.prototype.IsAnimationPlaying = function () {
            return this.isAnimationPlaybackEnabled && this.modelAnimationPlayback != null && this.modelAnimationPlayback.IsAnimationPlaying()
        };
        ModelRenderer.prototype.StartAnimationPlayback = function (looping) {
            this.isAnimationPlaybackEnabled = true;
            if (this.modelAnimationPlayback != null) {
                return this.modelAnimationPlayback.SetLoop(looping)
            }
        };
        ModelRenderer.prototype.StopAnimationPlayback = function () {
            return this.isAnimationPlaybackEnabled = false
        };
        ModelRenderer.prototype.SetAnimationTime = function (time) {
            if (this.modelAnimationPlayback != null) {
                this.modelAnimationPlayback.SetTime(time, true);
                if (this.model != null) {
                    return this.modelAnimationPlayback.SetupNodeTree(this.modelRoot.children[0], this.model.nodeTree)
                }
            }
        };
        ModelRenderer.prototype.GetAnimationTime = function () {
            if (this.modelAnimationPlayback != null) {
                return this.modelAnimationPlayback.time
            }
            return 0
        };
        ModelRenderer.prototype.GetAnimationDuration = function () {
            if (this.modelAnimationPlayback != null) {
                return this.modelAnimationPlayback.duration
            }
            return 0
        };
        ModelRenderer.prototype.GetBlockTransform = function (nodeName) {
            var blockOrientation, blockPosition, currentNode, dummyScale, factor, keyFrames, matrix, node, nodeAnim, nodeId, nodes, orientation, origin, pivotOffset, position, selfMatrix, _i, _len, _ref;
            currentNode = null;
            _ref = this.model.nodeTree.nodesById;
            for (nodeId in _ref) {
                node = _ref[nodeId];
                if (node.name === nodeName) {
                    currentNode = node;
                    break
                }
            }
            if (currentNode == null) {
                return null
            }
            nodes = [currentNode];
            while (currentNode.parentNodeId !== CSPlayer.UInt16MaxValue) {
                currentNode = this.model.nodeTree.nodesById[currentNode.parentNodeId];
                nodes.unshift(currentNode)
            }
            blockPosition = this.gameObject.transform.GetGlobalPosition();
            blockOrientation = this.gameObject.transform.GetGlobalOrientation();
            position = new THREE.Vector3;
            pivotOffset = new THREE.Vector3;
            orientation = new THREE.Quaternion;
            matrix = this.gameObject.transform.GetGlobalMatrix();
            for (_i = 0, _len = nodes.length; _i < _len; _i++) {
                node = nodes[_i];
                position.set(0, 0, 0);
                pivotOffset.set(0, 0, 0);
                orientation.set(0, 0, 0, 1);
                nodeAnim = null;
                if (this.modelAnimationPlayback != null) {
                    nodeAnim = this.modelAnimationPlayback.animation.nodeAnimsByNodeName[node.name]
                }
                if (nodeAnim != null) {
                    keyFrames = nodeAnim.GetNearestKeyFrames(nodeAnim.positionKeyFrames, this.modelAnimationPlayback.currentFrame, this.modelAnimationPlayback.animation.holdLastKeyFrame);
                    if (keyFrames != null) {
                        factor = this.modelAnimationPlayback.ComputeInterpolationFactor(keyFrames.previous.index, keyFrames.next.index);
                        position.copy(keyFrames.previous.delta);
                        position.lerp(keyFrames.next.delta, factor)
                    }
                    keyFrames = nodeAnim.GetNearestKeyFrames(nodeAnim.pivotOffsetKeyFrames, this.modelAnimationPlayback.currentFrame, this.modelAnimationPlayback.animation.holdLastKeyFrame);
                    if (keyFrames != null) {
                        factor = this.modelAnimationPlayback.ComputeInterpolationFactor(keyFrames.previous.index, keyFrames.next.index);
                        pivotOffset.copy(keyFrames.previous.delta);
                        pivotOffset.lerp(keyFrames.next.delta, factor)
                    }
                    keyFrames = nodeAnim.GetNearestKeyFrames(nodeAnim.orientationKeyFrames, this.modelAnimationPlayback.currentFrame, this.modelAnimationPlayback.animation.holdLastKeyFrame);
                    if (keyFrames != null) {
                        factor = this.modelAnimationPlayback.ComputeInterpolationFactor(keyFrames.previous.index, keyFrames.next.index);
                        orientation.copy(keyFrames.previous.delta);
                        orientation.slerp(keyFrames.next.delta, factor)
                    }
                }
                position.add(node.position);
                pivotOffset.add(node.pivotOffset);
                orientation.multiplyQuaternions(node.orientation, orientation);
                origin = pivotOffset.applyQuaternion(orientation).add(position);
                selfMatrix = (new THREE.Matrix4).makeRotationFromQuaternion(orientation).setPosition(origin);
                matrix.multiplyMatrices(matrix, selfMatrix)
            }
            blockPosition = new THREE.Vector3;
            blockOrientation = new THREE.Quaternion;
            dummyScale = {};
            matrix.decompose(blockPosition, blockOrientation, dummyScale);
            return {
                position: blockPosition,
                orientation: blockOrientation
            }
        };
        ModelRenderer.prototype.Update = function (elapsedTime) {
            if (elapsedTime == null) {
                elapsedTime = 1 / 60
            }
            if (this.modelAnimationPlayback != null && this.model != null) {
                if (this.isAnimationPlaybackEnabled) {
                    this.modelAnimationPlayback.SetTime(this.modelAnimationPlayback.time + elapsedTime, false)
                }
                this.modelAnimationPlayback.SetupNodeTree(this.modelRoot.children[0], this.model.nodeTree)
            }
        };
        ModelRenderer.prototype.OnDestroy = function () {
            var material, texture;
            if (this.mesh != null) {
                this.mesh.geometry.dispose();
                this.mesh = null
            }
            if (this.material != null) {
                this.gameObject.gameInstance.assetTextureCache.ReleaseTexture(this.model.id);
                texture = null;
                this.material.dispose();
                material = null
            }
            this.modelRoot.parent.remove(this.modelRoot);
            this.modelRoot = null;
            this.model = null;
            this.modelAnimationPlayback = null;
            ModelRenderer.__super__.OnDestroy.call(this)
        };
        rootNodeIdentityMatrix = new THREE.Matrix4;
        ModelRenderer.BuildModelMesh = function (nodeTree, material) {
            var blockIndex, buildModelBranch, geometry, indices, nodeCount, normals, positions, rootNode, textureSize, uvs, _i, _len, _ref;
            textureSize = {
                width: material.uniforms.map.value.image.width,
                height: material.uniforms.map.value.image.height
            };
            nodeCount = Object.keys(nodeTree.nodesById).length;
            geometry = new THREE.BufferGeometry;
            geometry.dynamic = true;
            geometry.attributes = {
                index: {
                    itemSize: 1,
                    array: new Uint16Array(nodeCount * 3 * 2 * 6)
                },
                position: {
                    itemSize: 3,
                    array: new Float32Array(nodeCount * 4 * 3 * 6)
                },
                normal: {
                    itemSize: 3,
                    array: new Float32Array(nodeCount * 4 * 3 * 6)
                },
                uv: {
                    itemSize: 2,
                    array: new Float32Array(nodeCount * 4 * 2 * 6)
                }
            };
            geometry.offsets = [{
                start: 0,
                index: 0,
                count: nodeCount * 3 * 2 * 6
            }];
            indices = geometry.attributes.index.array;
            positions = geometry.attributes.position.array;
            normals = geometry.attributes.normal.array;
            uvs = geometry.attributes.uv.array;
            blockIndex = 0;
            buildModelBranch = function (_this) {
                return function (node, parentMatrix) {
                    var blockHalfSize, blockStartFaceIndex, child, faceIndex, origin, selfMatrix, _i, _j, _len, _ref;
                    blockStartFaceIndex = blockIndex * 6;
                    for (faceIndex = _i = 0; _i < 6; faceIndex = ++_i) {
                        indices[(blockStartFaceIndex + faceIndex) * 6 + 0] = (blockStartFaceIndex + faceIndex) * 4 + 0;
                        indices[(blockStartFaceIndex + faceIndex) * 6 + 1] = (blockStartFaceIndex + faceIndex) * 4 + 1;
                        indices[(blockStartFaceIndex + faceIndex) * 6 + 2] = (blockStartFaceIndex + faceIndex) * 4 + 2;
                        indices[(blockStartFaceIndex + faceIndex) * 6 + 3] = (blockStartFaceIndex + faceIndex) * 4 + 0;
                        indices[(blockStartFaceIndex + faceIndex) * 6 + 4] = (blockStartFaceIndex + faceIndex) * 4 + 2;
                        indices[(blockStartFaceIndex + faceIndex) * 6 + 5] = (blockStartFaceIndex + faceIndex) * 4 + 3
                    }
                    origin = node.pivotOffset.clone().applyQuaternion(node.orientation).add(node.position);
                    selfMatrix = (new THREE.Matrix4).makeRotationFromQuaternion(node.orientation).setPosition(origin);
                    selfMatrix.multiplyMatrices(parentMatrix, selfMatrix);
                    blockHalfSize = new THREE.Vector3(node.blockSize.x, node.blockSize.y, node.blockSize.z).multiplyScalar(CSPlayer.GlobalSizeMultiplier * .5);
                    _this.SetupBlock(positions, normals, blockStartFaceIndex, selfMatrix, blockHalfSize, node.scale);
                    _this.SetupQuadUVs(uvs, textureSize, blockIndex, node.blockSize, node.uvQuadOffsets, node.uvQuadTransforms);
                    blockIndex++;
                    _ref = node.children;
                    for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                        child = _ref[_j];
                        buildModelBranch(child, selfMatrix)
                    }
                }
            }(this);
            _ref = nodeTree.rootNodes;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                rootNode = _ref[_i];
                buildModelBranch(rootNode, rootNodeIdentityMatrix)
            }
            return new THREE.Mesh(geometry, material)
        };
        blockScaledMatrix = new THREE.Matrix4;
        normalMatrix = new THREE.Matrix4;
        rightTopFront = new THREE.Vector3;
        leftTopFront = new THREE.Vector3;
        leftBottomFront = new THREE.Vector3;
        rightBottomFront = new THREE.Vector3;
        leftTopBack = new THREE.Vector3;
        rightTopBack = new THREE.Vector3;
        rightBottomBack = new THREE.Vector3;
        leftBottomBack = new THREE.Vector3;
        frontNormal = new THREE.Vector3;
        backNormal = new THREE.Vector3;
        rightNormal = new THREE.Vector3;
        bottomNormal = new THREE.Vector3;
        leftNormal = new THREE.Vector3;
        topNormal = new THREE.Vector3;
        setupQuad = function (positions, normals, quadOffset, pos0, pos1, pos2, pos3, normal) {
            positions[quadOffset * 12 + 0 * 3 + 0] = pos0.x;
            positions[quadOffset * 12 + 0 * 3 + 1] = pos0.y;
            positions[quadOffset * 12 + 0 * 3 + 2] = pos0.z;
            positions[quadOffset * 12 + 1 * 3 + 0] = pos1.x;
            positions[quadOffset * 12 + 1 * 3 + 1] = pos1.y;
            positions[quadOffset * 12 + 1 * 3 + 2] = pos1.z;
            positions[quadOffset * 12 + 2 * 3 + 0] = pos2.x;
            positions[quadOffset * 12 + 2 * 3 + 1] = pos2.y;
            positions[quadOffset * 12 + 2 * 3 + 2] = pos2.z;
            positions[quadOffset * 12 + 3 * 3 + 0] = pos3.x;
            positions[quadOffset * 12 + 3 * 3 + 1] = pos3.y;
            positions[quadOffset * 12 + 3 * 3 + 2] = pos3.z;
            normals[quadOffset * 12 + 0 * 3 + 0] = normal.x;
            normals[quadOffset * 12 + 0 * 3 + 1] = normal.y;
            normals[quadOffset * 12 + 0 * 3 + 2] = normal.z;
            normals[quadOffset * 12 + 1 * 3 + 0] = normal.x;
            normals[quadOffset * 12 + 1 * 3 + 1] = normal.y;
            normals[quadOffset * 12 + 1 * 3 + 2] = normal.z;
            normals[quadOffset * 12 + 2 * 3 + 0] = normal.x;
            normals[quadOffset * 12 + 2 * 3 + 1] = normal.y;
            normals[quadOffset * 12 + 2 * 3 + 2] = normal.z;
            normals[quadOffset * 12 + 3 * 3 + 0] = normal.x;
            normals[quadOffset * 12 + 3 * 3 + 1] = normal.y;
            normals[quadOffset * 12 + 3 * 3 + 2] = normal.z
        };
        ModelRenderer.SetupBlock = function (positions, normals, offset, matrix, halfSize, scale) {
            blockScaledMatrix.makeScale(scale.x, scale.y, scale.z).multiplyMatrices(matrix, blockScaledMatrix);
            normalMatrix.getInverse(blockScaledMatrix).transpose();
            rightTopFront.set(halfSize.x, halfSize.y, halfSize.z).applyMatrix4(blockScaledMatrix);
            leftTopFront.set(-halfSize.x, halfSize.y, halfSize.z).applyMatrix4(blockScaledMatrix);
            leftBottomFront.set(-halfSize.x, -halfSize.y, halfSize.z).applyMatrix4(blockScaledMatrix);
            rightBottomFront.set(halfSize.x, -halfSize.y, halfSize.z).applyMatrix4(blockScaledMatrix);
            leftTopBack.set(-halfSize.x, halfSize.y, -halfSize.z).applyMatrix4(blockScaledMatrix);
            rightTopBack.set(halfSize.x, halfSize.y, -halfSize.z).applyMatrix4(blockScaledMatrix);
            rightBottomBack.set(halfSize.x, -halfSize.y, -halfSize.z).applyMatrix4(blockScaledMatrix);
            leftBottomBack.set(-halfSize.x, -halfSize.y, -halfSize.z).applyMatrix4(blockScaledMatrix);
            frontNormal.set(0, 0, 1).applyMatrix4(normalMatrix);
            backNormal.set(0, 0, -1).applyMatrix4(normalMatrix);
            rightNormal.set(1, 0, 0).applyMatrix4(normalMatrix);
            bottomNormal.set(0, -1, 0).applyMatrix4(normalMatrix);
            leftNormal.set(-1, 0, 0).applyMatrix4(normalMatrix);
            topNormal.set(0, 1, 0).applyMatrix4(normalMatrix);
            setupQuad(positions, normals, offset + 0, rightTopFront, leftTopFront, leftBottomFront, rightBottomFront, frontNormal);
            setupQuad(positions, normals, offset + 1, leftTopBack, rightTopBack, rightBottomBack, leftBottomBack, backNormal);
            setupQuad(positions, normals, offset + 2, rightTopBack, rightTopFront, rightBottomFront, rightBottomBack, rightNormal);
            setupQuad(positions, normals, offset + 3, rightBottomFront, leftBottomFront, leftBottomBack, rightBottomBack, bottomNormal);
            setupQuad(positions, normals, offset + 4, leftTopFront, leftTopBack, leftBottomBack, leftBottomFront, leftNormal);
            setupQuad(positions, normals, offset + 5, rightTopBack, leftTopBack, leftTopFront, rightTopFront, topNormal)
        };
        ModelRenderer.SetupQuadUVs = function (uvs, textureSize, blockIndex, blockSize, uvQuadOffsets, uvQuadTransforms) {
            var faceIndex, startOffset, _i;
            for (faceIndex = _i = 0; _i < 6; faceIndex = ++_i) {
                startOffset = 2 * (blockIndex * 6 + faceIndex) * 4;
                setupUVPoints(uvs, startOffset, faceIndex, uvQuadOffsets[faceIndex], blockSize);
                CSPlayer.BlockUVLayout.ApplyQuadUVTransform(uvs, startOffset, uvQuadOffsets[faceIndex], uvQuadTransforms[faceIndex]);
                uvs[startOffset + 0 * 2 + 0] /= textureSize.width;
                uvs[startOffset + 0 * 2 + 1] = 1 - uvs[startOffset + 0 * 2 + 1] / textureSize.height;
                uvs[startOffset + 1 * 2 + 0] /= textureSize.width;
                uvs[startOffset + 1 * 2 + 1] = 1 - uvs[startOffset + 1 * 2 + 1] / textureSize.height;
                uvs[startOffset + 2 * 2 + 0] /= textureSize.width;
                uvs[startOffset + 2 * 2 + 1] = 1 - uvs[startOffset + 2 * 2 + 1] / textureSize.height;
                uvs[startOffset + 3 * 2 + 0] /= textureSize.width;
                uvs[startOffset + 3 * 2 + 1] = 1 - uvs[startOffset + 3 * 2 + 1] / textureSize.height
            }
        };
        return ModelRenderer
    }(CSPlayer.ComponentInstances.Component);
    setupUVPoints = function (uvs, startOffset, faceIndex, uvOffset, blockSize) {
        var x, y;
        switch (faceIndex) {
        case 0:
        case 1:
            x = blockSize.x;
            y = blockSize.y;
            break;
        case 2:
        case 4:
            x = blockSize.z;
            y = blockSize.y;
            break;
        case 3:
        case 5:
            x = blockSize.x;
            y = blockSize.z
        }
        uvs[startOffset + 0 * 2 + 0] = uvOffset.x + x;
        uvs[startOffset + 0 * 2 + 1] = uvOffset.y;
        uvs[startOffset + 1 * 2 + 0] = uvOffset.x;
        uvs[startOffset + 1 * 2 + 1] = uvOffset.y;
        uvs[startOffset + 2 * 2 + 0] = uvOffset.x;
        uvs[startOffset + 2 * 2 + 1] = uvOffset.y + y;
        uvs[startOffset + 3 * 2 + 0] = uvOffset.x + x;
        uvs[startOffset + 3 * 2 + 1] = uvOffset.y + y
    }
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.ComponentInstances.MapRenderer = function (_super) {
        var mapInverseWorldMatrix;
        __extends(MapRenderer, _super);
        CSPlayer.ComponentInstances.Component.ComponentTypeMap[CSPlayer.ComponentType.MapRenderer] = MapRenderer;

        function MapRenderer(gameObject, component) {
            var map, tileSet;
            MapRenderer.__super__.constructor.call(this, gameObject, component.componentType);
            this.gameObject.luaSelf.str["mapRenderer"] = this.luaSelf;
            this.mapRoot = new THREE.Object3D;
            this.gameObject.transform.object.add(this.mapRoot);
            this.mapRoot.updateMatrixWorld();
            this.colorMod = new THREE.Vector4(1, 1, 1, component.opacity);
            this.mapChunkMeshes = {};
            if (component.mapId !== CSPlayer.UInt16MaxValue) {
                map = this.gameObject.gameInstance.gamePackage.assets[component.mapId];
                tileSet = this.gameObject.gameInstance.gamePackage.assets[map.tileSetId];
                this.SetMap(map);
                this.SetTileSet(tileSet)
            }
        }
        MapRenderer.prototype.SetOpacity = function (opacity) {
            this.colorMod.w = opacity;
            if (this.material != null) {
                this.material.visible = this.colorMod.w > 0
            }
        };
        MapRenderer.prototype.GetOpacity = function () {
            return this.colorMod.w
        };
        MapRenderer.prototype.SetMap = function (map) {
            var chunkLocation, chunkMesh, _ref;
            _ref = this.mapChunkMeshes;
            for (chunkLocation in _ref) {
                chunkMesh = _ref[chunkLocation];
                this.mapRoot.remove(chunkMesh);
                if (chunkMesh.geometry != null) {
                    chunkMesh.geometry.dispose()
                }
            }
            this.mapChunkMeshes = {};
            this.map = map
        };
        MapRenderer.prototype.SetTileSet = function (tileSet) {
            var chunkLocation, chunkMesh, _ref;
            if (this.material != null) {
                this.gameObject.gameInstance.assetTextureCache.ReleaseTexture(this.tileSet.id);
                this.texture = null;
                this.material.dispose();
                this.material = null
            }
            this.tileSet = tileSet;
            if (this.tileSet != null) {
                this.texture = this.gameObject.gameInstance.assetTextureCache.GetTexture(this.tileSet.id, this.tileSet.image);
                this.material = new THREE.ShaderMaterial({
                    vertexShader: CSPlayer.VertexShader,
                    fragmentShader: CSPlayer.FragmentShader,
                    uniforms: {
                        map: {
                            type: "t",
                            value: this.texture
                        },
                        colorMod: {
                            type: "v4",
                            value: this.colorMod
                        },
                        lightDiffuseColor: {
                            type: "v3",
                            value: new THREE.Vector3(.3, .3, .3)
                        },
                        ambientColor: {
                            type: "v3",
                            value: new THREE.Vector3(.7, .7, .7)
                        }
                    },
                    side: THREE.FrontSide,
                    transparent: true,
                    blending: THREE.CustomBlending,
                    blendEquation: THREE.AddEquation,
                    blendSrc: THREE.OneFactor,
                    blendDst: THREE.OneMinusSrcAlphaFactor
                });
                this.material.visible = this.colorMod.w > 0
            }
            _ref = this.mapChunkMeshes;
            for (chunkLocation in _ref) {
                chunkMesh = _ref[chunkLocation];
                this.mapRoot.remove(chunkMesh);
                if (chunkMesh.geometry != null) {
                    chunkMesh.geometry.dispose()
                }
            }
            this.mapChunkMeshes = {}
        };
        mapInverseWorldMatrix = new THREE.Matrix4;
        MapRenderer.prototype.GetCameraChunkLocations = function () {
            var camera, _i, _len, _ref, _results;
            mapInverseWorldMatrix.getInverse(this.gameObject.transform.object.matrixWorld);
            _ref = this.gameObject.gameInstance.activeCameras;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                camera = _ref[_i];
                _results.push(this.GetChunkLocationAtMapPosition(camera.gameObject.transform.GetGlobalPosition().applyMatrix4(mapInverseWorldMatrix)))
            }
            return _results
        };
        MapRenderer.prototype.GetChunkLocationAtMapPosition = function (position) {
            var translation;
            translation = position.clone().divideScalar(this.tileSet.tileSize * CSPlayer.GlobalSizeMultiplier).add({
                x: .5 * CSPlayer.MapChunk.ChunkWidth,
                y: .5 * CSPlayer.MapChunk.ChunkHeight,
                z: .5 * CSPlayer.MapChunk.ChunkDepth
            });
            return translation.set(Math.floor(Math.round(translation.x) / CSPlayer.MapChunk.ChunkWidth), Math.floor(Math.round(translation.y) / CSPlayer.MapChunk.ChunkHeight), Math.floor(Math.round(translation.z) / CSPlayer.MapChunk.ChunkDepth))
        };
        MapRenderer.prototype.MarkChunkDirty = function (chunkLocation) {
            var chunkLocationString, chunkMesh;
            chunkLocationString = chunkLocation.x + "_" + chunkLocation.y + "_" + chunkLocation.z;
            chunkMesh = this.mapChunkMeshes[chunkLocationString];
            if (chunkMesh != null) {
                chunkMesh.isDirty = true
            }
        };
        MapRenderer.prototype.WarmUp = function () {
            var cameraChunkLocations, chunk, chunkLocation, chunkLocationString, chunkMesh, _i, _len;
            if (this.tileSet == null) {
                return
            }
            cameraChunkLocations = this.GetCameraChunkLocations();
            for (_i = 0, _len = cameraChunkLocations.length; _i < _len; _i++) {
                chunkLocation = cameraChunkLocations[_i];
                chunkLocationString = chunkLocation.x + "_" + chunkLocation.y + "_" + chunkLocation.z;
                chunk = this.map.chunks[chunkLocationString];
                if (chunk != null) {
                    chunkMesh = CSPlayer.ComponentInstances.MapRenderer.BuildChunkMesh(chunk, chunkLocation, this.tileSet, this.material);
                    this.mapChunkMeshes[chunkLocationString] = chunkMesh;
                    this.mapRoot.add(chunkMesh);
                    chunkMesh.updateMatrixWorld()
                }
            }
        };
        MapRenderer.prototype.OnDestroy = function () {
            var texture;
            if (this.material != null) {
                this.gameObject.gameInstance.assetTextureCache.ReleaseTexture(this.tileSet.id);
                texture = null;
                this.material.dispose();
                this.material = null
            }
            this.mapRoot.parent.remove(this.mapRoot);
            this.mapRoot = null;
            this.map = null;
            MapRenderer.__super__.OnDestroy.call(this)
        };
        MapRenderer.BuildChunkMesh = function (chunk, chunkLocation, tileSet, material) {
            var blockLocation, blockType, bufChunkDivider, bufChunkSize, data, geometry, i, indices, mesh, offset, offsets, quads, textureSize, triangles, x, y, z, _i, _j, _k, _l, _m, _ref, _ref1, _ref2;
            textureSize = {
                width: material.uniforms.map.value.image.width,
                height: material.uniforms.map.value.image.height
            };
            data = {
                positions: [],
                normals: [],
                uvs: []
            };
            blockLocation = new THREE.Vector3;
            for (z = _i = 0, _ref = CSPlayer.MapChunk.ChunkDepth; 0 <= _ref ? _i < _ref : _i > _ref; z = 0 <= _ref ? ++_i : --_i) {
                for (y = _j = 0, _ref1 = CSPlayer.MapChunk.ChunkHeight; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
                    for (x = _k = 0, _ref2 = CSPlayer.MapChunk.ChunkWidth; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; x = 0 <= _ref2 ? ++_k : --_k) {
                        offset = z * CSPlayer.MapChunk.ChunkWidth * CSPlayer.MapChunk.ChunkHeight + y * CSPlayer.MapChunk.ChunkWidth + x;
                        blockType = chunk.blockIDs[offset];
                        if (blockType !== CSPlayer.UInt8MaxValue) {
                            blockLocation.set((-.5 * CSPlayer.MapChunk.ChunkWidth + x) * tileSet.tileSize * CSPlayer.GlobalSizeMultiplier, (-.5 * CSPlayer.MapChunk.ChunkHeight + y) * tileSet.tileSize * CSPlayer.GlobalSizeMultiplier, (-.5 * CSPlayer.MapChunk.ChunkDepth + z) * tileSet.tileSize * CSPlayer.GlobalSizeMultiplier);
                            CSPlayer.MapGeometryGenerator.AppendBlock(data, blockLocation, tileSet.blockTypes[blockType], tileSet.tileSize, textureSize, chunk.blockOrientations[offset])
                        }
                    }
                }
            }
            if (data.positions.length === 0) {
                mesh = new THREE.Object3D
            } else {
                quads = data.positions.length / 12;
                triangles = quads * 2;
                bufChunkDivider = 6;
                bufChunkSize = Math.floor((CSPlayer.UInt16MaxValue + 1) / bufChunkDivider);
                geometry = new THREE.BufferGeometry;
                geometry.dynamic = false;
                geometry.attributes = {
                    index: {
                        itemSize: 1,
                        array: new Uint16Array(triangles * 3)
                    },
                    position: {
                        itemSize: 3,
                        array: new Float32Array(data.positions)
                    },
                    normal: {
                        itemSize: 3,
                        array: new Float32Array(data.normals)
                    },
                    uv: {
                        itemSize: 2,
                        array: new Float32Array(data.uvs)
                    }
                };
                indices = geometry.attributes.index.array;
                for (i = _l = 0; 0 <= quads ? _l < quads : _l > quads; i = 0 <= quads ? ++_l : --_l) {
                    indices[i * 6 + 0] = (i * 4 + 0) % (bufChunkSize * bufChunkDivider);
                    indices[i * 6 + 1] = (i * 4 + 1) % (bufChunkSize * bufChunkDivider);
                    indices[i * 6 + 2] = (i * 4 + 2) % (bufChunkSize * bufChunkDivider);
                    indices[i * 6 + 3] = (i * 4 + 0) % (bufChunkSize * bufChunkDivider);
                    indices[i * 6 + 4] = (i * 4 + 2) % (bufChunkSize * bufChunkDivider);
                    indices[i * 6 + 5] = (i * 4 + 3) % (bufChunkSize * bufChunkDivider)
                }
                geometry.offsets = [];
                offsets = triangles * 3 / (bufChunkSize * bufChunkDivider / 4 * 6);
                for (i = _m = 0; 0 <= offsets ? _m < offsets : _m > offsets; i = 0 <= offsets ? ++_m : --_m) {
                    offset = {
                        index: i * bufChunkSize * bufChunkDivider,
                        start: i * bufChunkSize * bufChunkDivider / 4 * 6,
                        count: Math.min(bufChunkSize * bufChunkDivider / 4 * 6, triangles * 3 - i * bufChunkSize * bufChunkDivider / 4 * 6)
                    };
                    geometry.offsets.push(offset)
                }
                geometry.computeBoundingSphere();
                mesh = new THREE.Mesh(geometry, material)
            }
            mesh.position.set(chunkLocation.x * CSPlayer.MapChunk.ChunkWidth * tileSet.tileSize * CSPlayer.GlobalSizeMultiplier, chunkLocation.y * CSPlayer.MapChunk.ChunkHeight * tileSet.tileSize * CSPlayer.GlobalSizeMultiplier, chunkLocation.z * CSPlayer.MapChunk.ChunkDepth * tileSet.tileSize * CSPlayer.GlobalSizeMultiplier);
            return mesh
        };
        MapRenderer.prototype.Update = function () {
            var cameraChunkLocation, cameraChunkLocations, chunk, chunkLocationString, chunkMesh, offset, shouldRender, _i, _len, _ref;
            if (this.tileSet == null) {
                return
            }
            cameraChunkLocations = this.GetCameraChunkLocations();
            _ref = this.map.chunks;
            for (chunkLocationString in _ref) {
                chunk = _ref[chunkLocationString];
                shouldRender = false;
                for (_i = 0, _len = cameraChunkLocations.length; _i < _len; _i++) {
                    cameraChunkLocation = cameraChunkLocations[_i];
                    offset = chunk.location.clone().sub(cameraChunkLocation);
                    if (Math.abs(offset.x) <= 4 && Math.abs(offset.y) <= 4 && Math.abs(offset.z) <= 4) {
                        shouldRender = true;
                        break
                    }
                }
                chunkMesh = this.mapChunkMeshes[chunkLocationString];
                if (chunkMesh != null && (!shouldRender || chunkMesh.isDirty)) {
                    this.mapRoot.remove(chunkMesh);
                    if (chunkMesh.geometry != null) {
                        chunkMesh.geometry.dispose()
                    }
                    delete this.mapChunkMeshes[chunkLocationString];
                    chunkMesh = null
                }
                if (chunkMesh == null && shouldRender) {
                    chunkMesh = CSPlayer.ComponentInstances.MapRenderer.BuildChunkMesh(chunk, chunk.location, this.tileSet, this.material);
                    this.mapChunkMeshes[chunkLocationString] = chunkMesh;
                    this.mapRoot.add(chunkMesh);
                    chunkMesh.updateMatrixWorld()
                }
            }
        };
        return MapRenderer
    }(CSPlayer.ComponentInstances.Component)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.ComponentInstances.TextRenderer = function (_super) {
        __extends(TextRenderer, _super);
        CSPlayer.ComponentInstances.Component.ComponentTypeMap[CSPlayer.ComponentType.TextRenderer] = TextRenderer;
        TextRenderer.TextAlignment = {
            Left: 0,
            Center: 1,
            Right: 2
        };

        function TextRenderer(gameObject, component) {
            TextRenderer.__super__.constructor.call(this, gameObject, component.componentType);
            this.gameObject.luaSelf.str["textRenderer"] = this.luaSelf;
            this.textRoot = new THREE.Object3D;
            this.gameObject.transform.object.add(this.textRoot);
            this.colorMod = new THREE.Vector4(1, 1, 1, component.opacity);
            this.text = component.text;
            this.textWidth = 0;
            this.alignment = component.alignment;
            if (component.fontId !== CSPlayer.UInt16MaxValue) {
                this.SetFont(this.gameObject.gameInstance.gamePackage.assets[component.fontId])
            }
        }
        TextRenderer.prototype.GetTextWidth = function (text) {
            if (text == null) {
                this.Undirty();
                return this.textWidth
            }
            return this.MeasureText(text)
        };
        TextRenderer.prototype.MeasureText = function (text) {
            var charIndex, charInfo, charWidth, charactersByRow, i, letters, textWidth, value, _i, _ref, _ref1;
            textWidth = 0;
            charactersByRow = Math.floor(this.material.uniforms.map.value.image.width / this.font.baseCharacterWidth);
            letters = text.length;
            for (i = _i = 0; 0 <= letters ? _i < letters : _i > letters; i = 0 <= letters ? ++_i : --_i) {
                value = text.charCodeAt(i);
                _ref = this.FindCharacterIndex(value), charIndex = _ref[0], charInfo = _ref[1];
                if (charIndex === CSPlayer.UInt32MaxValue) {
                    value = 127;
                    _ref1 = this.FindCharacterIndex(value), charIndex = _ref1[0], charInfo = _ref1[1]
                }
                charWidth = (charInfo.endOffset !== 0 ? charInfo.endOffset : this.font.baseCharacterWidth) - charInfo.startOffset;
                textWidth += charWidth
            }
            return textWidth
        };
        TextRenderer.prototype.SetAlignment = function (alignment) {
            this.alignment = alignment;
            if (this.mesh != null) {
                this.mesh.position.set(-this.textWidth / 2 * CSPlayer.GlobalSizeMultiplier + this.GetAlignmentOffset(), 0, 0);
                return this.mesh.updateMatrixWorld()
            }
        };
        TextRenderer.prototype.SetOpacity = function (opacity) {
            this.colorMod.w = opacity;
            if (this.material != null) {
                return this.material.visible = this.colorMod.w > 0
            }
        };
        TextRenderer.prototype.GetOpacity = function () {
            return this.colorMod.w
        };
        TextRenderer.prototype.SetFont = function (font) {
            if (this.font != null) {
                if (this.material != null) {
                    this.gameObject.gameInstance.assetTextureCache.ReleaseTexture(this.font.id);
                    this.texture = null;
                    this.material.dispose();
                    this.material = null
                }
            }
            this.font = font;
            if (this.font == null) {
                return
            }
            this.texture = this.gameObject.gameInstance.assetTextureCache.GetTexture(this.font.id, this.font.image);
            this.material = new THREE.ShaderMaterial({
                vertexShader: CSPlayer.VertexShader,
                fragmentShader: CSPlayer.FragmentShader,
                uniforms: {
                    map: {
                        type: "t",
                        value: this.texture
                    },
                    colorMod: {
                        type: "v4",
                        value: this.colorMod
                    },
                    lightDiffuseColor: {
                        type: "v3",
                        value: new THREE.Vector3(.3, .3, .3)
                    },
                    ambientColor: {
                        type: "v3",
                        value: new THREE.Vector3(.7, .7, .7)
                    }
                },
                side: THREE.DoubleSide,
                transparent: true,
                blending: THREE.CustomBlending,
                blendEquation: THREE.AddEquation,
                blendSrc: THREE.OneFactor,
                blendDst: THREE.OneMinusSrcAlphaFactor
            });
            this.material.visible = this.colorMod.w > 0;
            this.gameObject.gameInstance.MarkDirtyRenderer(this)
        };
        TextRenderer.prototype.SetText = function (text) {
            this.text = text;
            this.gameObject.gameInstance.MarkDirtyRenderer(this)
        };
        TextRenderer.prototype.Undirty = function () {
            var charIndex, charInfo, charWidth, charactersByRow, geometry, halfHeight, i, indices, letters, normals, positions, textureSize, uv, value, x, _i, _ref, _ref1;
            if (!this.dirty) {
                return
            }
            this.dirty = false;
            if (this.mesh != null) {
                this.mesh.geometry.dispose();
                this.textRoot.remove(this.mesh);
                this.mesh = null
            }
            this.textWidth = 0;
            if (this.font == null || this.text == null) {
                return
            }
            textureSize = {
                width: this.material.uniforms.map.value.image.width,
                height: this.material.uniforms.map.value.image.height
            };
            charactersByRow = Math.floor(textureSize.width / this.font.baseCharacterWidth);
            halfHeight = this.font.baseCharacterHeight * CSPlayer.GlobalSizeMultiplier * .5;
            letters = this.text.length;
            geometry = new THREE.BufferGeometry;
            geometry.dynamic = true;
            geometry.attributes = {
                index: {
                    itemSize: 1,
                    array: new Uint16Array(letters * 3 * 2)
                },
                position: {
                    itemSize: 3,
                    array: new Float32Array(letters * 4 * 3)
                },
                normal: {
                    itemSize: 3,
                    array: new Float32Array(letters * 4 * 3)
                },
                uv: {
                    itemSize: 2,
                    array: new Float32Array(letters * 4 * 2)
                }
            };
            geometry.offsets = [{
                start: 0,
                index: 0,
                count: letters * 3 * 2
            }];
            indices = geometry.attributes.index.array;
            positions = geometry.attributes.position.array;
            normals = geometry.attributes.normal.array;
            uv = geometry.attributes.uv.array;
            for (i = _i = 0; 0 <= letters ? _i < letters : _i > letters; i = 0 <= letters ? ++_i : --_i) {
                value = this.text.charCodeAt(i);
                _ref = this.FindCharacterIndex(value), charIndex = _ref[0], charInfo = _ref[1];
                if (charIndex === CSPlayer.UInt32MaxValue) {
                    value = 127;
                    _ref1 = this.FindCharacterIndex(value), charIndex = _ref1[0], charInfo = _ref1[1]
                }
                charWidth = (charInfo.endOffset !== 0 ? charInfo.endOffset : this.font.baseCharacterWidth) - charInfo.startOffset;
                x = this.textWidth;
                positions[(i * 4 + 0) * 3 + 0] = (x - charInfo.startOffset) * CSPlayer.GlobalSizeMultiplier;
                positions[(i * 4 + 0) * 3 + 1] = halfHeight;
                positions[(i * 4 + 0) * 3 + 2] = 0;
                normals[(i * 4 + 0) * 3 + 0] = 0;
                normals[(i * 4 + 0) * 3 + 1] = 0;
                normals[(i * 4 + 0) * 3 + 2] = 1;
                uv[(i * 4 + 0) * 2 + 0] = charIndex % charactersByRow * this.font.baseCharacterWidth / textureSize.width;
                uv[(i * 4 + 0) * 2 + 1] = 1 - Math.floor(charIndex / charactersByRow) * this.font.baseCharacterHeight / textureSize.height;
                positions[(i * 4 + 1) * 3 + 0] = (x - charInfo.startOffset + this.font.baseCharacterWidth) * CSPlayer.GlobalSizeMultiplier;
                positions[(i * 4 + 1) * 3 + 1] = halfHeight;
                positions[(i * 4 + 1) * 3 + 2] = 0;
                normals[(i * 4 + 1) * 3 + 0] = 0;
                normals[(i * 4 + 1) * 3 + 1] = 0;
                normals[(i * 4 + 1) * 3 + 2] = 1;
                uv[(i * 4 + 1) * 2 + 0] = (charIndex % charactersByRow * this.font.baseCharacterWidth + this.font.baseCharacterWidth) / textureSize.width;
                uv[(i * 4 + 1) * 2 + 1] = 1 - Math.floor(charIndex / charactersByRow) * this.font.baseCharacterHeight / textureSize.height;
                positions[(i * 4 + 2) * 3 + 0] = (x - charInfo.startOffset) * CSPlayer.GlobalSizeMultiplier;
                positions[(i * 4 + 2) * 3 + 1] = -halfHeight;
                positions[(i * 4 + 2) * 3 + 2] = 0;
                normals[(i * 4 + 2) * 3 + 0] = 0;
                normals[(i * 4 + 2) * 3 + 1] = 0;
                normals[(i * 4 + 2) * 3 + 2] = 1;
                uv[(i * 4 + 2) * 2 + 0] = charIndex % charactersByRow * this.font.baseCharacterWidth / textureSize.width;
                uv[(i * 4 + 2) * 2 + 1] = 1 - Math.floor(charIndex / charactersByRow + 1) * this.font.baseCharacterHeight / textureSize.height;
                positions[(i * 4 + 3) * 3 + 0] = (x - charInfo.startOffset + this.font.baseCharacterWidth) * CSPlayer.GlobalSizeMultiplier;
                positions[(i * 4 + 3) * 3 + 1] = -halfHeight;
                positions[(i * 4 + 3) * 3 + 2] = 0;
                normals[(i * 4 + 3) * 3 + 0] = 0;
                normals[(i * 4 + 3) * 3 + 1] = 0;
                normals[(i * 4 + 3) * 3 + 2] = 1;
                uv[(i * 4 + 3) * 2 + 0] = (charIndex % charactersByRow * this.font.baseCharacterWidth + this.font.baseCharacterWidth) / textureSize.width;
                uv[(i * 4 + 3) * 2 + 1] = 1 - Math.floor(charIndex / charactersByRow + 1) * this.font.baseCharacterHeight / textureSize.height;
                indices[i * 6 + 0] = i * 4 + 0;
                indices[i * 6 + 1] = i * 4 + 1;
                indices[i * 6 + 2] = i * 4 + 2;
                indices[i * 6 + 3] = i * 4 + 1;
                indices[i * 6 + 4] = i * 4 + 2;
                indices[i * 6 + 5] = i * 4 + 3;
                this.textWidth += charWidth
            }
            this.mesh = new THREE.Mesh(geometry, this.material);
            this.mesh.position.set(-this.textWidth / 2 * CSPlayer.GlobalSizeMultiplier + this.GetAlignmentOffset(), 0, 0);
            this.textRoot.add(this.mesh);
            this.textRoot.updateMatrixWorld()
        };
        TextRenderer.prototype.FindCharacterIndex = function (charValue) {
            var charIndex, charInfo, charRange, _i, _len, _ref;
            charIndex = 0;
            _ref = this.font.characterRanges;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                charRange = _ref[_i];
                if (charRange.startCharacter <= charValue && charRange.endCharacter >= charValue) {
                    charInfo = charRange.characterInfos[charValue - charRange.startCharacter];
                    return [charIndex + (charValue - charRange.startCharacter), charInfo]
                }
                charIndex += charRange.characterInfos.length
            }
            return [CSPlayer.UInt32MaxValue, null]
        };
        TextRenderer.prototype.GetAlignmentOffset = function () {
            switch (this.alignment) {
            case CSPlayer.ComponentInstances.TextRenderer.TextAlignment.Left:
                return this.textWidth / 2 * CSPlayer.GlobalSizeMultiplier;
            case CSPlayer.ComponentInstances.TextRenderer.TextAlignment.Right:
                return -this.textWidth / 2 * CSPlayer.GlobalSizeMultiplier;
            default:
                return 0
            }
        };
        TextRenderer.prototype.OnDestroy = function () {
            var material, texture;
            if (this.mesh != null) {
                this.mesh.geometry.dispose();
                this.mesh = null
            }
            if (this.material != null) {
                this.gameObject.gameInstance.assetTextureCache.ReleaseTexture(this.font.id);
                texture = null;
                this.material.dispose();
                material = null
            }
            this.textRoot.parent.remove(this.textRoot);
            this.textRoot = null;
            this.font = null;
            TextRenderer.__super__.OnDestroy.call(this)
        };
        TextRenderer.prototype.Update = function () {};
        return TextRenderer
    }(CSPlayer.ComponentInstances.Component)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.ComponentInstances.ScriptedBehavior = function (_super) {
        __extends(ScriptedBehavior, _super);
        CSPlayer.ComponentInstances.Component.ComponentTypeMap[CSPlayer.ComponentType.ScriptedBehavior] = ScriptedBehavior;

        function ScriptedBehavior(gameObject, component) {
            var luaScript;
            this.component = component;
            ScriptedBehavior.__super__.constructor.call(this, gameObject, this.component.componentType, false);
            luaScript = this.gameObject.gameInstance.scriptAPI.luaAssets[this.component.scriptId];
            this.luaSelf = this.gameObject.gameInstance.scriptAPI.luaComponentNews[this.component.componentType](null, this, this.gameObject.luaSelf, luaScript)[0];
            if (luaScript != null) {
                this.SetupScriptProperties(luaScript.str["inner"].scriptProperties);
                this.awakeFunc = luaScript.str["Awake"];
                this.startFunc = luaScript.str["Start"];
                this.updateFunc = luaScript.str["Update"]
            }
        }
        ScriptedBehavior.prototype.SetupScriptProperties = function (properties) {
            var property, useDefaultValue, value, _i, _len;
            for (_i = 0, _len = properties.length; _i < _len; _i++) {
                property = properties[_i];
                value = this.component.scriptPropertyValuesById[property.id];
                useDefaultValue = value == null;
                switch (property.propertyType) {
                case CSPlayer.ScriptProperty.ScriptPropertyType.Boolean:
                    this.luaSelf.str[property.name] = useDefaultValue ? property.defaultValue.booleanValue : value.booleanValue;
                    break;
                case CSPlayer.ScriptProperty.ScriptPropertyType.Number:
                    this.luaSelf.str[property.name] = useDefaultValue ? property.defaultValue.numberValue : value.numberValue;
                    break;
                case CSPlayer.ScriptProperty.ScriptPropertyType.String:
                    this.luaSelf.str[property.name] = useDefaultValue ? property.defaultValue.stringValue : value.stringValue
                }
            }
        };
        ScriptedBehavior.prototype.Awake = function () {
            if (this.awakeFunc != null) {
                this.awakeFunc(this.luaSelf)
            }
        };
        ScriptedBehavior.prototype.Start = function () {
            if (this.startFunc != null) {
                this.startFunc(this.luaSelf)
            }
        };
        ScriptedBehavior.prototype.Update = function () {
            if (this.updateFunc != null) {
                this.updateFunc(this.luaSelf)
            }
        };
        ScriptedBehavior.prototype.OnDestroy = function () {
            this.awakeFunc = null;
            this.startFunc = null;
            this.updateFunc = null;
            if (this.luaSelf !== null) {
                ScriptedBehavior.__super__.OnDestroy.call(this)
            }
        };
        return ScriptedBehavior
    }(CSPlayer.ComponentInstances.Component)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.ComponentInstances.Physics = function (_super) {
        __extends(Physics, _super);
        CSPlayer.ComponentInstances.Component.ComponentTypeMap[CSPlayer.ComponentType.Physics] = Physics;

        function Physics(gameObject, component) {
            Physics.__super__.constructor.call(this, gameObject, component.componentType);
            this.gameObject.luaSelf.str["physics"] = this.luaSelf
        }
        Physics.prototype.Update = function () {};
        return Physics
    }(CSPlayer.ComponentInstances.Component)
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.ComponentInstances.NetworkSync = function (_super) {
        __extends(NetworkSync, _super);
        CSPlayer.ComponentInstances.Component.ComponentTypeMap[CSPlayer.ComponentType.NetworkSync] = NetworkSync;

        function NetworkSync(gameObject, component) {
            NetworkSync.__super__.constructor.call(this, gameObject, component.componentType);
            this.gameObject.luaSelf.str["networkSync"] = this.luaSelf;
            this.syncId = CSPlayer.UInt32MaxValue
        }
        NetworkSync.prototype.OnDestroy = function () {
            if (this.syncId !== CSPlayer.UInt32MaxValue) {
                this.gameObject.gameInstance.UnregisterNetworkSync(this.syncId);
                this.syncId = CSPlayer.UInt32MaxValue
            }
            return NetworkSync.__super__.OnDestroy.call(this)
        };
        NetworkSync.prototype.Update = function () {};
        return NetworkSync
    }(CSPlayer.ComponentInstances.Component)
}).call(this);
(function () {
    CSPlayer.TextureCache = function () {
        function TextureCache() {
            this.texturesById = {}
        }
        TextureCache.prototype.IsEmpty = function () {
            return Object.keys(this.texturesById).length === 0
        };
        TextureCache.prototype.GetTexture = function (id, image) {
            var texEntry, texture;
            texEntry = this.texturesById[id];
            if (texEntry == null) {
                texture = new THREE.Texture(image, void 0, void 0, void 0, THREE.NearestFilter, THREE.NearestFilter, void 0, void 0, 0);
                texture.needsUpdate = true;
                texEntry = {
                    users: 1,
                    texture: texture
                };
                this.texturesById[id] = texEntry
            } else {
                texEntry.users++
            }
            return texEntry.texture
        };
        TextureCache.prototype.ReleaseTexture = function (id) {
            var texEntry;
            texEntry = this.texturesById[id];
            texEntry.users--;
            if (texEntry.users === 0) {
                texEntry.texture.dispose();
                return delete this.texturesById[id]
            }
        };
        return TextureCache
    }()
}).call(this);
(function () {
    CSPlayer.ModelAnimationPlayback = function () {
        var blockHalfSize, blockSize, orientation, pivotOffset, position, scale;
        ModelAnimationPlayback.FrameDuration = 1 / 30;

        function ModelAnimationPlayback(animation) {
            this.animation = animation;
            this.time = 0;
            this.currentFrame = 0;
            this.looping = true;
            this.isOver = false;
            this.duration = this.animation.duration * CSPlayer.ModelAnimationPlayback.FrameDuration
        }
        ModelAnimationPlayback.prototype.SetTime = function (time, clamp) {
            if (clamp == null) {
                clamp = false
            }
            this.isOver = false;
            if (this.looping) {
                this.time = time;
                if (clamp) {
                    this.time = Math.max(0, Math.min(this.time, this.duration))
                } else {
                    if (this.time < 0) {
                        this.time += (-this.time / this.duration | 0 + 1) * this.duration
                    }
                    this.time %= this.duration
                }
            } else if (time < this.duration) {
                this.time = Math.max(0, time)
            } else {
                this.time = this.duration;
                this.currentFrame = this.animation.duration;
                this.isOver = true
            } if (!this.isOver) {
                this.currentFrame = this.time / CSPlayer.ModelAnimationPlayback.FrameDuration | 0
            }
        };
        ModelAnimationPlayback.prototype.IsAnimationPlaying = function () {
            return this.looping || !this.isOver
        };
        ModelAnimationPlayback.prototype.SetCurrentFrame = function (frame) {
            this.currentFrame = frame % (this.animation.duration + 1) | 0;
            this.time = this.currentFrame * CSPlayer.ModelAnimationPlayback.FrameDuration;
            this.isOver = this.currentFrame < this.animation.duration
        };
        ModelAnimationPlayback.prototype.GetFrameTimer = function () {
            return this.time / CSPlayer.ModelAnimationPlayback.FrameDuration - this.currentFrame
        };
        ModelAnimationPlayback.prototype.SetLoop = function (looping) {
            this.looping = looping;
            if (this.looping) {
                this.isOver = false
            }
        };
        position = new THREE.Vector3;
        pivotOffset = new THREE.Vector3;
        blockSize = new THREE.Vector3;
        orientation = new THREE.Quaternion;
        scale = new THREE.Vector3;
        blockHalfSize = new THREE.Vector3;
        ModelAnimationPlayback.prototype.SetupNodeTree = function (mesh, nodeTree, forceUvsUpdate) {
            var blockIndex, matrix, node, normals, positions, setupNodeBranch, textureSize, uvs, uvsNeedUpdate, _i, _len, _ref;
            if (forceUvsUpdate == null) {
                forceUvsUpdate = false
            }
            blockIndex = 0;
            positions = mesh.geometry.attributes.position.array;
            mesh.geometry.attributes.position.needsUpdate = true;
            normals = mesh.geometry.attributes.normal.array;
            mesh.geometry.attributes.normal.needsUpdate = true;
            uvs = mesh.geometry.attributes.uv.array;
            uvsNeedUpdate = forceUvsUpdate;
            textureSize = {
                width: mesh.material.uniforms.map.value.image.width,
                height: mesh.material.uniforms.map.value.image.height
            };
            setupNodeBranch = function (_this) {
                return function (node, parentMatrix) {
                    var child, factor, hasBlockSizeKeyFrames, keyFrames, nodeAnim, origin, selfMatrix, _i, _len, _ref;
                    nodeAnim = _this.animation.nodeAnimsByNodeName[node.name];
                    position.set(0, 0, 0);
                    pivotOffset.set(0, 0, 0);
                    blockSize.set(0, 0, 0);
                    orientation.set(0, 0, 0, 1);
                    scale.set(0, 0, 0);
                    if (nodeAnim != null) {
                        keyFrames = nodeAnim.GetNearestKeyFrames(nodeAnim.positionKeyFrames, _this.currentFrame, _this.animation.holdLastKeyFrame);
                        if (keyFrames != null) {
                            factor = _this.ComputeInterpolationFactor(keyFrames.previous.index, keyFrames.next.index);
                            position.copy(keyFrames.previous.delta);
                            position.lerp(keyFrames.next.delta, factor)
                        }
                        keyFrames = nodeAnim.GetNearestKeyFrames(nodeAnim.pivotOffsetKeyFrames, _this.currentFrame, _this.animation.holdLastKeyFrame);
                        if (keyFrames != null) {
                            factor = _this.ComputeInterpolationFactor(keyFrames.previous.index, keyFrames.next.index);
                            pivotOffset.copy(keyFrames.previous.delta);
                            pivotOffset.lerp(keyFrames.next.delta, factor)
                        }
                        keyFrames = nodeAnim.GetNearestKeyFrames(nodeAnim.blockSizeKeyFrames, _this.currentFrame, _this.animation.holdLastKeyFrame);
                        hasBlockSizeKeyFrames = keyFrames != null;
                        if (hasBlockSizeKeyFrames) {
                            uvsNeedUpdate = true;
                            blockSize.copy(keyFrames.previous.delta)
                        }
                        keyFrames = nodeAnim.GetNearestKeyFrames(nodeAnim.orientationKeyFrames, _this.currentFrame, _this.animation.holdLastKeyFrame);
                        if (keyFrames != null) {
                            factor = _this.ComputeInterpolationFactor(keyFrames.previous.index, keyFrames.next.index);
                            orientation.copy(keyFrames.previous.delta);
                            orientation.slerp(keyFrames.next.delta, factor)
                        }
                        keyFrames = nodeAnim.GetNearestKeyFrames(nodeAnim.scaleKeyFrames, _this.currentFrame, _this.animation.holdLastKeyFrame);
                        if (keyFrames != null) {
                            factor = _this.ComputeInterpolationFactor(keyFrames.previous.index, keyFrames.next.index);
                            scale.copy(keyFrames.previous.delta);
                            scale.lerp(keyFrames.next.delta, factor)
                        }
                    }
                    position.add(node.position);
                    pivotOffset.add(node.pivotOffset);
                    blockSize.add(node.blockSize);
                    orientation.multiplyQuaternions(node.orientation, orientation);
                    scale.add(node.scale);
                    origin = pivotOffset.applyQuaternion(orientation).add(position);
                    selfMatrix = (new THREE.Matrix4).makeRotationFromQuaternion(orientation).setPosition(origin);
                    selfMatrix.multiplyMatrices(parentMatrix, selfMatrix);
                    blockHalfSize.copy(blockSize).multiplyScalar(CSPlayer.GlobalSizeMultiplier * .5);
                    CSPlayer.ComponentInstances.ModelRenderer.SetupBlock(positions, normals, blockIndex * 6, selfMatrix, blockHalfSize, scale);
                    if (hasBlockSizeKeyFrames || forceUvsUpdate) {
                        CSPlayer.ComponentInstances.ModelRenderer.SetupQuadUVs(uvs, textureSize, blockIndex, blockSize, node.uvQuadOffsets, node.uvQuadTransforms)
                    }
                    blockIndex++;
                    _ref = node.children;
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        child = _ref[_i];
                        setupNodeBranch(child, selfMatrix)
                    }
                }
            }(this);
            matrix = new THREE.Matrix4;
            _ref = nodeTree.rootNodes;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                node = _ref[_i];
                setupNodeBranch(node, matrix)
            }
            mesh.geometry.attributes.uv.needsUpdate = uvsNeedUpdate
        };
        ModelAnimationPlayback.prototype.ComputeInterpolationFactor = function (previousIndex, nextIndex) {
            var factor, length, time;
            factor = 0;
            time = this.time;
            if (nextIndex % this.animation.duration !== previousIndex % this.animation.duration || nextIndex > previousIndex) {
                length = nextIndex - previousIndex;
                if (length < 0) {
                    length += this.animation.duration
                }
                length *= CSPlayer.ModelAnimationPlayback.FrameDuration;
                if (this.currentFrame < previousIndex) {
                    time += this.animation.duration * CSPlayer.ModelAnimationPlayback.FrameDuration
                }
                factor = (time - previousIndex * CSPlayer.ModelAnimationPlayback.FrameDuration) / length
            }
            return factor
        };
        return ModelAnimationPlayback
    }()
}).call(this);
(function () {
    var getNormalizedUVQuad, getQuadUV, getUVCenter, getUVPoints, setupBlock;
    CSPlayer.MapGeometryGenerator = function () {
        var rotationMatrix;

        function MapGeometryGenerator() {}
        rotationMatrix = new THREE.Matrix4;
        MapGeometryGenerator.AppendBlock = function (data, blockLocation, blockType, tileSize, textureSize, blockOrientation) {
            var backNormal, bottomNormal, faceCount, faceIndex, faceUvs, frontNormal, halfSize, leftBottomBack, leftBottomFront, leftNormal, leftTopBack, leftTopFront, offset, rightBottomBack, rightBottomFront, rightNormal, rightTopBack, rightTopFront, topNormal, _i;
            offset = data.positions.length / 3;
            faceCount = CSPlayer.TileSet.QuadsPerShape[blockType.shape];
            switch (blockType.shape) {
            case CSPlayer.TileSet.BlockShape.Cube:
            case CSPlayer.TileSet.BlockShape.HorizontalSlab:
            case CSPlayer.TileSet.BlockShape.Pane:
                0;
                break;
            default:
                return
            }
            for (faceIndex = _i = 0; 0 <= faceCount ? _i < faceCount : _i > faceCount; faceIndex = 0 <= faceCount ? ++_i : --_i) {
                faceUvs = getQuadUV(faceIndex, blockType, tileSize, textureSize);
                data.uvs.push(faceUvs[0].x, faceUvs[0].y, faceUvs[1].x, faceUvs[1].y, faceUvs[2].x, faceUvs[2].y, faceUvs[3].x, faceUvs[3].y)
            }
            switch (blockOrientation) {
            case CSPlayer.Map.BlockOrientation.North:
                rotationMatrix.identity();
                break;
            case CSPlayer.Map.BlockOrientation.East:
                rotationMatrix.makeRotationY(Math.PI / 2);
                break;
            case CSPlayer.Map.BlockOrientation.South:
                rotationMatrix.makeRotationY(Math.PI);
                break;
            case CSPlayer.Map.BlockOrientation.West:
                rotationMatrix.makeRotationY(-Math.PI / 2);
                break;
            default:
                throw new Error("Unsupported orientation")
            }
            halfSize = new THREE.Vector3(tileSize, tileSize, tileSize).multiplyScalar(CSPlayer.GlobalSizeMultiplier * .5);
            switch (blockType.shape) {
            case CSPlayer.TileSet.BlockShape.Cube:
                leftTopBack = new THREE.Vector3(-halfSize.x, halfSize.y, -halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                rightTopBack = new THREE.Vector3(halfSize.x, halfSize.y, -halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                rightBottomBack = new THREE.Vector3(halfSize.x, -halfSize.y, -halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                leftBottomBack = new THREE.Vector3(-halfSize.x, -halfSize.y, -halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                rightTopFront = new THREE.Vector3(halfSize.x, halfSize.y, halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                leftTopFront = new THREE.Vector3(-halfSize.x, halfSize.y, halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                leftBottomFront = new THREE.Vector3(-halfSize.x, -halfSize.y, halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                rightBottomFront = new THREE.Vector3(halfSize.x, -halfSize.y, halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                frontNormal = new THREE.Vector3(0, 0, 1).applyMatrix4(rotationMatrix);
                backNormal = new THREE.Vector3(0, 0, -1).applyMatrix4(rotationMatrix);
                rightNormal = new THREE.Vector3(1, 0, 0).applyMatrix4(rotationMatrix);
                bottomNormal = new THREE.Vector3(0, -1, 0).applyMatrix4(rotationMatrix);
                leftNormal = new THREE.Vector3(-1, 0, 0).applyMatrix4(rotationMatrix);
                topNormal = new THREE.Vector3(0, 1, 0).applyMatrix4(rotationMatrix);
                setupBlock(data, offset + 0 * 4, rightTopFront, leftTopFront, leftBottomFront, rightBottomFront, frontNormal);
                setupBlock(data, offset + 1 * 4, leftTopBack, rightTopBack, rightBottomBack, leftBottomBack, backNormal);
                setupBlock(data, offset + 2 * 4, rightTopBack, rightTopFront, rightBottomFront, rightBottomBack, rightNormal);
                setupBlock(data, offset + 3 * 4, rightBottomFront, leftBottomFront, leftBottomBack, rightBottomBack, bottomNormal);
                setupBlock(data, offset + 4 * 4, leftTopFront, leftTopBack, leftBottomBack, leftBottomFront, leftNormal);
                setupBlock(data, offset + 5 * 4, rightTopBack, leftTopBack, leftTopFront, rightTopFront, topNormal);
                break;
            case CSPlayer.TileSet.BlockShape.Pane:
                leftTopBack = new THREE.Vector3(-halfSize.x, halfSize.y, -halfSize.z / CSPlayer.BlockUVLayout.PaneDepthDivider).applyMatrix4(rotationMatrix).add(blockLocation);
                rightTopBack = new THREE.Vector3(halfSize.x, halfSize.y, -halfSize.z / CSPlayer.BlockUVLayout.PaneDepthDivider).applyMatrix4(rotationMatrix).add(blockLocation);
                rightBottomBack = new THREE.Vector3(halfSize.x, -halfSize.y, -halfSize.z / CSPlayer.BlockUVLayout.PaneDepthDivider).applyMatrix4(rotationMatrix).add(blockLocation);
                leftBottomBack = new THREE.Vector3(-halfSize.x, -halfSize.y, -halfSize.z / CSPlayer.BlockUVLayout.PaneDepthDivider).applyMatrix4(rotationMatrix).add(blockLocation);
                rightTopFront = new THREE.Vector3(halfSize.x, halfSize.y, halfSize.z / CSPlayer.BlockUVLayout.PaneDepthDivider).applyMatrix4(rotationMatrix).add(blockLocation);
                leftTopFront = new THREE.Vector3(-halfSize.x, halfSize.y, halfSize.z / CSPlayer.BlockUVLayout.PaneDepthDivider).applyMatrix4(rotationMatrix).add(blockLocation);
                leftBottomFront = new THREE.Vector3(-halfSize.x, -halfSize.y, halfSize.z / CSPlayer.BlockUVLayout.PaneDepthDivider).applyMatrix4(rotationMatrix).add(blockLocation);
                rightBottomFront = new THREE.Vector3(halfSize.x, -halfSize.y, halfSize.z / CSPlayer.BlockUVLayout.PaneDepthDivider).applyMatrix4(rotationMatrix).add(blockLocation);
                frontNormal = new THREE.Vector3(0, 0, 1).applyMatrix4(rotationMatrix);
                backNormal = new THREE.Vector3(0, 0, -1).applyMatrix4(rotationMatrix);
                rightNormal = new THREE.Vector3(1, 0, 0).applyMatrix4(rotationMatrix);
                bottomNormal = new THREE.Vector3(0, -1, 0).applyMatrix4(rotationMatrix);
                leftNormal = new THREE.Vector3(-1, 0, 0).applyMatrix4(rotationMatrix);
                topNormal = new THREE.Vector3(0, 1, 0).applyMatrix4(rotationMatrix);
                setupBlock(data, offset + 0 * 4, rightTopFront, leftTopFront, leftBottomFront, rightBottomFront, frontNormal);
                setupBlock(data, offset + 1 * 4, leftTopBack, rightTopBack, rightBottomBack, leftBottomBack, backNormal);
                setupBlock(data, offset + 2 * 4, rightTopBack, rightTopFront, rightBottomFront, rightBottomBack, rightNormal);
                setupBlock(data, offset + 3 * 4, rightBottomFront, leftBottomFront, leftBottomBack, rightBottomBack, bottomNormal);
                setupBlock(data, offset + 4 * 4, leftTopFront, leftTopBack, leftBottomBack, leftBottomFront, leftNormal);
                setupBlock(data, offset + 5 * 4, rightTopBack, leftTopBack, leftTopFront, rightTopFront, topNormal);
                break;
            case CSPlayer.TileSet.BlockShape.HorizontalSlab:
                leftTopBack = new THREE.Vector3(-halfSize.x, 0, -halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                rightTopBack = new THREE.Vector3(halfSize.x, 0, -halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                rightBottomBack = new THREE.Vector3(halfSize.x, -halfSize.y, -halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                leftBottomBack = new THREE.Vector3(-halfSize.x, -halfSize.y, -halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                rightTopFront = new THREE.Vector3(halfSize.x, 0, halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                leftTopFront = new THREE.Vector3(-halfSize.x, 0, halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                leftBottomFront = new THREE.Vector3(-halfSize.x, -halfSize.y, halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                rightBottomFront = new THREE.Vector3(halfSize.x, -halfSize.y, halfSize.z).applyMatrix4(rotationMatrix).add(blockLocation);
                frontNormal = new THREE.Vector3(0, 0, 1).applyMatrix4(rotationMatrix);
                backNormal = new THREE.Vector3(0, 0, -1).applyMatrix4(rotationMatrix);
                rightNormal = new THREE.Vector3(1, 0, 0).applyMatrix4(rotationMatrix);
                bottomNormal = new THREE.Vector3(0, -1, 0).applyMatrix4(rotationMatrix);
                leftNormal = new THREE.Vector3(-1, 0, 0).applyMatrix4(rotationMatrix);
                topNormal = new THREE.Vector3(0, 1, 0).applyMatrix4(rotationMatrix);
                setupBlock(data, offset + 0 * 4, rightTopFront, leftTopFront, leftBottomFront, rightBottomFront, frontNormal);
                setupBlock(data, offset + 1 * 4, leftTopBack, rightTopBack, rightBottomBack, leftBottomBack, backNormal);
                setupBlock(data, offset + 2 * 4, rightTopBack, rightTopFront, rightBottomFront, rightBottomBack, rightNormal);
                setupBlock(data, offset + 3 * 4, rightBottomFront, leftBottomFront, leftBottomBack, rightBottomBack, bottomNormal);
                setupBlock(data, offset + 4 * 4, leftTopFront, leftTopBack, leftBottomBack, leftBottomFront, leftNormal);
                setupBlock(data, offset + 5 * 4, rightTopBack, leftTopBack, leftTopFront, rightTopFront, topNormal)
            }
        };
        return MapGeometryGenerator
    }();
    setupBlock = function (data, offset, pos0, pos1, pos2, pos3, normal) {
        data.positions[(offset + 0) * 3 + 0] = pos0.x;
        data.positions[(offset + 0) * 3 + 1] = pos0.y;
        data.positions[(offset + 0) * 3 + 2] = pos0.z;
        data.positions[(offset + 1) * 3 + 0] = pos1.x;
        data.positions[(offset + 1) * 3 + 1] = pos1.y;
        data.positions[(offset + 1) * 3 + 2] = pos1.z;
        data.positions[(offset + 2) * 3 + 0] = pos2.x;
        data.positions[(offset + 2) * 3 + 1] = pos2.y;
        data.positions[(offset + 2) * 3 + 2] = pos2.z;
        data.positions[(offset + 3) * 3 + 0] = pos3.x;
        data.positions[(offset + 3) * 3 + 1] = pos3.y;
        data.positions[(offset + 3) * 3 + 2] = pos3.z;
        data.normals[(offset + 0) * 3 + 0] = normal.x;
        data.normals[(offset + 0) * 3 + 1] = normal.y;
        data.normals[(offset + 0) * 3 + 2] = normal.z;
        data.normals[(offset + 1) * 3 + 0] = normal.x;
        data.normals[(offset + 1) * 3 + 1] = normal.y;
        data.normals[(offset + 1) * 3 + 2] = normal.z;
        data.normals[(offset + 2) * 3 + 0] = normal.x;
        data.normals[(offset + 2) * 3 + 1] = normal.y;
        data.normals[(offset + 2) * 3 + 2] = normal.z;
        data.normals[(offset + 3) * 3 + 0] = normal.x;
        data.normals[(offset + 3) * 3 + 1] = normal.y;
        data.normals[(offset + 3) * 3 + 2] = normal.z
    };
    getQuadUV = function (quadIndex, blockType, tileSize, textureSize) {
        var center, uvPoints;
        center = getUVCenter(blockType.shape, quadIndex, blockType.uvQuadOffsets[quadIndex], tileSize);
        uvPoints = getUVPoints(blockType.shape, quadIndex, blockType.uvQuadOffsets[quadIndex], tileSize);
        CSPlayer.BlockUVLayout.ApplyQuadUVTransformXY(uvPoints, center, blockType.uvQuadTransforms[quadIndex]);
        return getNormalizedUVQuad(uvPoints, center, textureSize)
    };
    getNormalizedUVQuad = function (uvPoints, center, textureSize) {
        var aUV, i, uvFixOffset, x, y, _i;
        uvFixOffset = .01;
        aUV = [];
        for (i = _i = 0; _i < 4; i = ++_i) {
            x = (uvPoints[i].x + uvFixOffset * (uvPoints[i].x < center.x ? 1 : -1)) / textureSize.width;
            y = 1 - (uvPoints[i].y + uvFixOffset * (uvPoints[i].y < center.y ? 1 : -1)) / textureSize.height;
            aUV.push(new THREE.Vector2(x, y))
        }
        return aUV
    };
    getUVCenter = function (blockShape, quadIndex, uvOffset, tileSize) {
        var height, width;
        switch (blockShape) {
        case CSPlayer.TileSet.BlockShape.Pane:
            width = tileSize;
            height = tileSize;
            switch (quadIndex) {
            case 2:
            case 4:
                width = tileSize / CSPlayer.BlockUVLayout.PaneDepthDivider;
                break;
            case 3:
            case 5:
                height = tileSize / CSPlayer.BlockUVLayout.PaneDepthDivider
            }
            return new THREE.Vector2(uvOffset.X + width / 2, uvOffset.Y + height / 2);
        default:
            return new THREE.Vector2(uvOffset.x + tileSize / 2, uvOffset.y + tileSize / 2)
        }
    };
    getUVPoints = function (blockShape, quadIndex, uvOffset, tileSize) {
        var height, width;
        switch (blockShape) {
        case CSPlayer.TileSet.BlockShape.Pane:
            width = tileSize;
            height = tileSize;
            switch (quadIndex) {
            case 2:
            case 4:
                width = tileSize / CSPlayer.BlockUVLayout.PaneDepthDivider;
                break;
            case 3:
            case 5:
                height = tileSize / CSPlayer.BlockUVLayout.PaneDepthDivider
            }
            return [new THREE.Vector2(uvOffset.x + width, uvOffset.y), new THREE.Vector2(uvOffset.x, uvOffset.y), new THREE.Vector2(uvOffset.x, uvOffset.y + height), new THREE.Vector2(uvOffset.x + width, uvOffset.y + height)];
        default:
            return [new THREE.Vector2(uvOffset.x + tileSize, uvOffset.y), new THREE.Vector2(uvOffset.x, uvOffset.y), new THREE.Vector2(uvOffset.x, uvOffset.y + tileSize), new THREE.Vector2(uvOffset.x + tileSize, uvOffset.y + tileSize)]
        }
    }
}).call(this);
(function () {
    CSPlayer.SoundInstance = function () {
        SoundInstance.SoundState = {
            Playing: 0,
            Paused: 1,
            Stopped: 2
        };

        function SoundInstance(buffer) {
            this.buffer = buffer;
            this.offset = 0;
            this.looping = false;
            this.state = CSPlayer.SoundInstance.SoundState.Stopped;
            this.volume = 1;
            this.pitch = 0;
            this.pan = 0
        }
        SoundInstance.prototype.Play = function () {
            var gainNode;
            if (CSPlayer.audioCtx == null) {
                return
            }
            if (this.state === CSPlayer.SoundInstance.SoundState.Playing) {
                return
            }
            if (this.source != null) {
                this.Stop()
            }
            this.source = CSPlayer.audioCtx.createBufferSource();
            this.source.buffer = this.buffer;
            this.source.loop = this.looping;
            this.panner = CSPlayer.audioCtx.createPanner();
            this.panner.setPosition(-this.pan, 0, 0);
            if (this.source.gain == null) {
                gainNode = CSPlayer.audioCtx.createGain();
                this.source.gain = gainNode.gain;
                this.source.connect(gainNode);
                gainNode.connect(CSPlayer.masterGain)
            } else {
                this.panner.connect(CSPlayer.masterGain);
                this.source.connect(this.panner)
            }
            this.source.gain.value = this.volume;
            this.source.playbackRate.value = Math.pow(2, this.pitch);
            this.state = CSPlayer.SoundInstance.SoundState.Playing;
            this.source.onended = function (_this) {
                return function () {
                    return _this.state = CSPlayer.SoundInstance.SoundState.Stopped
                }
            }(this);
            this.startTime = CSPlayer.audioCtx.currentTime - this.offset;
            return this.source.start(0, this.offset)
        };
        SoundInstance.prototype.Stop = function () {
            if (CSPlayer.audioCtx == null) {
                return
            }
            if (this.source != null) {
                this.source.stop(0);
                delete this.source;
                delete this.panner
            }
            this.offset = 0;
            return this.state = CSPlayer.SoundInstance.SoundState.Stopped
        };
        SoundInstance.prototype.Pause = function () {
            if (CSPlayer.audioCtx == null) {
                return
            }
            if (this.source != null) {
                this.offset = CSPlayer.audioCtx.currentTime - this.startTime;
                this.source.stop(0);
                delete this.source;
                delete this.panner;
                return this.state = CSPlayer.SoundInstance.SoundState.Paused
            }
        };
        SoundInstance.prototype.Resume = function () {
            return this.Play()
        };
        SoundInstance.prototype.GetState = function () {
            if (this.state === CSPlayer.SoundInstance.SoundState.Playing && this.source.playbackState != null && this.source.playbackState === this.source.FINISHED_STATE) {
                this.state = CSPlayer.SoundInstance.SoundState.Stopped
            }
            return this.state
        };
        SoundInstance.prototype.SetLoop = function (looping) {
            this.looping = looping;
            if (this.source != null) {
                return this.source.loop = this.looping
            }
        };
        SoundInstance.prototype.SetVolume = function (volume) {
            this.volume = Math.max(0, Math.min(1, volume));
            if (this.source != null) {
                return this.source.gain.value = this.volume
            }
        };
        SoundInstance.prototype.SetPan = function (pan) {
            this.pan = Math.max(-1, Math.min(1, pan));
            if (this.source != null) {
                return this.panner.setPosition(-this.pan, 0, 0)
            }
        };
        SoundInstance.prototype.SetPitch = function (pitch) {
            this.pitch = Math.max(-1, Math.min(1, pitch));
            if (this.source != null) {
                return this.source.playbackRate.value = Math.pow(2, this.pitch)
            }
        };
        SoundInstance.prototype.GetLoop = function () {
            return this.looping
        };
        SoundInstance.prototype.GetVolume = function () {
            return this.volume
        };
        SoundInstance.prototype.GetPan = function () {
            return this.pan
        };
        SoundInstance.prototype.GetPitch = function () {
            return this.pitch
        };
        return SoundInstance
    }()
}).call(this);
(function () {
    var __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key]
            }

            function ctor() {
                this.constructor = child
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;
            return child
        };
    CSPlayer.GameObject = function (_super) {
        __extends(GameObject, _super);

        function GameObject(gameInstance, nodeId, parentNodeId, name) {
            this.gameInstance = gameInstance;
            GameObject.__super__.constructor.call(this, this.gameInstance.nodeTree, nodeId, parentNodeId, name);
            this.componentsByType = {};
            this.luaSelf = this.gameInstance.scriptAPI.SetupLuaGameObject(this);
            this.pendingForDestruction = false
        }
        GameObject.prototype.AddComponent = function (component) {
            var componentList;
            componentList = this.componentsByType[component.componentType];
            if (componentList == null) {
                componentList = [component];
                this.componentsByType[component.componentType] = componentList
            } else {
                componentList.push(component)
            } if (component.componentType === CSPlayer.ComponentType.Transform) {
                this.transform = component
            }
        };
        GameObject.prototype.RemoveComponent = function (component) {
            var componentList, index;
            componentList = this.componentsByType[component.componentType];
            index = componentList.indexOf(component);
            if (index !== -1) {
                componentList.splice(index, 1)
            }
        };
        GameObject.prototype.Awake = function () {
            var component, componentList, type, _i, _len, _ref;
            _ref = this.componentsByType;
            for (type in _ref) {
                componentList = _ref[type];
                for (_i = 0, _len = componentList.length; _i < _len; _i++) {
                    component = componentList[_i];
                    component.Awake()
                }
            }
        };
        GameObject.prototype.WarmUp = function () {
            var component, componentList, type, _i, _len, _ref;
            _ref = this.componentsByType;
            for (type in _ref) {
                componentList = _ref[type];
                for (_i = 0, _len = componentList.length; _i < _len; _i++) {
                    component = componentList[_i];
                    component.WarmUp()
                }
            }
        };
        GameObject.prototype.Update = function () {
            var component, componentList, type, _i, _len, _ref;
            if (this.pendingForDestruction) {
                return
            }
            _ref = this.componentsByType;
            for (type in _ref) {
                componentList = _ref[type];
                for (_i = 0, _len = componentList.length; _i < _len; _i++) {
                    component = componentList[_i];
                    component.Update()
                }
            }
        };
        GameObject.prototype.MarkDestructionPending = function () {
            var child, _i, _len, _ref, _results;
            this.pendingForDestruction = true;
            _ref = this.children;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                child = _ref[_i];
                _results.push(child.MarkDestructionPending())
            }
            return _results
        };
        GameObject.prototype.OnDestroy = function () {
            var component, componentList, type, _i, _len, _ref;
            _ref = this.componentsByType;
            for (type in _ref) {
                componentList = _ref[type];
                for (_i = 0, _len = componentList.length; _i < _len; _i++) {
                    component = componentList[_i];
                    component.OnDestroy()
                }
            }
            this.componentsByType = {};
            this.luaSelf.str["inner"] = null;
            this.luaSelf.str["transform"] = null;
            this.luaSelf = null;
            this.gameInstance = null;
            this.transform = null
        };
        return GameObject
    }(CSPlayer.Node)
}).call(this);
(function () {
    CSPlayer.GameInput = function () {
        function GameInput(gameInstance) {
            var activeTouchId, control, fullscreenChange, isFullscreen, isPointerLocked, name, needsFullscreenToLock, onMouseWheel, pointerlockError, requestFullscreen, requestPointLockTime, requestPointerLock, _ref;
            this.gameInstance = gameInstance;
            this.isGameActive = true;
            this.axes = {};
            this.buttons = {};
            this.mouseLocked = false;
            this.mousePosition = {
                x: 0,
                y: 0
            };
            this.mouseDelta = {
                x: 0,
                y: 0
            };
            this.newMouseDelta = {
                x: 0,
                y: 0
            };
            this.keysDown = {};
            this.enteredText = [];
            this.newEnteredText = [];
            this.mouseButtonsDown = {};
            this.newMousePosition = null;
            this.newScrollDelta = 0;
            needsFullscreenToLock = false;
            requestPointLockTime = null;
            isFullscreen = function (elem) {
                return document.fullscreenElement === elem || document.webkitFullscreenElement === elem || document.mozFullscreenElement === elem || document.mozFullScreenElement === elem
            };
            requestFullscreen = function (elem) {
                elem.requestFullscreen = elem.requestFullscreen || elem.webkitRequestFullscreen || elem.mozRequestFullscreen || elem.mozRequestFullScreen;
                elem.requestFullscreen()
            };
            this.GoFullscreen = function () {
                if (!isFullscreen(window)) {
                    requestFullscreen(window)
                }
            };
            isPointerLocked = function (elem) {
                return document.pointerLockElement === elem || document.webkitPointerLockElement === elem || document.mozPointerLockElement === elem
            };
            requestPointerLock = function (elem) {
                if ((!needsFullscreenToLock || isFullscreen(window)) && !isPointerLocked(elem)) {
                    requestPointLockTime = +new Date;
                    elem.requestPointerLock = elem.requestPointerLock || elem.webkitRequestPointerLock || elem.mozRequestPointerLock;
                    elem.requestPointerLock()
                }
            };
            this.LockMouse = function () {
                return this.mouseLocked = true
            };
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
            this.UnlockMouse = function () {
                this.mouseLocked = false;
                return document.exitPointerLock()
            };
            pointerlockError = function () {
                var dt;
                dt = +new Date - requestPointLockTime;
                if (dt < 100) {
                    return needsFullscreenToLock = true
                }
            };
            document.addEventListener("pointerlockerror", pointerlockError, false);
            document.addEventListener("mozpointerlockerror", pointerlockError, false);
            document.addEventListener("webkitpointerlockerror", pointerlockError, false);
            fullscreenChange = function (_this) {
                return function () {
                    CSPlayer.UpdateCanvasSize();
                    if (isFullscreen(window) && _this.mouseLocked) {
                        requestPointerLock(_this.gameInstance.canvas)
                    }
                    return false
                }
            }(this);
            document.addEventListener("fullscreenchange", fullscreenChange, false);
            document.addEventListener("mozfullscreenchange", fullscreenChange, false);
            document.addEventListener("webkitfullscreenchange", fullscreenChange, false);
            this.gameInstance.canvas.addEventListener("contextmenu", function (event) {
                event.preventDefault();
                return false
            }, false);
            this.gameInstance.canvas.addEventListener("mousemove", function (_this) {
                return function (event) {
                    var movX, movY;
                    event.preventDefault();
                    if (_this.mouseLocked) {
                        if (isPointerLocked(_this.gameInstance.canvas)) {
                            movX = event.movementX;
                            if (movX == null) {
                                movX = event.webkitMovementX
                            }
                            if (movX == null) {
                                movX = event.mozMovementX
                            }
                            movY = event.movementY;
                            if (movY == null) {
                                movY = event.webkitMovementY
                            }
                            if (movY == null) {
                                movY = event.mozMovementY
                            }
                            _this.newMouseDelta.x += movX;
                            _this.newMouseDelta.y += movY
                        }
                    } else {
                        _this.newMousePosition = {
                            x: event.offsetX || event.layerX,
                            y: event.offsetY || event.layerY
                        };
                        _this.newMouseDelta.x = _this.newMousePosition.x - _this.mousePosition.x;
                        _this.newMouseDelta.y = _this.newMousePosition.y - _this.mousePosition.y
                    }
                    return false
                }
            }(this), false);
            this.gameInstance.canvas.addEventListener("mousedown", function (_this) {
                return function (event) {
                    event.preventDefault();
                    _this.gameInstance.canvas.focus();
                    if (_this.mouseLocked) {
                        if (needsFullscreenToLock && !isFullscreen(window)) {
                            requestFullscreen(window)
                        } else if (!isPointerLocked(_this.gameInstance.canvas)) {
                            requestPointerLock(_this.gameInstance.canvas)
                        } else {
                            _this.mouseButtonsDown[event.button] = true
                        }
                    } else {
                        _this.mouseButtonsDown[event.button] = true
                    }
                    return false
                }
            }(this), false);
            onMouseWheel = function (_this) {
                return function (event) {
                    event.preventDefault();
                    _this.newScrollDelta += event.wheelDelta || -event.detail;
                    return false
                }
            }(this);
            this.gameInstance.canvas.addEventListener("DOMMouseScroll", onMouseWheel, false);
            this.gameInstance.canvas.addEventListener("mousewheel", onMouseWheel, false);
            document.addEventListener("mouseup", function (_this) {
                return function (event) {
                    event.preventDefault();
                    if (_this.mouseLocked && needsFullscreenToLock) {
                        if (!isFullscreen(window)) {
                            requestFullscreen(window)
                        } else if (!isPointerLocked(_this.gameInstance.canvas)) {
                            requestPointerLock(_this.gameInstance.canvas)
                        }
                    }
                    _this.mouseButtonsDown[event.button] = false;
                    return false
                }
            }(this), false);
            activeTouchId = null;
            this.gameInstance.canvas.addEventListener("touchstart", function (_this) {
                return function (event) {
                    var rect, touch;
                    event.preventDefault();
                    if (activeTouchId == null) {
                        touch = event.changedTouches[0];
                        activeTouchId = touch.identifier;
                        rect = event.target.getBoundingClientRect();
                        _this.newMousePosition = {
                            x: (touch.clientX - rect.left) * window.devicePixelRatio,
                            y: (touch.clientY - rect.top) * window.devicePixelRatio
                        };
                        _this.newMouseDelta.x = _this.newMousePosition.x - _this.mousePosition.x;
                        _this.newMouseDelta.y = _this.newMousePosition.y - _this.mousePosition.y;
                        _this.mouseButtonsDown[0] = true
                    }
                }
            }(this));
            this.gameInstance.canvas.addEventListener("touchend", function (_this) {
                return function (event) {
                    if (activeTouchId === event.changedTouches[0].identifier) {
                        activeTouchId = null;
                        _this.mouseButtonsDown[0] = false
                    }
                }
            }(this));
            this.gameInstance.canvas.addEventListener("touchcancel", function (_this) {
                return function (event) {
                    if (activeTouchId === event.changedTouches[0].identifier) {
                        activeTouchId = null;
                        _this.mouseButtonsDown[0] = false
                    }
                }
            }(this));
            this.gameInstance.canvas.addEventListener("touchmove", function (_this) {
                return function (event) {
                    var rect, touch;
                    event.preventDefault();
                    touch = event.changedTouches[0];
                    if (activeTouchId === touch.identifier) {
                        rect = event.target.getBoundingClientRect();
                        _this.newMousePosition = {
                            x: (touch.clientX - rect.left) * window.devicePixelRatio,
                            y: (touch.clientY - rect.top) * window.devicePixelRatio
                        };
                        _this.newMouseDelta.x = _this.newMousePosition.x - _this.mousePosition.x;
                        _this.newMouseDelta.y = _this.newMousePosition.y - _this.mousePosition.y
                    }
                }
            }(this));
            document.addEventListener("keypress", function (_this) {
                return function (event) {
                    if (event.keyCode > 0 && event.keyCode < 32) {
                        return
                    }
                    if (event.char != null) {
                        _this.newEnteredText.push(event.char)
                    } else if (event.charCode !== 0) {
                        _this.newEnteredText.push(String.fromCharCode(event.charCode))
                    } else {
                        _this.newEnteredText.push(String.fromCharCode(event.keyCode))
                    }
                    return false
                }
            }(this), false);
            document.addEventListener("keydown", function (_this) {
                return function (event) {
                    if (event.keyCode < 48) {
                        event.preventDefault();
                        if (event.keyCode <= 32) {
                            _this.newEnteredText.push(String.fromCharCode(event.keyCode))
                        }
                    }
                    _this.keysDown[event.keyCode] = true;
                    return event.keyCode >= 48
                }
            }(this), false);
            document.addEventListener("keyup", function (_this) {
                return function (event) {
                    event.preventDefault();
                    _this.keysDown[event.keyCode] = false;
                    return false
                }
            }(this), false);
            _ref = this.gameInstance.gamePackage.controls;
            for (name in _ref) {
                control = _ref[name];
                switch (control.type) {
                case CSPlayer.GameControl.ControlType.Axis:
                    this.axes[name] = {
                        value: 0
                    };
                    break;
                case CSPlayer.GameControl.ControlType.Button:
                    this.buttons[name] = {
                        isDown: false,
                        wasJustPressed: false,
                        wasJustReleased: false
                    }
                }
            }
        }
        GameInput.prototype.Update = function (elapsedTime) {
            var axis, button, control, name, negative, oldEnteredText, positive, wasDown, _ref;
            if (elapsedTime == null) {
                elapsedTime = 1 / 60
            }
            if (this.newMousePosition != null) {
                this.mousePosition = this.newMousePosition;
                this.newMousePosition = null
            }
            this.mouseDelta = this.newMouseDelta;
            this.newMouseDelta = {
                x: 0,
                y: 0
            };
            this.mouseButtonsDown[5] = this.newScrollDelta > 0;
            this.mouseButtonsDown[6] = this.newScrollDelta < 0;
            this.newScrollDelta = 0;
            oldEnteredText = this.enteredText;
            this.enteredText = this.newEnteredText;
            this.newEnteredText = oldEnteredText;
            this.newEnteredText.length = 0;
            _ref = this.gameInstance.gamePackage.controls;
            for (name in _ref) {
                control = _ref[name];
                switch (control.type) {
                case CSPlayer.GameControl.ControlType.Axis:
                    axis = this.axes[name];
                    if (control.source !== CSPlayer.GameControl.ControlSource.JoystickAxis) {
                        positive = false;
                        negative = false;
                        switch (control.source) {
                        case CSPlayer.GameControl.ControlSource.Keyboard:
                            positive = this.isGameActive && this.keysDown[control.positiveKey];
                            negative = this.isGameActive && this.keysDown[control.negativeKey];
                            break;
                        case CSPlayer.GameControl.ControlSource.MouseButton:
                            positive = this.isGameActive && this.mouseButtonsDown[control.positiveButtonIndex];
                            negative = this.isGameActive && this.mouseButtonsDown[control.negativeButtonIndex]
                        }
                        if (control.axisSnap) {
                            if (positive) {
                                axis.value = Math.max(0, axis.value)
                            }
                            if (negative) {
                                axis.value = Math.min(0, axis.value)
                            }
                        }
                        if (positive) {
                            axis.value = Math.min(1, axis.value + elapsedTime * control.axisSensitivity)
                        }
                        if (negative) {
                            axis.value = Math.max(-1, axis.value - elapsedTime * control.axisSensitivity)
                        }
                        if (!(positive || negative)) {
                            axis.value = (axis.value > 0 ? 1 : -1) * Math.max(0, Math.abs(axis.value) - elapsedTime * control.axisGravity)
                        }
                    }
                    break;
                case CSPlayer.GameControl.ControlType.Button:
                    button = this.buttons[name];
                    wasDown = button.isDown;
                    switch (control.source) {
                    case CSPlayer.GameControl.ControlSource.Keyboard:
                        button.isDown = this.isGameActive && this.keysDown[control.positiveKey];
                        break;
                    case CSPlayer.GameControl.ControlSource.MouseButton:
                        button.isDown = this.isGameActive && this.mouseButtonsDown[control.positiveButtonIndex]
                    }
                    button.wasJustPressed = !wasDown && button.isDown;
                    button.wasJustReleased = wasDown && !button.isDown
                }
            }
        };
        return GameInput
    }()
}).call(this);
(function () {
    var __indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item) return i
        }
        return -1
    };
    CSPlayer.GameInstance = function () {
        function GameInstance(gamePackage, canvas) {
            this.canvas = canvas;
            this.gamePackage = gamePackage;
            this.gameInput = new CSPlayer.GameInput(this);
            this.scriptAPI = new CSPlayer.ScriptAPI(this);
            this.nodeTree = null;
            this.activeCameras = [];
            this.cachedGameObjects = [];
            this.componentsToBeStarted = [];
            this.pendingDestroyedGameObjects = [];
            this.pendingDestroyedComponents = [];
            this.dirtyRendererComponents = [];
            this.assetTextureCache = new CSPlayer.TextureCache;
            this.nextNetworkPlayerId = 0;
            this.networkPlayersById = {};
            this.networkSyncsById = {}
        }
        GameInstance.prototype.Init = function (callback, progressCallback) {
            this.scriptAPI.Init(callback, progressCallback)
        };
        GameInstance.prototype.LoadScene = function (sceneId) {
            var gameObject, newGameObjects, scene, _i, _j, _len, _len1;
            this.Clear();
            scene = this.gamePackage.assets[sceneId];
            if (!scene instanceof CSPlayer.Scene) {
                throw new Error("Could not get scene " + sceneId)
            }
            this.nodeTree = new CSPlayer.NodeTree(scene.nodeTree.nextNodeId);
            newGameObjects = [];
            scene.nodeTree.Walk(function (_this) {
                return function (node) {
                    var component, componentInstance, obj, _i, _len, _ref, _results;
                    obj = new CSPlayer.GameObject(_this, node.nodeId, node.parentNodeId, node.name);
                    _this.nodeTree.AddNode(obj);
                    newGameObjects.push(obj);
                    _ref = node.components;
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        component = _ref[_i];
                        componentInstance = new CSPlayer.ComponentInstances.Component.ComponentTypeMap[component.componentType](obj, component);
                        obj.AddComponent(componentInstance);
                        _results.push(_this.componentsToBeStarted.push(componentInstance))
                    }
                    return _results
                }
            }(this));
            for (_i = 0, _len = newGameObjects.length; _i < _len; _i++) {
                gameObject = newGameObjects[_i];
                gameObject.Awake()
            }
            for (_j = 0, _len1 = newGameObjects.length; _j < _len1; _j++) {
                gameObject = newGameObjects[_j];
                gameObject.WarmUp()
            }
        };
        GameInstance.prototype.Clear = function () {
            if (this.nodeTree !== null) {
                this.nodeTree.Walk(function (node) {
                    return node.OnDestroy()
                });
                this.nodeTree.Clear()
            }
            if (!this.assetTextureCache.IsEmpty()) {
                console.warn("Asset texture cache somehow isn't empty after the node tree was cleared")
            }
            this.activeCameras.length = 0;
            this.cachedGameObjects.length = 0;
            this.cachedGameObjects.length = 0;
            this.componentsToBeStarted.length = 0;
            this.pendingDestroyedGameObjects.length = 0;
            this.pendingDestroyedComponents.length = 0;
            this.dirtyRendererComponents.length = 0
        };
        GameInstance.prototype.Update = function () {
            var component, gameObject, index, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
            this.gameInput.Update();
            if (this.scriptAPI.sceneIdToLoad !== CSPlayer.UInt16MaxValue) {
                this.LoadScene(this.scriptAPI.sceneIdToLoad);
                this.scriptAPI.Reset()
            }
            this.cachedGameObjects.length = 0;
            this.nodeTree.Walk(function (_this) {
                return function (gameObject) {
                    return _this.cachedGameObjects.push(gameObject)
                }
            }(this));
            index = 0;
            while (index < this.componentsToBeStarted.length) {
                component = this.componentsToBeStarted[index];
                if (_ref = !component.gameObject, __indexOf.call(this.cachedGameObjects, _ref) >= 0) {
                    index++
                } else {
                    component.Start();
                    this.componentsToBeStarted.splice(index, 1)
                }
            }
            _ref1 = this.cachedGameObjects;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                gameObject = _ref1[_i];
                gameObject.Update()
            }
            this.scriptAPI.Update();
            _ref2 = this.pendingDestroyedComponents;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                component = _ref2[_j];
                this.DestroyComponent(component)
            }
            this.pendingDestroyedComponents.length = 0;
            _ref3 = this.pendingDestroyedGameObjects;
            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
                gameObject = _ref3[_k];
                this.DestroyGameObjectRecursive(gameObject)
            }
            this.pendingDestroyedGameObjects.length = 0
        };
        GameInstance.prototype.Draw = function () {
            var camera, depthValue, index, renderer, rootNode, updateDepth, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
            _ref = this.dirtyRendererComponents;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                renderer = _ref[_i];
                renderer.Undirty()
            }
            this.dirtyRendererComponents.length = 0;
            depthValue = 0;
            updateDepth = function (obj) {
                var child, _j, _len1, _ref1;
                obj.renderDepth = depthValue;
                depthValue--;
                _ref1 = obj.children;
                for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                    child = _ref1[_j];
                    updateDepth(child)
                }
            };
            _ref1 = this.nodeTree.rootNodes;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                rootNode = _ref1[_j];
                updateDepth(rootNode.transform.object)
            }
            index = 0;
            this.nodeTree.Walk(function (_this) {
                return function (node) {
                    node.transform.object.renderDepth = index;
                    index++
                }
            }(this));
            _ref2 = this.activeCameras;
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                camera = _ref2[_k];
                camera.SetupRendering();
                CSPlayer.renderer.render(CSPlayer.scene, camera.actualCamera)
            }
        };
        GameInstance.prototype.DestroyGameObjectRecursive = function (gameObject) {
            var index;
            while (gameObject.children.length > 0) {
                this.DestroyGameObjectRecursive(gameObject.children[0])
            }
            gameObject.OnDestroy();
            this.nodeTree.DeleteNode(gameObject.nodeId);
            index = this.cachedGameObjects.indexOf(gameObject);
            this.cachedGameObjects.splice(index, 1)
        };
        GameInstance.prototype.DestroyComponent = function (component) {
            component.OnDestroy();
            component.gameObject.RemoveComponent(component)
        };
        GameInstance.prototype.MarkDirtyRenderer = function (renderer) {
            renderer.dirty = true;
            if (this.dirtyRendererComponents.indexOf(renderer) === -1) {
                this.dirtyRendererComponents.push(renderer)
            }
        };
        GameInstance.prototype.MarkGameObjectForDestruction = function (gameObject) {
            if (this.pendingDestroyedGameObjects.indexOf(gameObject) === -1) {
                this.pendingDestroyedGameObjects.push(gameObject);
                gameObject.MarkDestructionPending()
            }
        };
        GameInstance.prototype.MarkComponentForDestruction = function (component) {
            var index;
            if (this.pendingDestroyedComponents.indexOf(component) === -1) {
                this.pendingDestroyedComponents.push(component)
            }
            index = this.componentsToBeStarted.indexOf(component);
            if (index !== -1) {
                this.componentsToBeStarted.splice(index, 1)
            }
        };
        GameInstance.prototype.RegisterNetworkSync = function (networkSync, syncId) {
            networkSync.syncId = syncId;
            return this.networkSyncsById[syncId] = networkSync
        };
        GameInstance.prototype.UnregisterNetworkSync = function (networkSync) {
            return delete this.networkSyncsById[networkSync.syncId]
        };
        return GameInstance
    }()
}).call(this);
(function () {
    window.G = null;
    CSPlayer.ScriptAPI = function () {
        ScriptAPI.NetworkMessageSide = {
            Players: 0,
            Server: 1,
            Any: 2
        };
        ScriptAPI.NetworkMessageArgType = {
            String: 0,
            Number: 1,
            Boolean: 2,
            Table: 3
        };
        ScriptAPI.NetworkDeliveryMethod = {
            ReliableOrdered: 0,
            ReliableSequenced: 1,
            UnreliableSequenced: 2
        };

        function ScriptAPI(gameInstance) {
            this.gameInstance = gameInstance;
            this.sceneIdToLoad = CSPlayer.UInt16MaxValue;
            this.luaAssetNews = {};
            this.luaGameObjectNew = null;
            this.luaComponentNews = {};
            this.luaAssets = {};
            this.soundBuffersByAssetId = {};
            this.luaWorker = new Worker(CSPlayer.ScriptRootPath + "LuaParserWorker.js")
        }
        ScriptAPI.prototype.LoadLua = function (chunk, chunkName, callback) {
            this.luaWorker.onmessage = function (_this) {
                return function (event) {
                    return callback(lua_load_js(event.data, chunkName)())
                }
            }(this);
            return this.luaWorker.postMessage(chunk)
        };
        ScriptAPI.prototype.Init = function (callback, progressCallback) {
            return this.SetupAPI(function (_this) {
                return function () {
                    var asset, assetId, scriptIndex, scriptsToSetup, setupAllScripts, setupAllSounds, soundIndex, soundsToSetup, _i, _len, _ref;
                    scriptsToSetup = [];
                    soundsToSetup = [];
                    _ref = _this.gameInstance.gamePackage.orderedAssetIds;
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        assetId = _ref[_i];
                        asset = _this.gameInstance.gamePackage.assets[assetId];
                        if (asset == null) {
                            continue
                        }
                        _this.luaAssets[asset.id] = _this.MakeLuaAsset(asset);
                        if (asset instanceof CSPlayer.Script) {
                            if (asset.isVisual) {
                                asset.content = asset.SerializeToLua(_this.gameInstance.gamePackage.scriptAPIVersion)
                            }
                            scriptsToSetup.push(asset)
                        } else if (asset instanceof CSPlayer.Sound) {
                            soundsToSetup.push(asset)
                        }
                    }
                    soundIndex = 0;
                    setupAllSounds = function (soundsCallback) {
                        var sound;
                        if (soundIndex === soundsToSetup.length) {
                            soundsCallback();
                            return
                        }
                        progressCallback(soundIndex, soundsToSetup.length, "Initializing sounds...");
                        sound = soundsToSetup[soundIndex];
                        if (CSPlayer.audioCtx != null) {
                            return CSPlayer.audioCtx.decodeAudioData(sound.rawData.buffer, function (buffer) {
                                _this.soundBuffersByAssetId[sound.id] = buffer;
                                soundIndex++;
                                return setupAllSounds(soundsCallback)
                            }, function () {
                                console.warn('Failed to decode audio data for sound "' + _this.gameInstance.gamePackage.assetFQNames[sound.id] + '" (' + sound.id + ")");
                                soundIndex++;
                                return setupAllSounds(soundsCallback)
                            })
                        } else {
                            soundIndex++;
                            return setupAllSounds(soundsCallback)
                        }
                    };
                    scriptIndex = 0;
                    setupAllScripts = function (scriptsCallback) {
                        var script;
                        if (scriptIndex === scriptsToSetup.length) {
                            _this.luaWorker.terminate();
                            delete _this.lua.str["Behavior"];
                            scriptsCallback();
                            return
                        }
                        progressCallback(scriptIndex, scriptsToSetup.length, "Initializing scripts...");
                        script = scriptsToSetup[scriptIndex];
                        _this.lua.str["Behavior"] = _this.luaAssets[script.id];
                        return _this.LoadLua(script.content, "Behavior_" + script.id, function () {
                            scriptIndex++;
                            return setupAllScripts(scriptsCallback)
                        })
                    };
                    return setupAllSounds(function () {
                        return setupAllScripts(function () {
                            return callback(null)
                        })
                    })
                }
            }(this))
        };
        ScriptAPI.prototype.MakeLuaAsset = function (asset) {
            return this.luaAssetNews[asset.assetType](null, asset)[0]
        };
        ScriptAPI.prototype.Reset = function () {
            this.sceneIdToLoad = CSPlayer.UInt16MaxValue
        };
        ScriptAPI.prototype.Update = function () {
            var char, _i, _len, _ref;
            _ref = this.gameInstance.gameInput.enteredText;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                char = _ref[_i];
                if (this.textEnteredCallback != null) {
                    lua_rawcall(this.textEnteredCallback, [char])
                }
            }
        };
        ScriptAPI.prototype.SetupAPI = function (callback) {
            return this.LoadLua("", "root", function (_this) {
                return function (lua) {
                    var csTable, loadMathFiles, mathFiles;
                    _this.lua = lua;
                    window.G = _this.lua;
                    csTable = lua_newtable2({
                        Exit: function () {},
                        LoadScene: function (sceneToLoad) {
                            _this.sceneIdToLoad = sceneToLoad.str["inner"].id
                        },
                        AppendScene: function (luaScene, luaParentGameObject) {
                            var instantiatedGameObject, newGameObjects, nodeMappings, parentGameObjectId, scene, _i, _len;
                            scene = luaScene.str["inner"];
                            parentGameObjectId = luaParentGameObject != null ? luaParentGameObject.str["inner"].nodeId : CSPlayer.UInt16MaxValue;
                            nodeMappings = {};
                            nodeMappings[CSPlayer.UInt16MaxValue] = parentGameObjectId;
                            newGameObjects = [];
                            scene.nodeTree.Walk(function (node) {
                                var component, componentInstance, componentInstanceType, gameInstanceNodeId, obj, _i, _len, _ref, _results;
                                gameInstanceNodeId = _this.gameInstance.nodeTree.GenerateNextNodeId();
                                nodeMappings[node.nodeId] = gameInstanceNodeId;
                                obj = new CSPlayer.GameObject(_this.gameInstance, gameInstanceNodeId, nodeMappings[node.parentNodeId], node.name);
                                _this.gameInstance.nodeTree.AddNode(obj);
                                newGameObjects.push(obj);
                                _ref = node.components;
                                _results = [];
                                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                    component = _ref[_i];
                                    componentInstanceType = CSPlayer.ComponentInstances.Component.ComponentTypeMap[component.componentType];
                                    componentInstance = new componentInstanceType(obj, component);
                                    obj.AddComponent(componentInstance);
                                    _results.push(_this.gameInstance.componentsToBeStarted.push(componentInstance))
                                }
                                return _results
                            });
                            for (_i = 0, _len = newGameObjects.length; _i < _len; _i++) {
                                instantiatedGameObject = newGameObjects[_i];
                                instantiatedGameObject.Awake()
                            }
                            if (scene.nodeTree.rootNodes.length === 1) {
                                return [newGameObjects[0].luaSelf]
                            } else {
                                return [null]
                            }
                        },
                        Instantiate: function (name, luaScene, luaParentGameObject) {
                            var gameObject, instantiatedGameObject, newGameObjects, nodeMappings, parentGameObjectId, scene, transform, _i, _len;
                            scene = luaScene.str["inner"];
                            parentGameObjectId = luaParentGameObject != null ? luaParentGameObject.str["inner"].nodeId : CSPlayer.UInt16MaxValue;
                            gameObject = new CSPlayer.GameObject(_this.gameInstance, _this.gameInstance.nodeTree.GenerateNextNodeId(), parentGameObjectId, name);
                            transform = new CSPlayer.ComponentInstances.Transform(gameObject, new CSPlayer.Components.Transform);
                            gameObject.AddComponent(transform);
                            _this.gameInstance.nodeTree.AddNode(gameObject);
                            nodeMappings = {};
                            nodeMappings[CSPlayer.UInt16MaxValue] = gameObject.nodeId;
                            newGameObjects = [];
                            newGameObjects.push(gameObject);
                            scene.nodeTree.Walk(function (node) {
                                var component, componentInstance, componentInstanceType, gameInstanceNodeId, obj, _i, _len, _ref, _results;
                                gameInstanceNodeId = _this.gameInstance.nodeTree.GenerateNextNodeId();
                                nodeMappings[node.nodeId] = gameInstanceNodeId;
                                obj = new CSPlayer.GameObject(_this.gameInstance, gameInstanceNodeId, nodeMappings[node.parentNodeId], node.name);
                                _this.gameInstance.nodeTree.AddNode(obj);
                                newGameObjects.push(obj);
                                _ref = node.components;
                                _results = [];
                                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                    component = _ref[_i];
                                    componentInstanceType = CSPlayer.ComponentInstances.Component.ComponentTypeMap[component.componentType];
                                    componentInstance = new componentInstanceType(obj, component);
                                    obj.AddComponent(componentInstance);
                                    _results.push(_this.gameInstance.componentsToBeStarted.push(componentInstance))
                                }
                                return _results
                            });
                            for (_i = 0, _len = newGameObjects.length; _i < _len; _i++) {
                                instantiatedGameObject = newGameObjects[_i];
                                instantiatedGameObject.Awake()
                            }
                            return [gameObject.luaSelf]
                        },
                        Destroy: function (luaObj) {
                            var obj;
                            obj = luaObj.str["inner"];
                            if (obj instanceof CSPlayer.GameObject) {
                                _this.gameInstance.MarkGameObjectForDestruction(obj)
                            } else if (obj instanceof CSPlayer.ComponentInstances.Component) {
                                if (obj.componentType !== CSPlayer.ComponentType.Transform) {
                                    _this.gameInstance.MarkComponentForDestruction(obj)
                                }
                            } else if (obj instanceof CSPlayer.Asset) {
                                if (_this.gameInstance.gamePackage.assets[obj.id] == null) {
                                    delete _this.luaAssets[obj.id]
                                } else {
                                    console.error("Cannot destroy asset from package. Only dynamically-loaded assets can be destroyed")
                                }
                            }
                        },
                        CreateGameObject: function (name, luaParentGameObject) {
                            var newGameObject, parentGameObjectId, transform;
                            parentGameObjectId = luaParentGameObject != null ? luaParentGameObject.str["inner"].nodeId : CSPlayer.UInt16MaxValue;
                            newGameObject = new CSPlayer.GameObject(_this.gameInstance, _this.gameInstance.nodeTree.GenerateNextNodeId(), parentGameObjectId, name);
                            transform = new CSPlayer.ComponentInstances.Transform(newGameObject, new CSPlayer.Components.Transform);
                            newGameObject.AddComponent(transform);
                            _this.gameInstance.nodeTree.AddNode(newGameObject);
                            newGameObject.Awake();
                            return [newGameObject.luaSelf]
                        },
                        FindGameObject: function (name) {
                            var gameObject, id, _ref;
                            _ref = _this.gameInstance.nodeTree.nodesById;
                            for (id in _ref) {
                                gameObject = _ref[id];
                                if (gameObject.name === name) {
                                    return [gameObject.luaSelf]
                                }
                            }
                            return [null]
                        },
                        FindAsset: function (assetFQName, assetTypeName) {
                            var assetId, fqName, _ref;
                            if (assetTypeName == null) {
                                assetTypeName = ""
                            }
                            _ref = _this.gameInstance.gamePackage.assetFQNames;
                            for (assetId in _ref) {
                                fqName = _ref[assetId];
                                if (fqName === assetFQName && (assetTypeName === "" || CSPlayer.AssetTypeNames[_this.gameInstance.gamePackage.assets[assetId].assetType] === assetTypeName)) {
                                    return [_this.luaAssets[assetId]]
                                }
                            }
                            return [null]
                        },
                        GetRootGameObjects: function () {
                            var child, gameObjects, index, _i, _len, _ref;
                            gameObjects = lua_newtable();
                            index = 1;
                            _ref = _this.gameInstance.nodeTree.rootNodes;
                            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                child = _ref[_i];
                                if (child.pendingForDestruction) {
                                    continue
                                }
                                gameObjects.uints[index] = child.luaSelf;
                                index++
                            }
                            return [gameObjects]
                        }
                    });
                    _this.lua.str["CraftStudio"] = csTable;
                    _this.lua.str["CS"] = csTable;
                    mathFiles = ["Misc", "Vector3", "Quaternion", "Plane", "Ray"];
                    loadMathFiles = function (index, callback) {
                        if (index === mathFiles.length) {
                            callback();
                            return
                        }
                        return CSPlayer.DownloadUrl(CSPlayer.ScriptRootPath + "Lua/Math/" + mathFiles[index] + ".lua", "text", function (content) {
                            return _this.LoadLua(content, "math_" + mathFiles[index], function () {
                                return loadMathFiles(index + 1, callback)
                            })
                        })
                    };
                    return loadMathFiles(0, function () {
                        var audioTable, inputTable, jsonToLua, luaToQuerystring, networkTable, physicsTable, quaternionTable, rayTable, screenTable, storageTable, vector3Table, webTable;
                        vector3Table = _this.lua.str["Vector3"];
                        _this.luaVector3New = vector3Table.str["New"];
                        if (_this.gameInstance.gamePackage.scriptAPIVersion < 3) {
                            vector3Table.str["Forward"] = _this.lua.str["Vector3"].str["UnitZ"];
                            vector3Table.str["Left"] = _this.lua.str["Vector3"].str["UnitX"]
                        }
                        quaternionTable = _this.lua.str["Quaternion"];
                        _this.luaQuaternionNew = quaternionTable.str["New"];
                        rayTable = _this.lua.str["Ray"];
                        _this.luaRayNew = rayTable.str["New"];
                        rayTable.str["IntersectsModelRenderer"] = function (self, luaModelRenderer) {
                            var direction, intersects, luaDirection, luaPosition, normal, position, raycaster;
                            luaPosition = self.str["position"];
                            luaDirection = self.str["direction"];
                            position = new THREE.Vector3(luaPosition.str["x"], luaPosition.str["y"], luaPosition.str["z"]);
                            direction = new THREE.Vector3(luaDirection.str["x"], luaDirection.str["y"], luaDirection.str["z"]);
                            if (!(luaModelRenderer.str["inner"].modelRoot == null)) {
                                raycaster = new THREE.Raycaster(position, direction);
                                intersects = raycaster.intersectObject(luaModelRenderer.str["inner"].modelRoot, true)
                            }
                            if (!(intersects == null || intersects.length === 0)) {
                                normal = _this.luaVector3New(null, intersects[0].normal.x, intersects[0].normal.y, intersects[0].normal.z)[0];
                                return [intersects[0].distance, normal]
                            } else {
                                return [null]
                            }
                        };
                        rayTable.str["IntersectsMapRenderer"] = function (self, luaMapRenderer) {
                            return [null]
                        };
                        rayTable.str["IntersectsTextRenderer"] = function (self, luaTextRenderer) {
                            var direction, intersects, luaDirection, luaPosition, normal, position, raycaster;
                            luaPosition = self.str["position"];
                            luaDirection = self.str["direction"];
                            position = new THREE.Vector3(luaPosition.str["x"], luaPosition.str["y"], luaPosition.str["z"]);
                            direction = new THREE.Vector3(luaDirection.str["x"], luaDirection.str["y"], luaDirection.str["z"]);
                            if (!(luaTextRenderer.str["inner"].textRoot == null)) {
                                raycaster = new THREE.Raycaster(position, direction);
                                intersects = raycaster.intersectObject(luaTextRenderer.str["inner"].textRoot, true)
                            }
                            if (!(intersects == null || intersects.length === 0)) {
                                normal = _this.luaVector3New(null, intersects[0].normal.x, intersects[0].normal.y, intersects[0].normal.z)[0];
                                return [intersects[0].distance, normal]
                            } else {
                                return [null]
                            }
                        };
                        rayTable.str["IntersectsPlane"] = function (self, luaPlane) {
                            var direction, luaDirection, luaNormal, luaPosition, plane, position, ray;
                            luaPosition = self.str["position"];
                            luaDirection = self.str["direction"];
                            position = new THREE.Vector3(luaPosition.str["x"], luaPosition.str["y"], luaPosition.str["z"]);
                            direction = new THREE.Vector3(luaDirection.str["x"], luaDirection.str["y"], luaDirection.str["z"]);
                            ray = new THREE.Ray(position, direction);
                            luaNormal = luaPlane.str["normal"];
                            plane = new THREE.Plane(new THREE.Vector3(luaNormal.str["x"], luaNormal.str["y"], luaNormal.str["z"]), luaPlane.str["distance"]);
                            return [ray.distanceToPlane(plane)]
                        };
                        screenTable = lua_newtable2({
                            GetSize: function () {
                                return [lua_newtable2({
                                    x: _this.gameInstance.canvas.width,
                                    y: _this.gameInstance.canvas.height
                                })]
                            },
                            SetSize: function (width, height) {
                                return CSPlayer.SetScreenRatio(width / height)
                            },
                            SetResizable: function () {}
                        });
                        csTable.str["Screen"] = screenTable;
                        inputTable = lua_newtable2({
                            GetMousePosition: function () {
                                return [lua_newtable2(_this.gameInstance.gameInput.mousePosition)]
                            },
                            GetMouseDelta: function () {
                                return [lua_newtable2(_this.gameInstance.gameInput.mouseDelta)]
                            },
                            IsButtonDown: function (buttonName) {
                                return [_this.gameInstance.gameInput.buttons[buttonName].isDown]
                            },
                            WasButtonJustPressed: function (buttonName) {
                                return [_this.gameInstance.gameInput.buttons[buttonName].wasJustPressed]
                            },
                            WasButtonJustReleased: function (buttonName) {
                                return [_this.gameInstance.gameInput.buttons[buttonName].wasJustReleased]
                            },
                            GetAxisValue: function (axisName) {
                                return [_this.gameInstance.gameInput.axes[axisName].value]
                            },
                            LockMouse: function () {
                                return _this.gameInstance.gameInput.LockMouse()
                            },
                            UnlockMouse: function () {
                                return _this.gameInstance.gameInput.UnlockMouse()
                            },
                            SetMouseVisible: function (visible) {
                                return _this.gameInstance.canvas.style.cursor = visible ? "" : "none"
                            },
                            OnTextEntered: function (callback) {
                                return _this.textEnteredCallback = callback
                            }
                        });
                        csTable.str["Input"] = inputTable;
                        storageTable = lua_newtable2({
                            Save: function (identifier, data, callback) {
                                var itemId;
                                itemId = "CSStorage:" + _this.gameInstance.gamePackage.baseUrl + ":1:" + identifier;
                                if (data === null) {
                                    window.localStorage.removeItem(itemId)
                                } else {
                                    window.localStorage.setItem(itemId, JSON.stringify(data))
                                }
                                return callback(null)
                            },
                            Load: function (identifier, callback) {
                                var value;
                                value = window.localStorage.getItem("CSStorage:" + _this.gameInstance.gamePackage.baseUrl + ":1:" + identifier);
                                if (value != null) {
                                    value = JSON.parse(value)
                                }
                                return callback(null, value)
                            }
                        });
                        csTable.str["Storage"] = storageTable;
                        audioTable = lua_newtable2({
                            SetMasterVolume: function (volume) {
                                return CSPlayer.masterGain.gain.value = volume
                            },
                            GetMasterVolume: function () {
                                return [CSPlayer.masterGain.gain.value]
                            }
                        });
                        csTable.str["Audio"] = audioTable;
                        physicsTable = lua_newtable2({
                            SetGravity: function () {
                                return console.warn("CS.Physics.SetGravity: Not yet implemented")
                            }
                        });
                        csTable.str["Physics"] = physicsTable;
                        networkTable = lua_newtable2({
                            RegisterMessageHandler: function () {
                                return console.warn("CS.Network.RegisterMessageHandler: Not yet implemented")
                            },
                            MessageSide: lua_newtable2(CSPlayer.ScriptAPI.NetworkMessageSide),
                            DeliveryMethod: lua_newtable2(CSPlayer.ScriptAPI.NetworkDeliveryMethod),
                            Server: lua_newtable2({
                                Start: function () {
                                    return console.warn("CS.Network.Server.Start: Not yet implemented")
                                },
                                Stop: function () {
                                    return console.warn("CS.Network.Server.Stop: Not yet implemented")
                                },
                                OnPlayerJoined: function () {
                                    return console.warn("CS.Network.Server.OnPlayerJoined: Not yet implemented")
                                },
                                OnPlayerLeft: function () {
                                    return console.warn("CS.Network.Server.OnPlayerLeft: Not yet implemented")
                                },
                                OnPlayerLatencyUpdated: function () {
                                    return console.warn("CS.Network.Server.OnPlayerLatencyUpdated: Not yet implemented")
                                },
                                DisconnectPlayer: function () {
                                    return console.warn("CS.Network.Server.DisconnectPlayer: Not yet implemented")
                                }
                            }),
                            Connect: function () {
                                return console.warn("CS.Network.Connect: Not yet implemented")
                            },
                            Disconnect: function () {
                                return console.warn("CS.Network.Disconnect: Not yet implemented")
                            },
                            OnDisconnected: function () {
                                return console.warn("CS.Network.OnDisconnected: Not yet implemented")
                            },
                            OnLatencyUpdated: function () {
                                return console.warn("CS.Network.OnLatencyUpdated: Not yet implemented")
                            }
                        });
                        csTable.str["Network"] = networkTable;
                        jsonToLua = function (jsonData) {
                            var i, key, luaTable, luaValue, value, _i, _len;
                            luaTable = {
                                str: {},
                                uints: {},
                                floats: {},
                                bool: {},
                                objs: {}
                            };
                            if (Array.isArray(jsonData)) {
                                for (i = _i = 0, _len = jsonData.length; _i < _len; i = ++_i) {
                                    value = jsonData[i];
                                    luaTable.uints[i + 1] = jsonToLua(value)
                                }
                            } else if (jsonData !== null && typeof jsonData === "object") {
                                for (key in jsonData) {
                                    value = jsonData[key];
                                    luaValue = jsonToLua(value);
                                    if (luaValue != null) {
                                        luaTable.str[key] = luaValue
                                    }
                                }
                            } else {
                                return jsonData
                            }
                            return luaTable
                        };
                        luaToQuerystring = function (luaData) {
                            if (luaData != null) {
                                return luaData.str
                            } else {
                                return null
                            }
                        };
                        webTable = lua_newtable2({
                            Redirect: function (url) {
                                window.top.location = url
                            },
                            Open: function (url) {
                                var win;
                                win = window.open(url, "_blank");
                                win.focus()
                            },
                            Get: function (url, data, responseType, callback) {
                                $.ajax({
                                    type: "GET",
                                    url: url,
                                    data: luaToQuerystring(data),
                                    dataType: responseType,
                                    success: function (responseData) {
                                        if (responseType === "json") {
                                            callback(null, jsonToLua(responseData))
                                        } else {
                                            callback(null, responseData)
                                        }
                                    },
                                    error: function (xhr, textStatus, errorThrown) {
                                        callback(lua_newtable2({
                                            message: errorThrown || textStatus
                                        }), null)
                                    }
                                })
                            },
                            Post: function (url, data, responseType, callback) {
                                $.ajax({
                                    type: "POST",
                                    url: url,
                                    data: data.str,
                                    dataType: responseType,
                                    success: function (responseData) {
                                        if (responseType === "json") {
                                            callback(null, jsonToLua(responseData))
                                        } else {
                                            callback(null, responseData)
                                        }
                                    },
                                    error: function (xhr, textStatus, errorThrown) {
                                        callback(lua_newtable2({
                                            message: errorThrown || textStatus
                                        }), null)
                                    }
                                })
                            }
                        });
                        webTable.str["ResponseType"] = lua_newtable2({
                            Text: "text",
                            JSON: "json"
                        });
                        csTable.str["Web"] = webTable;
                        return _this.SetupAssetsAPI(function () {
                            return _this.SetupGameObjectAPI(function () {
                                return _this.SetupComponentsAPI(function () {
                                    return callback()
                                })
                            })
                        })
                    })
                }
            }(this))
        };
        ScriptAPI.prototype.SetupAssetsAPI = function (callback) {
            var assetClassDef, assetClassSetupFunctions, getAssetPathInPackage, index, registerAssetClass, registerAssetClasses;
            assetClassDef = "@ = {}\n@.__index = @\nfunction @:New(inner)\nself = setmetatable({ inner = inner }, @)\nself.__index = self\nreturn self\nend";
            registerAssetClass = function (_this) {
                return function (className, callback) {
                    return _this.LoadLua(assetClassDef.replace(/@/g, className), null, function () {
                        var assetClass;
                        assetClass = _this.lua.str[className];
                        _this.luaAssetNews[CSPlayer.AssetType[className]] = assetClass.str["New"];
                        return callback(assetClass)
                    })
                }
            }(this);
            assetClassSetupFunctions = [];
            getAssetPathInPackage = function (_this) {
                return function (self) {
                    return [_this.gameInstance.gamePackage.assetFQNames[self.str["inner"].id]]
                }
            }(this);
            assetClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return registerAssetClass("Sprite", function (spriteTable) {
                        spriteTable.str["GetPathInPackage"] = getAssetPathInPackage;
                        return callback()
                    })
                }
            }(this));
            assetClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return registerAssetClass("Model", function (modelTable) {
                        modelTable.str["GetPathInPackage"] = getAssetPathInPackage;
                        return callback()
                    })
                }
            }(this));
            assetClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return registerAssetClass("ModelAnimation", callback)
                }
            }(this));
            assetClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return registerAssetClass("Map", function (mapTable) {
                        mapTable.str["GetPathInPackage"] = getAssetPathInPackage;
                        mapTable.str["LoadFromPackage"] = function (assetFQName, mapLoadedCallback) {
                            var assetId, mapAssetId, name, newMapAssetId, url, _ref;
                            mapAssetId = null;
                            _ref = _this.gameInstance.gamePackage.assetFQNames;
                            for (assetId in _ref) {
                                name = _ref[assetId];
                                if (name === assetFQName && _this.gameInstance.gamePackage.assets[assetId] instanceof CSPlayer.Map) {
                                    mapAssetId = assetId;
                                    break
                                }
                            }
                            if (mapAssetId == null) {
                                return
                            }
                            newMapAssetId = _this.gameInstance.gamePackage.nextAssetId;
                            _this.gameInstance.gamePackage.nextAssetId++;
                            url = _this.gameInstance.gamePackage.baseUrl + "Data/" + CSPlayer.GamePackage.GetPathForAsset(mapAssetId, CSPlayer.AssetType.Map);
                            CSPlayer.Map.LoadFromUrl(newMapAssetId, url, function (err, map) {
                                var luaMap;
                                luaMap = _this.MakeLuaAsset(map);
                                _this.luaAssets[map.id] = luaMap;
                                return mapLoadedCallback(luaMap)
                            })
                        };
                        mapTable.str["SetBlockAt"] = function (self, x, y, z, blockId, blockOrientation) {
                            var chunkLocation, map;
                            if (blockOrientation == null) {
                                blockOrientation = CSPlayer.Map.BlockOrientation.North
                            }
                            x = x | 0;
                            y = y | 0;
                            z = z | 0;
                            map = self.str["inner"];
                            map.SetBlockAt({
                                x: x + 16,
                                y: y + 16,
                                z: z + 16
                            }, blockId, blockOrientation);
                            chunkLocation = {
                                x: Math.floor((x + 16) / CSPlayer.MapChunk.ChunkWidth),
                                y: Math.floor((y + 16) / CSPlayer.MapChunk.ChunkHeight),
                                z: Math.floor((z + 16) / CSPlayer.MapChunk.ChunkDepth)
                            };
                            _this.gameInstance.nodeTree.Walk(function (obj) {
                                var mapRndr, mapRndrList, _i, _len, _results;
                                mapRndrList = obj.componentsByType[CSPlayer.ComponentType.MapRenderer];
                                if (mapRndrList != null) {
                                    _results = [];
                                    for (_i = 0, _len = mapRndrList.length; _i < _len; _i++) {
                                        mapRndr = mapRndrList[_i];
                                        if (mapRndr.map === map) {
                                            _results.push(mapRndr.MarkChunkDirty(chunkLocation))
                                        } else {
                                            _results.push(void 0)
                                        }
                                    }
                                    return _results
                                }
                            })
                        };
                        mapTable.str["GetBlockIDAt"] = function (self, x, y, z) {
                            x = x | 0;
                            y = y | 0;
                            z = z | 0;
                            return [self.str["inner"].GetBlockIDAt({
                                x: x + 16,
                                y: y + 16,
                                z: z + 16
                            })]
                        };
                        mapTable.str["GetBlockOrientationAt"] = function (self, x, y, z) {
                            x = x | 0;
                            y = y | 0;
                            z = z | 0;
                            return [self.str["inner"].GetBlockOrientationAt({
                                x: x + 16,
                                y: y + 16,
                                z: z + 16
                            })]
                        };
                        mapTable.str["BlockOrientation"] = lua_newtable2(CSPlayer.Map.BlockOrientation);
                        mapTable.str["EmptyBlockID"] = CSPlayer.UInt8MaxValue;
                        return callback()
                    })
                }
            }(this));
            assetClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return registerAssetClass("TileSet", function (tileSetTable) {
                        tileSetTable.str["GetPathInPackage"] = getAssetPathInPackage;
                        tileSetTable.str["GetTileSize"] = function (self) {
                            return [self.str["inner"].tileSize]
                        };
                        tileSetTable.str["GetBlockTypeShape"] = function (self, blockType) {
                            return [self.str["inner"].blockTypes[blockType].shape]
                        };
                        tileSetTable.str["BlockShape"] = lua_newtable2(CSPlayer.TileSet.BlockShape);
                        return callback()
                    })
                }
            }(this));
            assetClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return registerAssetClass("Scene", function (sceneTable) {
                        sceneTable.str["GetPathInPackage"] = getAssetPathInPackage;
                        return callback()
                    })
                }
            }(this));
            assetClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return registerAssetClass("Script", function (scriptTable) {
                        scriptTable.str["GetPathInPackage"] = getAssetPathInPackage;
                        return callback()
                    })
                }
            }(this));
            assetClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return registerAssetClass("Sound", function (soundTable) {
                        soundTable.str["GetPathInPackage"] = getAssetPathInPackage;
                        soundTable.str["Play"] = function (self) {
                            return new CSPlayer.SoundInstance(_this.soundBuffersByAssetId[self.str["inner"].id]).Play()
                        };
                        soundTable.str["CreateInstance"] = function (self) {
                            var sfx, sfxInstance;
                            sfx = self.str["inner"];
                            sfxInstance = new CSPlayer.SoundInstance(_this.soundBuffersByAssetId[sfx.id]);
                            return _this.luaAssetNews[CSPlayer.AssetType.SoundInstance](null, sfxInstance)
                        };
                        return callback()
                    })
                }
            }(this));
            assetClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return registerAssetClass("SoundInstance", function (soundInstanceTable) {
                        soundInstanceTable.str["SetLoop"] = function (self, looping) {
                            var sfxInstance;
                            sfxInstance = self.str["inner"];
                            sfxInstance.SetLoop(looping)
                        };
                        soundInstanceTable.str["GetLoop"] = function (self) {
                            var sfxInstance;
                            sfxInstance = self.str["inner"];
                            return [sfxInstance.GetLoop()]
                        };
                        soundInstanceTable.str["Play"] = function (self) {
                            var sfxInstance;
                            sfxInstance = self.str["inner"];
                            sfxInstance.Play()
                        };
                        soundInstanceTable.str["Stop"] = function (self) {
                            var sfxInstance;
                            sfxInstance = self.str["inner"];
                            sfxInstance.Stop()
                        };
                        soundInstanceTable.str["Pause"] = function (self) {
                            var sfxInstance;
                            sfxInstance = self.str["inner"];
                            sfxInstance.Pause()
                        };
                        soundInstanceTable.str["Resume"] = function (self) {
                            var sfxInstance;
                            sfxInstance = self.str["inner"];
                            sfxInstance.Resume()
                        };
                        soundInstanceTable.str["SetVolume"] = function (self, volume) {
                            var sfxInstance;
                            sfxInstance = self.str["inner"];
                            sfxInstance.SetVolume(volume)
                        };
                        soundInstanceTable.str["GetVolume"] = function (self) {
                            var sfxInstance;
                            sfxInstance = self.str["inner"];
                            return [sfxInstance.GetVolume()]
                        };
                        soundInstanceTable.str["SetPitch"] = function (self, pitch) {
                            var sfxInstance;
                            sfxInstance = self.str["inner"];
                            sfxInstance.SetPitch(pitch)
                        };
                        soundInstanceTable.str["GetPitch"] = function (self) {
                            var sfxInstance;
                            sfxInstance = self.str["inner"];
                            return [sfxInstance.GetPitch()]
                        };
                        soundInstanceTable.str["SetPan"] = function (self, pan) {
                            var sfxInstance;
                            sfxInstance = self.str["inner"];
                            sfxInstance.SetPan(pan)
                        };
                        soundInstanceTable.str["GetPan"] = function (self) {
                            var sfxInstance;
                            sfxInstance = self.str["inner"];
                            return [sfxInstance.GetPan()]
                        };
                        soundInstanceTable.str["GetState"] = function (self) {
                            var sfxInstance;
                            sfxInstance = self.str["inner"];
                            return [sfxInstance.GetState()]
                        };
                        soundInstanceTable.str["State"] = lua_newtable2({
                            Playing: CSPlayer.SoundInstance.SoundState.Playing,
                            Paused: CSPlayer.SoundInstance.SoundState.Paused,
                            Stopped: CSPlayer.SoundInstance.SoundState.Stopped
                        });
                        return callback()
                    })
                }
            }(this));
            assetClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return registerAssetClass("Font", function (fontTable) {
                        fontTable.str["GetPathInPackage"] = getAssetPathInPackage;
                        return callback()
                    })
                }
            }(this));
            index = 0;
            registerAssetClasses = function (_this) {
                return function () {
                    if (index === assetClassSetupFunctions.length) {
                        callback();
                        return
                    }
                    return assetClassSetupFunctions[index](function () {
                        index++;
                        return registerAssetClasses()
                    })
                }
            }(this);
            return registerAssetClasses()
        };
        ScriptAPI.prototype.SetupGameObjectAPI = function (callback) {
            return this.LoadLua("GameObject = {}\nGameObject.__index = GameObject\nfunction GameObject:New(inner)\nreturn setmetatable({ inner = inner }, GameObject)\nend", null, function (_this) {
                return function () {
                    var gameObjectTable;
                    gameObjectTable = _this.lua.str["GameObject"];
                    _this.luaGameObjectNew = gameObjectTable.str["New"];
                    gameObjectTable.str["GetName"] = function (self) {
                        return [self.str["inner"].name]
                    };
                    gameObjectTable.str["SetName"] = function (self, name) {
                        return self.str["inner"].name = name
                    };
                    gameObjectTable.str["CreateComponent"] = function (self, componentTypeName) {
                        var component, componentClass, componentInstance, componentInstanceClass, componentType, obj;
                        obj = self.str["inner"];
                        componentType = CSPlayer.ComponentType[componentTypeName];
                        componentClass = CSPlayer.Components.Component.ComponentTypeMap[componentType];
                        component = new componentClass;
                        componentInstanceClass = CSPlayer.ComponentInstances.Component.ComponentTypeMap[componentType];
                        componentInstance = new componentInstanceClass(obj, component);
                        obj.AddComponent(componentInstance);
                        componentInstance.Awake();
                        _this.gameInstance.componentsToBeStarted.push(componentInstance);
                        return [componentInstance.luaSelf]
                    };
                    gameObjectTable.str["CreateScriptedBehavior"] = function (self, luaScript, propertyValues) {
                        var component, componentInstance, key, obj, value, _ref;
                        obj = self.str["inner"];
                        component = new CSPlayer.Components.ScriptedBehavior;
                        component.scriptId = luaScript.str["inner"].id;
                        componentInstance = new CSPlayer.ComponentInstances.ScriptedBehavior(obj, component);
                        obj.AddComponent(componentInstance);
                        if (propertyValues != null) {
                            _ref = propertyValues.str;
                            for (key in _ref) {
                                value = _ref[key];
                                componentInstance.luaSelf.str[key] = value
                            }
                        }
                        componentInstance.Awake();
                        _this.gameInstance.componentsToBeStarted.push(componentInstance);
                        return [componentInstance.luaSelf]
                    };
                    gameObjectTable.str["GetComponent"] = function (self, componentTypeName) {
                        var componentList, obj;
                        obj = self.str["inner"];
                        componentList = obj.componentsByType[CSPlayer.ComponentType[componentTypeName]];
                        if (componentList != null) {
                            return [componentList[0].luaSelf]
                        } else {
                            return [null]
                        }
                    };
                    gameObjectTable.str["GetScriptedBehavior"] = function (self, luaScript) {
                        var componentInstance, componentList, obj, scriptId, _i, _len;
                        obj = self.str["inner"];
                        componentList = obj.componentsByType[CSPlayer.ComponentType.ScriptedBehavior];
                        if (componentList != null) {
                            scriptId = luaScript.str["inner"].id;
                            for (_i = 0, _len = componentList.length; _i < _len; _i++) {
                                componentInstance = componentList[_i];
                                if (componentInstance.component.scriptId === scriptId) {
                                    return [componentInstance.luaSelf]
                                }
                            }
                        }
                        return [null]
                    };
                    if (_this.gameInstance.gamePackage.scriptAPIVersion < 4) {
                        gameObjectTable.str["GetScriptedBehaviorByScript"] = gameObjectTable.str["GetScriptedBehavior"];
                        gameObjectTable.str["GetScriptedBehavior"] = function (self, scriptName) {
                            var componentInstance, componentList, obj, _i, _len;
                            obj = self.str["inner"];
                            componentList = obj.componentsByType[CSPlayer.ComponentType.ScriptedBehavior];
                            if (componentList != null) {
                                for (_i = 0, _len = componentList.length; _i < _len; _i++) {
                                    componentInstance = componentList[_i];
                                    if (_this.gameInstance.gamePackage.assetFQNames[componentInstance.component.scriptId] === scriptName) {
                                        return [componentInstance.luaSelf]
                                    }
                                }
                            }
                            return [null]
                        }
                    }
                    gameObjectTable.str["GetParent"] = function (self) {
                        var obj;
                        obj = self.str["inner"];
                        if (obj.parentNodeId === CSPlayer.UInt16MaxValue) {
                            return [null]
                        } else {
                            return [_this.gameInstance.nodeTree.nodesById[obj.parentNodeId].luaSelf]
                        }
                    };
                    gameObjectTable.str["SetParent"] = function (self, luaNewParent, keepLocal) {
                        var globalMatrix, index, newParent, obj, oldParent;
                        if (keepLocal == null) {
                            keepLocal = false
                        }
                        obj = self.str["inner"];
                        if (obj.pendingForDestruction) {
                            return
                        }
                        newParent = null;
                        if (luaNewParent != null) {
                            newParent = luaNewParent.str["inner"];
                            if (newParent.pendingForDestruction) {
                                return
                            }
                        }
                        if (!keepLocal) {
                            globalMatrix = obj.transform.GetGlobalMatrix()
                        }
                        if (obj.parentNodeId !== CSPlayer.UInt16MaxValue) {
                            oldParent = _this.gameInstance.nodeTree.nodesById[obj.parentNodeId];
                            index = oldParent.children.indexOf(obj);
                            oldParent.children.splice(index, 1)
                        } else {
                            index = _this.gameInstance.nodeTree.rootNodes.indexOf(obj);
                            _this.gameInstance.nodeTree.rootNodes.splice(index, 1)
                        }
                        obj.transform.object.parent.remove(obj.transform.object);
                        if (newParent != null) {
                            obj.parentNodeId = newParent.nodeId;
                            newParent.children.push(obj);
                            newParent.transform.object.add(obj.transform.object)
                        } else {
                            obj.parentNodeId = CSPlayer.UInt16MaxValue;
                            _this.gameInstance.nodeTree.rootNodes.push(obj);
                            CSPlayer.scene.add(obj.transform.object)
                        } if (!keepLocal) {
                            obj.transform.SetGlobalMatrix(globalMatrix)
                        }
                    };
                    gameObjectTable.str["GetChildren"] = function (self) {
                        var child, children, index, obj, _i, _len, _ref;
                        obj = self.str["inner"];
                        children = lua_newtable();
                        index = 1;
                        _ref = obj.children;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            child = _ref[_i];
                            if (child.pendingForDestruction) {
                                continue
                            }
                            children.uints[index] = child.luaSelf;
                            index++
                        }
                        return [children]
                    };
                    gameObjectTable.str["FindChild"] = function (self, name, recursive) {
                        var findChild, foundChild, gameObject;
                        if (recursive == null) {
                            recursive = false
                        }
                        gameObject = self.str["inner"];
                        findChild = function (obj) {
                            var child, foundChild, _i, _len, _ref;
                            _ref = obj.children;
                            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                child = _ref[_i];
                                if (child.name === name) {
                                    return child
                                }
                                if (recursive) {
                                    foundChild = findChild(child);
                                    if (foundChild != null) {
                                        return foundChild
                                    }
                                }
                            }
                            return null
                        };
                        foundChild = findChild(gameObject, name);
                        if (foundChild != null) {
                            return [foundChild.luaSelf]
                        } else {
                            return [null]
                        }
                    };
                    gameObjectTable.str["SendMessage"] = function (self, funcName, args) {
                        var component, componentsList, func, gameObject, _i, _len, _results;
                        gameObject = self.str["inner"];
                        componentsList = gameObject.componentsByType[CSPlayer.ComponentType.ScriptedBehavior];
                        if (componentsList != null) {
                            _results = [];
                            for (_i = 0, _len = componentsList.length; _i < _len; _i++) {
                                component = componentsList[_i];
                                func = component.luaSelf.metatable.str[funcName];
                                if (func != null) {
                                    _results.push(func(component.luaSelf, args))
                                } else {
                                    _results.push(void 0)
                                }
                            }
                            return _results
                        }
                    };
                    return callback()
                }
            }(this))
        };
        ScriptAPI.prototype.SetupComponentsAPI = function (callback) {
            var componentClassSetupFunctions, index, registerComponentClasses;
            componentClassSetupFunctions = [];
            componentClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return _this.LoadLua("Transform = {}\nTransform.__index = Transform\nfunction Transform:New(inner, gameObject)\nreturn setmetatable({ inner = inner, gameObject = gameObject }, Transform)\nend\nfunction Transform:LookAt( v )\nlocal pos = self:GetPosition()\nlocal diffX = pos.x - v.x\nlocal diffZ = pos.z - v.z\nlocal angleY = math.deg( math.atan2( diffX, diffZ ) )\nlocal planeDistance = math.sqrt( math.pow( diffX, 2 ) + math.pow( diffZ, 2 ) )\nlocal angleX = -math.deg( math.atan2( pos.y - v.y, planeDistance ) )\nself:SetEulerAngles( Vector3:New( angleX, angleY, 0 ) )\nend", null, function () {
                        var transformTable;
                        transformTable = _this.lua.str["Transform"];
                        _this.luaComponentNews[CSPlayer.ComponentType.Transform] = transformTable.str["New"];
                        transformTable.str["SetLocalPosition"] = function (self, pos) {
                            var transform;
                            transform = self.str["inner"];
                            transform.object.position.set(pos.str["x"], pos.str["y"], pos.str["z"]);
                            transform.object.updateMatrixWorld()
                        };
                        transformTable.str["GetLocalPosition"] = function (self) {
                            var pos;
                            pos = self.str["inner"].object.position;
                            return _this.luaVector3New(null, pos.x, pos.y, pos.z)
                        };
                        transformTable.str["SetPosition"] = function (self, luaPos) {
                            var pos, transform;
                            transform = self.str["inner"];
                            pos = new THREE.Vector3(luaPos.str["x"], luaPos.str["y"], luaPos.str["z"]);
                            transform.SetGlobalPosition(pos)
                        };
                        transformTable.str["GetPosition"] = function (self) {
                            var pos, transform;
                            transform = self.str["inner"];
                            pos = transform.GetGlobalPosition();
                            return _this.luaVector3New(null, pos.x, pos.y, pos.z)
                        };
                        transformTable.str["SetLocalEulerAngles"] = function (self, luaEulerAngles) {
                            var eulerAngles, transform;
                            transform = self.str["inner"];
                            eulerAngles = new THREE.Euler(THREE.Math.degToRad(luaEulerAngles.str["x"]), THREE.Math.degToRad(luaEulerAngles.str["y"]), THREE.Math.degToRad(luaEulerAngles.str["z"]));
                            transform.object.quaternion.setFromEuler(eulerAngles);
                            transform.object.updateMatrixWorld()
                        };
                        transformTable.str["GetLocalEulerAngles"] = function (self) {
                            var eulerAngles, transform;
                            transform = self.str["inner"];
                            eulerAngles = (new THREE.Euler).setFromQuaternion(transform.object.quaternion);
                            return _this.luaVector3New(null, THREE.Math.radToDeg(eulerAngles.x), THREE.Math.radToDeg(eulerAngles.y), THREE.Math.radToDeg(eulerAngles.z))
                        };
                        transformTable.str["SetEulerAngles"] = function (self, luaEulerAngles) {
                            var eulerAngles, transform;
                            transform = self.str["inner"];
                            eulerAngles = new THREE.Euler(THREE.Math.degToRad(luaEulerAngles.str["x"]), THREE.Math.degToRad(luaEulerAngles.str["y"]), THREE.Math.degToRad(luaEulerAngles.str["z"]));
                            transform.SetGlobalEulerAngles(eulerAngles)
                        };
                        transformTable.str["GetEulerAngles"] = function (self) {
                            var eulerAngles, transform;
                            transform = self.str["inner"];
                            eulerAngles = transform.GetGlobalEulerAngles();
                            return _this.luaVector3New(null, THREE.Math.radToDeg(eulerAngles.x), THREE.Math.radToDeg(eulerAngles.y), THREE.Math.radToDeg(eulerAngles.z))
                        };
                        transformTable.str["SetOrientation"] = function (self, luaOrientation) {
                            var orientation, transform;
                            transform = self.str["inner"];
                            orientation = new THREE.Quaternion(luaOrientation.str["x"], luaOrientation.str["y"], luaOrientation.str["z"], luaOrientation.str["w"]);
                            transform.SetGlobalOrientation(orientation)
                        };
                        transformTable.str["GetOrientation"] = function (self) {
                            var orientation, transform;
                            transform = self.str["inner"];
                            orientation = transform.GetGlobalOrientation();
                            return _this.luaQuaternionNew(null, orientation.x, orientation.y, orientation.z, orientation.w)
                        };
                        transformTable.str["SetLocalOrientation"] = function (self, luaOrientation) {
                            var transform;
                            transform = self.str["inner"];
                            transform.object.quaternion.set(luaOrientation.str["x"], luaOrientation.str["y"], luaOrientation.str["z"], luaOrientation.str["w"]);
                            transform.object.updateMatrixWorld()
                        };
                        transformTable.str["GetLocalOrientation"] = function (self) {
                            var orientation, transform;
                            transform = self.str["inner"];
                            orientation = transform.object.quaternion;
                            return _this.luaQuaternionNew(null, orientation.x, orientation.y, orientation.z, orientation.w)
                        };
                        transformTable.str["Rotate"] = function (self, luaOrientation) {
                            var orientation, transform;
                            transform = self.str["inner"];
                            orientation = new THREE.Quaternion(luaOrientation.str["x"], luaOrientation.str["y"], luaOrientation.str["z"], luaOrientation.str["w"]);
                            transform.RotateGlobal(orientation)
                        };
                        transformTable.str["RotateLocal"] = function (self, luaOrientation) {
                            var orientation, transform;
                            transform = self.str["inner"];
                            orientation = new THREE.Quaternion(luaOrientation.str["x"], luaOrientation.str["y"], luaOrientation.str["z"], luaOrientation.str["w"]);
                            transform.RotateLocal(orientation)
                        };
                        transformTable.str["RotateEulerAngles"] = function (self, luaEulerAngles) {
                            var eulerAngles, transform;
                            transform = self.str["inner"];
                            eulerAngles = new THREE.Euler(THREE.Math.degToRad(luaEulerAngles.str["x"]), THREE.Math.degToRad(luaEulerAngles.str["y"]), THREE.Math.degToRad(luaEulerAngles.str["z"]));
                            transform.RotateGlobalEulerAngles(eulerAngles)
                        };
                        transformTable.str["RotateLocalEulerAngles"] = function (self, luaEulerAngles) {
                            var eulerAngles, transform;
                            transform = self.str["inner"];
                            eulerAngles = new THREE.Euler(THREE.Math.degToRad(luaEulerAngles.str["x"]), THREE.Math.degToRad(luaEulerAngles.str["y"]), THREE.Math.degToRad(luaEulerAngles.str["z"]));
                            transform.RotateLocalEulerAngles(eulerAngles)
                        };
                        transformTable.str["SetLocalScale"] = function (self, scale) {
                            var transform;
                            transform = self.str["inner"];
                            transform.object.scale.set(scale.str["x"], scale.str["y"], scale.str["z"]);
                            transform.object.updateMatrixWorld()
                        };
                        transformTable.str["GetLocalScale"] = function (self) {
                            var scale;
                            scale = self.str["inner"].object.scale;
                            return _this.luaVector3New(null, scale.x, scale.y, scale.z)
                        };
                        transformTable.str["Move"] = function (self, offset) {
                            var transform;
                            transform = self.str["inner"];
                            transform.MoveGlobal(new THREE.Vector3(offset.str["x"], offset.str["y"], offset.str["z"]))
                        };
                        transformTable.str["MoveLocal"] = function (self, offset) {
                            var transform;
                            transform = self.str["inner"];
                            transform.MoveLocal(new THREE.Vector3(offset.str["x"], offset.str["y"], offset.str["z"]))
                        };
                        transformTable.str["MoveOriented"] = function (self, offset) {
                            var transform;
                            transform = self.str["inner"];
                            transform.MoveOriented(new THREE.Vector3(offset.str["x"], offset.str["y"], offset.str["z"]))
                        };
                        callback()
                    })
                }
            }(this));
            componentClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return _this.LoadLua("Camera = {}\nCamera.__index = Camera\nfunction Camera:New(inner, gameObject)\nreturn setmetatable({ inner = inner, gameObject = gameObject }, Camera)\nend", null, function () {
                        var cameraTable;
                        cameraTable = _this.lua.str["Camera"];
                        _this.luaComponentNews[CSPlayer.ComponentType.Camera] = cameraTable.str["New"];
                        cameraTable.str["CreateRay"] = function (self, position) {
                            var camera, far, near, x, y;
                            camera = self.str["inner"];
                            x = (position.str["x"] - camera.viewportPosition.x * _this.gameInstance.canvas.width) / (camera.viewportSize.x * _this.gameInstance.canvas.width) * 2 - 1;
                            y = (position.str["y"] - camera.viewportPosition.y * _this.gameInstance.canvas.height) / (camera.viewportSize.y * _this.gameInstance.canvas.height) * 2 - 1;
                            near = new THREE.Vector3(x, -y, -1);
                            far = new THREE.Vector3(x, -y, 1);
                            CSPlayer.Projector.unprojectVector(near, camera.actualCamera);
                            CSPlayer.Projector.unprojectVector(far, camera.actualCamera);
                            far.sub(near).normalize();
                            return _this.luaRayNew(null, _this.luaVector3New(null, near.x, near.y, near.z)[0], _this.luaVector3New(null, far.x, far.y, far.z)[0])
                        };
                        cameraTable.str["Project"] = function (self, luaPosition) {
                            var camera, position;
                            camera = self.str["inner"];
                            position = new THREE.Vector3(luaPosition.str["x"], luaPosition.str["y"], luaPosition.str["z"]);
                            CSPlayer.Projector.projectVector(position, camera.actualCamera);
                            return [lua_newtable2({
                                x: (position.x + 1) * camera.viewportSize.x * _this.gameInstance.canvas.width / 2 + camera.viewportPosition.x * _this.gameInstance.canvas.width,
                                y: (-position.y + 1) * camera.viewportSize.y * _this.gameInstance.canvas.height / 2 + camera.viewportPosition.y * _this.gameInstance.canvas.height
                            })]
                        };
                        cameraTable.str["SetFOV"] = function (self, fov) {
                            return self.str["inner"].SetFOV(fov)
                        };
                        cameraTable.str["SetOrthographicScale"] = function (self, scale) {
                            return self.str["inner"].SetOrthographicScale(scale)
                        };
                        cameraTable.str["SetRenderViewportPosition"] = function (self, x, y) {
                            return self.str["inner"].SetViewportPosition(x, y)
                        };
                        cameraTable.str["SetRenderViewportSize"] = function (self, x, y) {
                            return self.str["inner"].SetViewportSize(x, y)
                        };
                        cameraTable.str["SetProjectionMode"] = function (self, projectionMode) {
                            return self.str["inner"].SetProjectionMode(projectionMode)
                        };
                        cameraTable.str["GetFOV"] = function (self) {
                            return [self.str["inner"].fov]
                        };
                        cameraTable.str["GetOrthographicScale"] = function (self) {
                            return [self.str["inner"].orthographicScale]
                        };
                        cameraTable.str["GetRenderViewportPosition"] = function (self) {
                            return lua_newtable2(self.str["inner"].viewportPosition)
                        };
                        cameraTable.str["GetRenderViewportSize"] = function (self) {
                            return lua_newtable2(self.str["inner"].viewportSize)
                        };
                        cameraTable.str["GetProjectionMode"] = function (self) {
                            return [self.str["inner"].projectionMode]
                        };
                        cameraTable.str["ProjectionMode"] = lua_newtable2(CSPlayer.Components.Camera.CameraProjectionMode);
                        return callback()
                    })
                }
            }(this));
            componentClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return _this.LoadLua("ModelRenderer = {}\nModelRenderer.__index = ModelRenderer\nfunction ModelRenderer:New(inner, gameObject)\nreturn setmetatable({ inner = inner, gameObject = gameObject }, ModelRenderer)\nend", null, function () {
                        var modelRendererTable;
                        modelRendererTable = _this.lua.str["ModelRenderer"];
                        _this.luaComponentNews[CSPlayer.ComponentType.ModelRenderer] = modelRendererTable.str["New"];
                        modelRendererTable.str["SetModel"] = function (self, luaModel, clearAnimation) {
                            var modelRndr;
                            if (clearAnimation == null) {
                                clearAnimation = true
                            }
                            modelRndr = self.str["inner"];
                            modelRndr.SetModel(luaModel != null ? luaModel.str["inner"] : null);
                            if (luaModel == null) {
                                clearAnimation = true
                            }
                            if (clearAnimation) {
                                modelRndr.SetAnimation(null);
                                modelRndr.StartAnimationPlayback(true)
                            }
                        };
                        modelRendererTable.str["GetModel"] = function (self) {
                            var modelRndr;
                            modelRndr = self.str["inner"];
                            return [modelRndr.model != null ? _this.luaAssets[modelRndr.model.id] : null]
                        };
                        modelRendererTable.str["SetAnimation"] = function (self, luaModelAnim) {
                            if (luaModelAnim != null) {
                                self.str["inner"].SetAnimation(luaModelAnim.str["inner"])
                            } else {
                                self.str["inner"].SetAnimation(null)
                            }
                        };
                        modelRendererTable.str["GetAnimation"] = function (self) {
                            var animation;
                            animation = self.str["inner"].GetAnimation();
                            return [animation != null ? _this.luaAssets[animation.id] : null]
                        };
                        modelRendererTable.str["StartAnimationPlayback"] = function (self, looping) {
                            self.str["inner"].StartAnimationPlayback(looping)
                        };
                        modelRendererTable.str["StopAnimationPlayback"] = function (self) {
                            self.str["inner"].StopAnimationPlayback()
                        };
                        modelRendererTable.str["SetAnimationTime"] = function (self, time) {
                            self.str["inner"].SetAnimationTime(time)
                        };
                        modelRendererTable.str["GetAnimationTime"] = function (self) {
                            return [self.str["inner"].GetAnimationTime()]
                        };
                        modelRendererTable.str["GetAnimationDuration"] = function (self) {
                            return [self.str["inner"].GetAnimationDuration()]
                        };
                        modelRendererTable.str["IsAnimationPlaying"] = function (self) {
                            return [self.str["inner"].IsAnimationPlaying()]
                        };
                        modelRendererTable.str["GetBlockTransform"] = function (self, nodeName) {
                            var modelRndr, transform;
                            modelRndr = self.str["inner"];
                            if (modelRndr.model == null) {
                                return [null]
                            }
                            transform = modelRndr.GetBlockTransform(nodeName);
                            if (transform == null) {
                                return [null]
                            }
                            return [lua_newtable2({
                                position: _this.luaVector3New(null, transform.position.x, transform.position.y, transform.position.z)[0],
                                orientation: _this.luaQuaternionNew(null, transform.orientation.x, transform.orientation.y, transform.orientation.z, transform.orientation.w)[0]
                            })]
                        };
                        modelRendererTable.str["SetOpacity"] = function (self, opacity) {
                            self.str["inner"].SetOpacity(opacity)
                        };
                        modelRendererTable.str["GetOpacity"] = function (self) {
                            return [self.str["inner"].GetOpacity()]
                        };
                        return callback()
                    })
                }
            }(this));
            componentClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return _this.LoadLua("MapRenderer = {}\nMapRenderer.__index = MapRenderer\nfunction MapRenderer:New(inner, gameObject)\nreturn setmetatable({ inner = inner, gameObject = gameObject }, MapRenderer)\nend", null, function () {
                        var mapRendererTable;
                        mapRendererTable = _this.lua.str["MapRenderer"];
                        _this.luaComponentNews[CSPlayer.ComponentType.MapRenderer] = mapRendererTable.str["New"];
                        mapRendererTable.str["SetMap"] = function (self, luaMap, replaceTileSet) {
                            var map, mapRndr;
                            if (replaceTileSet == null) {
                                replaceTileSet = true
                            }
                            map = luaMap != null ? luaMap.str["inner"] : null;
                            mapRndr = self.str["inner"];
                            mapRndr.SetMap(map);
                            if (replaceTileSet) {
                                mapRndr.SetTileSet(map != null ? _this.luaAssets[map.tileSetId].str["inner"] : null)
                            }
                        };
                        mapRendererTable.str["GetMap"] = function (self) {
                            var mapRndr;
                            mapRndr = self.str["inner"];
                            if (mapRndr.map != null) {
                                return [_this.luaAssets[mapRndr.map.id]]
                            } else {
                                return [null]
                            }
                        };
                        mapRendererTable.str["SetTileSet"] = function (self, luaTileSet) {
                            var mapRndr;
                            mapRndr = self.str["inner"];
                            mapRndr.SetTileSet(luaTileSet != null ? luaTileSet.str["inner"] : null)
                        };
                        mapRendererTable.str["GetTileSet"] = function (self) {
                            var mapRndr;
                            mapRndr = self.str["inner"];
                            if (mapRndr.tileSet != null) {
                                return [_this.luaAssets[mapRndr.tileSet.id]]
                            } else {
                                return [null]
                            }
                        };
                        mapRendererTable.str["SetOpacity"] = function (self, opacity) {
                            self.str["inner"].SetOpacity(opacity)
                        };
                        mapRendererTable.str["GetOpacity"] = function (self) {
                            return [self.str["inner"].GetOpacity()]
                        };
                        return callback()
                    })
                }
            }(this));
            componentClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return _this.LoadLua("TextRenderer = {}\nTextRenderer.__index = TextRenderer\nfunction TextRenderer:New(inner, gameObject)\nreturn setmetatable({ inner = inner, gameObject = gameObject }, TextRenderer)\nend", null, function () {
                        var textRendererTable;
                        textRendererTable = _this.lua.str["TextRenderer"];
                        _this.luaComponentNews[CSPlayer.ComponentType.TextRenderer] = textRendererTable.str["New"];
                        textRendererTable.str["Alignment"] = lua_newtable2(CSPlayer.ComponentInstances.TextRenderer.TextAlignment);
                        textRendererTable.str["SetFont"] = function (self, luaFont) {
                            var textRndr;
                            textRndr = self.str["inner"];
                            textRndr.SetFont(luaFont != null ? luaFont.str["inner"] : null)
                        };
                        textRendererTable.str["GetFont"] = function (self) {
                            var textRndr;
                            textRndr = self.str["inner"];
                            if (textRndr.font != null) {
                                return [_this.luaAssets[textRndr.font.id]]
                            } else {
                                return [null]
                            }
                        };
                        textRendererTable.str["SetAlignment"] = function (self, alignment) {
                            var textRndr;
                            textRndr = self.str["inner"];
                            textRndr.SetAlignment(alignment)
                        };
                        textRendererTable.str["GetAlignment"] = function (self) {
                            var textRndr;
                            textRndr = self.str["inner"];
                            if (textRndr.font != null) {
                                return [textRndr.alignment]
                            } else {
                                return [null]
                            }
                        };
                        textRendererTable.str["SetText"] = function (self, text) {
                            var textRndr;
                            textRndr = self.str["inner"];
                            textRndr.SetText(check_string(text))
                        };
                        textRendererTable.str["GetText"] = function (self) {
                            return [self.str["inner"].text]
                        };
                        textRendererTable.str["SetOpacity"] = function (self, opacity) {
                            self.str["inner"].SetOpacity(opacity)
                        };
                        textRendererTable.str["GetOpacity"] = function (self) {
                            return [self.str["inner"].GetOpacity()]
                        };
                        textRendererTable.str["GetTextWidth"] = function (self, text) {
                            return [self.str["inner"].GetTextWidth(text) * CSPlayer.GlobalSizeMultiplier]
                        };
                        return callback()
                    })
                }
            }(this));
            componentClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return _this.LoadLua("ScriptedBehavior = {}\nScriptedBehavior.__index = ScriptedBehavior\nfunction ScriptedBehavior:New(inner, gameObject, behavior)\nreturn setmetatable({ inner = inner, gameObject = gameObject }, behavior)\nend", null, function () {
                        _this.luaComponentNews[CSPlayer.ComponentType.ScriptedBehavior] = _this.lua.str["ScriptedBehavior"].str["New"];
                        return callback()
                    })
                }
            }(this));
            componentClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return _this.LoadLua("Physics = {}\nPhysics.__index = Physics\nfunction Physics:New(inner, gameObject)\nreturn setmetatable({ inner = inner, gameObject = gameObject }, Physics)\nend", null, function () {
                        var physicsTable;
                        physicsTable = _this.lua.str["Physics"];
                        _this.luaComponentNews[CSPlayer.ComponentType.Physics] = physicsTable.str["New"];
                        return callback()
                    })
                }
            }(this));
            componentClassSetupFunctions.push(function (_this) {
                return function (callback) {
                    return _this.LoadLua("NetworkSync = {}\nNetworkSync.__index = NetworkSync\nfunction NetworkSync:New(inner, gameObject)\nreturn setmetatable({ inner = inner, gameObject = gameObject }, NetworkSync)\nend", null, function () {
                        var networkSyncTable;
                        networkSyncTable = _this.lua.str["NetworkSync"];
                        _this.luaComponentNews[CSPlayer.ComponentType.NetworkSync] = networkSyncTable.str["New"];
                        networkSyncTable.str["Setup"] = function (self, id) {
                            var networkSync;
                            networkSync = self.str["inner"];
                            if (networkSync.syncId !== CSPlayer.UInt32MaxValue) {
                                console.error("Network sync was already setup")
                            }
                            _this.gameInstance.RegisterNetworkSync(networkSync, id)
                        };
                        networkSyncTable.str["SendMessageToServer"] = function (self, id) {
                            var networkSync;
                            networkSync = self.str["inner"];
                            console.warn("NetworkSync.SendMessageToServer: Not yet implemented")
                        };
                        networkSyncTable.str["SendMessageToPlayers"] = function (self, id) {
                            var networkSync;
                            networkSync = self.str["inner"];
                            console.warn("NetworkSync.SendMessageToPlayers: Not yet implemented")
                        };
                        return callback()
                    })
                }
            }(this));
            index = 0;
            registerComponentClasses = function (_this) {
                return function () {
                    if (index === componentClassSetupFunctions.length) {
                        callback();
                        return
                    }
                    return componentClassSetupFunctions[index](function () {
                        index++;
                        return registerComponentClasses()
                    })
                }
            }(this);
            return registerComponentClasses()
        };
        ScriptAPI.prototype.SetupLuaGameObject = function (obj) {
            return this.luaGameObjectNew(null, obj)[0]
        };
        ScriptAPI.prototype.SetupLuaComponent = function (component) {
            return this.luaComponentNews[component.componentType](null, component, component.gameObject.luaSelf)[0]
        };
        return ScriptAPI
    }()
}).call(this);